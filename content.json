[{"title":"回忆录 & For Friends","date":"2021-08-24T06:54:55.000Z","path":"posts/26649ddc.html","text":"大型回忆录 通过目录可直达某一个人 有修改。 趁着没人 说点真心话 1 老师 孙老师 勤勤恳恳跟了我们三年的班主任，在进行赞扬和批判之前 首先值得尊敬。 其实在孙老师身上看到最多的是矛盾这个词，孙老师也引发过我对这个世界对错的很多思考。得出的结论是，世间没有上帝，所以世间本无黑白对错之分。 孙老师风格变化莫测，且音调极高。上课喜欢讲人生道理，中考之前喜欢拉着我到处谈话。 对打饭事业十分支持，有时候甚至对矫辰特赦打饭。 经常鼓励我们自己去查东西，可惜大家脑子都是这样，于是完成度感人 有时候拉着同学们找地方走路。散步这件事刻在孙老师的DNA里，网课时候散步开班会，天天早晨咕咚上面跑，放了假还不忘拉着同学们徒步 当然参与人数感人 其实也挺好 就是我比较懒 不怎么去罢了 现在倒有点后悔 对孙老师和世上所有一心为别人却不了解方法的人 以最真诚的祝福。 雷老师 神仙老师 神仙姐姐！ 印象最深 教哪个班哪个班第一 说实在的 雷老师是我见过最神仙的老师 不论在外表还是教学 还是除了这两样以外的任何方面 雷老师办公室氛围超级好 可惜自己融不进去。有几次（不对 是一直 直到现在）想和雷老师深入交流一下 结果还是自己开不了口 照雷老师的描述 感觉自己像一班人 不善表达 倒很擅长杀死话题（照这么说 有的时候连话题都不能好好杀死 自己在这一方面确实一无是处） 雷老师身上最大的是亲和力 一种 任何时候看起来都不会反感的气质。我贫瘠的语言描述不出这种超然物外的气概，只想说我爱语文老师。 希望几年后再回来，还能在雷老师身上找回这种感觉——假如雷老师还当老师的话。不然，一句前程似锦，也应该送给雷老师。 杨老师 “年龄和学识加起来，组成了他的外表” 杨老师又是与雷老师不同类型的 另一种亲和力。是那种 朴实无华 真诚 有点憨厚的感觉（原谅一个憨厚的人说另一个人憨厚 但我感觉就是这样）。课堂氛围极好 这或许是最重要的。名言 我印象最深的 “没有我做不出来的动点题”。即使那时我不了解杨老师的真实年龄，但我还是觉得这是一种恃才傲物 意气风发的感觉 希望有天这话能从自己嘴里出来 而且是在学生时代 算了算了 做人还是内敛点好（ 陈老师 尽管音乐美术老师在初中生活中并不常见 但陈老师确实对我有很大影响 包括但不限于玩调音台 组织活动 搞LED 然后整个人变得更沉稳 履历内容还更加丰富 我这人不大会说话 但确实感受到陈老师身上独特的魅力 陈老师对导演组一众人都特别好，和无数学长保持联系，一代代导演组 毕了业都能成神 办公室位置靠窗，至少我认为是个绝佳的位置。可能我是比较正经不苟言笑的人，所以陈老师和我也比较正经 三年其实学会了不少东西，干了许多活，在陈老师的电脑上留下宝贵的痕迹 不过说实话，我自己干的活也不算多，形象也不怎么正常，然后还白搭着一个主席的名头丢脸 也是托陈老师的喜爱（（ 给陈老师以真诚的感谢。 分分合合，其实我们都一样。 惠老师 （虽然我没惠老师好友 但我还是想说） 其实惠老师表面上有点暴躁 内心还是很平和的 至少你有个什么正常的问题去问她 她还是非常乐意解决的。这是一个标准的大大咧咧且不拘小节的模子 多说一句 虽然我没经历过很多次 但罚抄方程式实在是太吓人了 2 同学 马宇轩 myx是最好的朋友之一，或许连之一都没有，即使已经一年不怎么见面。这一年里我俩的联系也挺密切，有时候我会跟他讲讲学校里的事情，有时候他会找我帮忙，或者讲讲他人生中的大事（确信）。myx商赛的时候有天我花了两个晚上给他搭了个网站 域名一年 不怎么维护了： usefulltechs.cf 不知道这算不算brotherhood 但我觉得差不多 那种感觉我体会的次数不多 只是两个人在一起 甚至电话两头 微信两边 不用多说话 就能感受到彼此的存在。 希望这种感觉会持续下去。 现在看来 只能说myx运气很好 能力很强。国外看起来是不错的选择 毕竟国内内卷实在太厉害 想了半天想到一个词 brilliant 或者用中文说 热忱 虽然不是一个意思 但我觉得都特别适合这个人。 一路星光，前途无量。 李佩璇 myx走掉之后，没什么真正的朋友了，毕竟咱班男生实在太少。很负责任地说，佩璇是人生路上重要的朋友，标准的神仙 印象最深的是 做什么事情都看起来有条不紊 站起来能一说说很多还不带前摇 不管讲话还是学习都比自己稳太多了 另外就是 佩璇到哪里都有特别成熟的感觉 像个姐姐或者妈妈。并不是说未老先衰，而是天生和后天结合成的 浑然一体的稳重。 希望没看错人。 多说一句 佩璇这种志向明确座右铭明确的人确实少见（ 一诺 小神仙。心理年龄极小，但先天智商极高，甚至高过佩璇。 人过的单纯 不能说没心没肺 只能说除了学习无忧无虑 自然会天天笑 潜力无限。这句话的确非常适用。拿来就考，考完吓倒。 尤其是物理，震惊阿泽一百年。 特别重视分数，写作业的时候却又不那么重视。不知道长了几个肝，但是历史课却神志不清 “但愿你的道路漫长， 但愿那里有很多夏天的早晨。” 胡昊亮 另一个好朋友 hiphop爱好者 我从这里入的门 情商高过智商 经历丰富 然而老天对他不怎么好 仅此而已。 不知为何少白头 但我不觉得这是什么好兆头。或许是命运注定 或许是欲扬先抑。不论如何，未来就在那里，不会改变。想起那些日子在晚饭时谈论人生理想 科学黑洞 世界毁灭 谈天说地 扯来扯去 倒有种说不出来的自在 可惜自己当时意志不够坚定 没整理出来《论人类如何灭亡》 不然这里的内容可能会更多（ 在脑海里搜了半天 想起一个词 叫志同道合。可惜道已不再合。平常在一起的时候并不觉得如何，分别时分才后知后觉 可惜再珍惜 时光也就这么过去了。 “如果你总是异常清醒，生活将不堪忍受。” 祝一路好运！好运！ 陈心语 每个班都会有一个女孩子被喊哥。 陈哥出名外向，身上像有个小太阳。据说武艺高强，擅长和任何人相处，包括男生和女生，也包括老师。 一直很羡慕这种白天到了随便一群人中都能混得熟的能力，也在深夜感受到一个灵魂是如何的脆弱。 看到一点自己的影子。可惜自己白天过得不如人家，晚上过得也不如人家。 曾经特别喜欢陈哥的笑，还有那份坦诚和直率。希望上帝不会把这份棱角磨平。 生活中又要离开一个这样神仙的女孩子，莫名有些伤感。 “读很多的书，走很多的路。交很多朋友，看很多风景。爱很多人，也被很多人爱。” 李兆阳 一对好朋友就要放在一起写。 兆阳和陈哥性格极度相似 导致这两个人一出现就让很多男孩子闻风丧胆（我找不出高端的词了 只能这么说 希望不要打我 和兆阳当过一阵子同位 一开始觉得这是个儒雅随和还挺可爱的女孩子。后来过得越久知道的越多，才明白兆阳身上的故事可能几天也讲不完。 我和兆阳真没啥，我倒也很佩服兆阳身上这种独特的魅力。没准这就是天生的体质，下辈子咱也想要一个。 深不可测，绝了。上哪找这种智商情商都爆炸的女生啊。 “人就这么有限的心力，你一定要把它专注地拿去用在你最在乎的事情上。” 吴欣玥 一直不敢写这个人，怕驾驭不了这种神仙的性格 咱班女生神仙真多。 性格有点孤僻，过的很累的一个人——至少我这么猜。当然，如果你很享受你的初三生活，请收下我五体投地的佩服。 一个潜力无限的女孩子。我的意思是 总能干出很多出乎意料的事情，不论是在学习上还是学习以外。三班阴阳怪气的鼻祖。说实在的 有的时候笑起来也很累。咱到现在也不知道她到底喜欢过多少人，也不知道她的上限到底在哪。 挺好的，院长喜欢这种类型，比那种整天一言不发的病人好多了。 另外，又是一个情商极高的女孩子，可能只是命运不大好罢了。 像我亮亮，却又不大像。 “有人生来就被长夜环绕，有人生来就被幸福拥抱。” 赠品：歌 梁博 《男孩》 毛仕林 智商极高的男孩子，却不知为何写不好字。可能字如其头，都是天生弯弯曲曲。 毛仕林是三年的体育委员。不得不说，极为称职。骨子里有那种拼劲，身上有那种热血。 擅长和女孩子还有男孩子相处，这点我也极为佩服。我爸评价这个人很健谈，我觉得没毛病。 毛仕林可能具有天生的运动天赋。腿虽然挺短但是爆发力极强，在三班打饭队被称作土拨鼠。 （恕我直言，这个外号太过形象 再就是 很有责任感 能主动承担责任 很好的朋友！一路好运！ 杨景川 特点鲜明的男生，不知为何老是像个女孩子。 总结了很久，发现可能是骨子里不够果断。怕什么怕啊，仅此而已。 景川智商还算正常，虽然性格有些并不阳刚，但不影响他身上奇怪的魅力。这种魅力在男生间表现为每次都被欺负，在女生间表现为超受欢迎。 可能投胎时候脑子一糊涂走错边了 人应该要自信点 但有时候自信起来还是没有办法 导致我也不知道该怎么救这个人 上了高中换个环境！相信自己！ “爱每一个今天吧。耀眼一点，你 有资格。” 逄颜宁 9年老同志 义务教育路上的好朋友 外表人畜无害，温柔可爱，了解多了发现内心世界奇奇怪怪，奇怪到院长都觉得厉害。 有一只兔子伙伴，一人一兔在朋友圈形影不离。梅梅好朋友，罚抄鬼头令。 说实话，逄颜宁任何时候的存在感都不算很强，至少与她的成绩不相符。 找到词了，对外人并不主动，但对好朋友极好。极有特色的女孩子。 一路好运，愿桥都坚固，隧道都光明。 王雅楠 相由心生的验证者。 性格和外表一样有点憨厚的老实，但脑子是真好用。 一个很深的印象是，在刚入学的时候，我就注意到雅楠声音特别有磁性，特稳重的那种，可能和很多个人因素有关。 尽管当时我连她叫啥都不知道。 雅楠一直是很正常的一个人，干什么事都特别认真，板板正正，极为标准。在中考前擅长踩各种奇奇怪怪的雷 另外就是包容了矫辰特别久 这个事我一直佩服雅楠，同时还觉得有点可惜。我觉得换我受不了几天。 命中注定的事了，让一切过去吧。 “云蒸霞蔚，前途似锦。” 李知晓 心理年龄极小 有点幼稚的男孩子 长的很喜剧的一个人 尤其是刚上初一 没戴眼镜的时候。那天翻出一张照片，差点当场笑死。 擅长与女孩子和男孩子沟通，如果要比较的话，我觉得更擅长女孩子。据院长这些年的观察他有对女孩子的受虐倾向，不知道怎么表述这种症状。 另外是一个挺可爱的人，重视朋友，包括女性朋友。会跟着所有人一起沙雕，会在课堂上大声说出自己的想法（确信 喊打饭喊的最大声的一个，虽然不是打的最好的 但是估计是受伤第二重的 第一是我副院长（默哀 祝前途光明，能碰上好人和好的朋友。 “生活总是这样，夜晚卸下白昼，新梦卸下旧梦 ” 李佳鑫 三班打饭队代表人物 由于又老又黑被称作老黑（确信 众所周知 老黑极具体育天赋，表现在经常和土拨鼠抢一千米第一名，还有打饭时候跑的最快。 不知道健康的肤色是不是因此养成 孙老师的干儿子，班主任特派秘书，待遇是每次上课都被拿来举 很好的例子（ 有时候干事情特别认真，特喜欢唱歌且极度自信。特喜欢约球，这算吗，可惜我时间总是不巧，导致去的次数极少 希望老黑能遇到一个正常的班主任 也希望老黑自己更加peace（ 祝一路好运！ 唐鸣远 三班打饭队代表人物 小小年纪双目失明且全身瘫痪 咱也不知道他怎么就莫名其妙的瘫痪了，现在的院长十分佛系，只能祝福他永远瘫痪。 平常是存在感不强的人和语文课代表，但在打饭的时候极为神勇，瘫痪起来也是进展极度顺利。 这件事情似乎能激发班级荣誉感） 不管如何，都有些一鸣惊人的感觉 希望下次是在成绩上！ 祝99！祝前途无量！ 李柳宣 很努力阳光的女孩子 能努力到逼自己，也特别真诚的问过我怎么学习，可惜努力了有时候改变并不明显，让我这个挺懒的人无地自容。 分析了很久，觉得是天生悲剧。很多老师讲假努力真努力的区别，我曾经相信努力一定体现在成绩上，但这个人第一次让我动摇。 另外 实在是太正能量了 太正了 比我正一万倍 自己心情崩了甚至能从这里获得一些支持 剧本是命运写的，微笑着读下去就好了。 凌雪 走出国门的代表者，虽然有时睡不够。 颇有大姐大的风范，无论是在物理上还是在精神或言行上。 孙老师的雪儿，上课精神状态的航标。有让人羡慕的条件和目标 ，不过这里祝早日雅思（ 曾经热爱体育，尤其是打饭事业，不知道现在怎么样。可以肯定的是，颜值和智商，都在前路上成长。 “做你自己，因为别人都有人做了。” 董思含 智商正常，也愿意努力，做事极度认真 只可惜多干跟学习沾边的事就行了。 佩璇的好朋友，梅梅的宠儿 人的外貌极佳，性格也很棒，而且笑起来像傻笑（确信） 似乎也愿意按部就班的学习。现任是吴世勋，别问我为什么写这个 啊对，感情史丰富，直到现在。 虽是离别，却有点伤感。两条完全不同的人生轨迹，在某个点相交以后，只会越走越远。 “不要执着于别人的认可或赞美，过自己的人生。” 于新雨 老于 人如外号，不是未老先衰，是肉体和行为组合起来形成的独特灵魂，被一个普通而精辟的词概括 谁第一个这么喊的 简直绝了 人特老实，干什么事都看起来认认真真。写字的风格自成一派，能张牙舞爪，也能认认真真。 能画画，我把人分为两类，大部分女孩子属于能画画这一类，老于应该属于比较靠前的，我属于手残的那一类。印象最深的是那天画黑板报，老于和一群人对着黑板疯狂输出，院长只能在下面看着心灵手巧的女孩子们哭。（skr 杨大宝的好朋友，昆昆的宠儿。道法课代表虽然不是人干的，但干完之后还是人就很佩服 智商在线，人也特勤奋。按我说，哪天突然开窍直接起飞，应该不是问题。 未来可期！去九中好好吃饭！ 李叶青 舞蹈生！ 一直特羡慕学舞蹈的孩子，至少走路不会顺拐，坐位体前屈不会零分。叶青搞得是民族舞，虽然我不了解这些，但我觉得民族舞衣服的色调总是奇奇怪怪，一会绿色一会蓝色（其实挺好 艺术这东西 我不理解太正常了 和老于有亲属关系，据我观察是母女 声音的音调有些高 皮肤对光的吸收能力较强。 地理课代表，亮亮的好朋友，姜伟的宠儿，是某著名定律首当其冲者（笑 祝前程似锦！去一中好好吃饭！ 康承民 康哥 真正的大哥 人有时候有些邋遢， 有奇怪的头发，但是人很实在，没有坏心思的那种。只不过遇到小女生会用奇怪的方式表达想法，往往把人家吓得不轻。康哥吃完饭会在学校的各个角落闪现，也不知道干啥，另外康哥还是男厕歌霸。 和妈妈形成强烈反差。康哥妈妈是特别细心能干还关心集体的那种 康哥奇爱历史，然后历史成绩上天。能一本正经的唱国际歌，也能义正言辞的讲毛主席。还特别爱分享故事，具体表现为看到外教或萌萌老师或阿泽就冲过去开讲。虽然我不知道他们在讲什么，听懂了多少，但我还是对两边都特别佩服。 康哥爱研究历史，没准能成为他以后人生的方向。我第一次见对某一门学科如此执着的人，也希望康哥能在自己的道路上一鸣惊人。 “人们在千百条道路的十字路偶然相逢，却并不知道他们以往的全部生活正是为这次相逢做准备。” 刘雅琪 6+3年同学 画画超好的美术生 拿着58的分去报17 社会资源浪费者 记得当年超级擅长画人物 画出来的女孩子超级好看www 印象中学工时候分在一组 人家画那盘子惟妙惟肖 然后还留在那里展览了 就特羡慕然后佩服 鬼知道咱画了个啥 当年 指小学的时候 和大董雅琪都是好朋友 父母都认识 经常三家一起出去的那种。时过境迁，三个人几乎三年没在一起见过，莫名有些感慨。可惜徒一颗初心，抵不过红尘滚滚罢了。 总体来说，超级佩服的一个人。有天生的艺术细胞，有难以想象的坚持。 “留一点回忆给未来，留一点氧气给郊外的紫苜蓿。” 苗欣璞 学弟 超阳光的男孩子 爱打球 特能干活 导演组的主力，gk球队接班人 一起干完了毕业典礼的活，紧接着都要各奔东西。现在青岛中学和隔壁HWS是我心中义务教育两大黑洞，逃离中国体制的捷径 然后人特友善 很有趣 也是特别正的朋友 一路好运！希望能逃中考！ 王梓岳 学弟 第一个定下来的导演组成员 搞编程 也特能干。从初一开始就在干活 曾经跟着我有也特别愉快的一年 初一的时候超级可爱 真的 然后过了两年也长大了 人也变稳很多了 学习超级好！学霸！半个神仙！ 新班主任好像是阿泽！ 好好学习！阿泽强！ 希望化学老师不是梅梅（ 杨景文 再小一届的学弟 体验了初一六点半放学 特地写写他 因为我觉得我俩是一个模子里刻出来的 无论是长相还是爱好都特别像当时的自己 可惜没有一起的照片uhhh 我初一也超爱听家驹的 干活很利索 然后脑子也特好用 学东西超快的那种 好好学习叭 希望国开不会继续变态了（ 何承霖 氯化氢 初一我认识的第一个人 在去军训的车上坐我旁边吐 初中三年锰蹿个子还瘦了不少 啊说到这我就想起亮亮（都给我哭 除了学习啥都行，某人朋友圈第一名，梅梅说话最爱听 skr 印象最深的是晚会上模仿惠老师 绝了 不知道有没有人录像 打饭也完全OK 毕竟身高快上天 梦想当控卫（确信 生来和化学联系紧密，梅梅的宠儿 国科大 好好学化学！ 赵宝沣 人挺憨 特别能唱歌 有嗓子的男人 虽然智商守恒 但能干什么事都特别认真 很难相信没有成绩 热爱嘻哈 印象深刻 曾经在没有人的地方一起蹦 不知道有没有被监控室大爷当成病人抓走 那天回家还写一言了 写了一坨 有兴趣也不建议翻 因为太久远了 不了解和杨大宝是什么关系 几年了没摸透 干活卖力 这是认真的 尤其是班级文艺活动 演过树獭 每次唱歌都是最大声的 唱到嗓子爆炸为止 还成功塑造了岳肥的千古形象 成为三班一切朗诵的常客 希望以后还能发挥自己身上的个性好叭 爱嘻哈 就坚持自己 反正自己不尴尬 尴尬的就是别人 冲 相信自己 补一句 阳寿三分（（ 孟俊廷 特地写一写 毕竟人没了 还是有点想念（ 写的可能是两年前的人了 wxy的好朋友 林黛玉的转世 三班女生身高第二顶梁柱 声音有点小 但从现在的回忆来看 还蛮中听 然后是人性格如声 都是并不外向 如果非要做个比喻 我觉得像小猫。 有过故事 好像当过一段时间同位 放学时候能一群人走到车站 是初一为数不多记忆里的重要组成部分。虽然但是 实在想不起来谁第一个喊的饕餮 再就印象里经常请假 尤其是后面初二往后 就一切特点都符合黛玉 除了不会喷脏字（ 反正这类人物在后来都成了神话 多说一句 王金泽 现在在2019级三班 不知道过的怎么样 根据观察跑去了即墨 不知道为什么。 故事总有人续写，未来一路好运。 高亦翚 从小学一路走过来的好兄弟 应该不是九年 但忘了哪年 过了三年再看 感觉苍老了许多（ 名字有个生僻字 风评被害 被念成各种奇奇怪怪的音 不要百度 在评论区留下你们读出了什么（（ 小学的时候翻过字典 释意为：五彩羽毛的野鸡 记得初一时候天天一起坐车 人脑袋上一直糊个白帽子 印象中手机没换过 壳后面一直贴着某张照片（？ 然后我俩喜欢研究各种奇怪的东西 有时候搞车站学术 有阵子打你行你上 还有时候研究奇怪的APP 包括但不限于美服BS/烧杯… 平常我俩话不多，但真的是好朋友 多说两句 翚这个假期是真的闲（ 58自招！神仙！ 永远的兄弟！一路好运！ 矫辰 又爱又恨，这个人让我哭笑不得。 课堂氛围组组长，老孙的宠儿 打饭活跃分子 却是唯一一个负数 人够义气，真的，官方认证。对朋友特别好，不管是男性还是女性朋友，有时候也藏不住自己的想法 和lzx并称男子1km两大黑洞，梅梅一见就特别激动 再一个事是，初一第一个周，一个组 拿了第一。现在回想起来这个阵容简直不可思议，其他成员包括康哥，杨大宝，pyn等 总之是很神奇的组合 暂且认为人写字特别好！15！ 加油！ 刘钰 身高感人 “清纯女学生”（明显引用 人其实印象不深。只是初三一换眼镜，让康哥大为震撼 不过有一说一，气质确实不大一样。 卑微的英语课代表，好像从来没在哪节课前喊过老孙 八上被老孙奶过，不过那场期末考试确实出现了太多人才 人不怎么拐弯抹角，是很放心的类型。声音略有点沙哑，可能是变声期不小心过了头。然后干事收作业认认真真 确实是 挺努力和有趣的类型 继续努力！要相信自己更优秀！ 王绎乔 大姐大 在小学隔壁班 印象中和松乐哥哥是好朋友 六年级才有印象 但说实在 第一印象不是太好 和老孙相爱相杀 唯一一个和老孙顶嘴的人 但老孙说她能笑着接受批评还不会生气 行走在时代的前列腺，游离在课堂的终点站。（就想压个韵，勿喷 真爱语文雷老师。曾经勇夺语文班级第二，当然只是算了选择题 但选择都能糊对也是真强 所以说热爱的力量是无穷的 加油！未来也要有所爱！ 付馨宇 摸不透的一个人，原谅我做了一阵同位之后也只能做出这个评价。 性格有些孤僻，恕我直言。当然性格相同的人待在一起，那是最好。 主要是建议吧，就相信自己，然后稍微开朗一点 乐观一点就好啦 祝一路好运！希望遇到知心的人！ 刘佳怡 说实话，要我说，人存在感其实不算很强 属于灰色地带的半透明 曾经的地理课代表，某著名定律的受害者之一 其实人看起来特别认真 也许缺少一点自信 无论如何 也要试着展露自己的锋芒。 一路好运！ 王欣媛 体积小 但是能量不小 曾经 印象最深 是在开学第一节英语课上第一个发言。应该是拿去写个什么作文。还记得名字是Jessica虽然写的有点问题 但不得不说，特别勇敢。 成绩不算拔尖，但速度超快，还是让我特别佩服 人挺努力，也被老孙奶过，被整天拿来当矫辰的板子（（ 差不多到这里 希望能更努力 相信自己！祝好运！希望不和康哥一个班（（ 吴韫泽 人特好 然后特别爱交朋友 一个人剪毕业视频 那时候天天一起 很高 被我爸评价特别有篮球天赋 尤其是肚子以下 腿以上的某个部位 然后就也挺努力的吧 经常问我一点学术问题 中考过去就过去啦 未来好好努力就好！去拿级部第一给gk争光！ 邓天舟 隔壁一班的女孩子 老黑的好朋友，老管的接班人 说实话，一班有一种班级文化 我这辈子体会不来 表现起来就是每个人都看着奇奇怪怪 但又莫名其妙的一致 人体积不大 但是长相声音都特别OK 性格也很开朗啊 再就不知什么时候开始变成老黑的好朋友 然后在谢师宴上风评被害（（ 一路好运！去小MT当神仙！ 王嘉言 神仙&amp;雷老师的好朋友。 实在想不通，人怎么能做到学习能学好，还每个课间往楼下跑 可能这就是爱吧。我不理解。 不过爱能促进学习 我好像又理解了 算了算了 这玩意不归我管。但说实话，这种…感情？情感？总之我也很佩服。 也羡慕。 人特和蔼，脾气也好，斯斯文文 特别爱认亲，尤其是晚辈 再就 考自招的时候一直一个考场 人强还帅！数学！无敌！Orz！ 杜婧 隔壁班的女孩子 体积特小 但干活是真利索 声线特别低 有年艺术节去唱歌，深刻意识到了这一点 在我印象里人很正经 然后学习也特好 头像常年不换，但是一换就完全认不出来 也是58神仙了！前程似锦！多吃饭！多长个！ 杜晨 隔壁班体育委员，一副嗓子声震全校（字面意思 58自招挂掉了，但是中考还是很稳 导演组，人特能干，能抗下所有锅 不过毕业典礼跑路当主持人去了 现在看来啥都能干，还是很强 然后羽毛球打的特好 篮球是定点投手 每次都拉着我去定投 强！在58继续无敌！ 李俊辉 58自招rk4 真就是巨佬 人特谦虚 苟来苟去 据传言课堂游离，见题无敌 考试学习特别稳 中考数学120 Orz 人讲话晃来晃去，但没办法，这就是大佬风气。级部第一常客，语数英都能考，恐怖如斯 曾经一起搞OI 在初中之前就认识 可惜搞到一半退役 留下我一个人被OI摧残（（ 神仙！加油！清北！裸分！无敌！ 武佳文 神仙，在数学分层大杀四方（（ 人是真强，xes巨佬 已经不知道学到哪了 反正仰望就对了 人特真诚 然后面相就像学理科的 去了隔壁数学MT 没能羟基可可惜惜 真诚的祝好运！相信自己！Orz document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"其他","slug":"其他","permalink":"https://lzylzy.cf/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"P3469 [POI2008]BLO-Blockade","date":"2021-08-24T03:41:32.000Z","path":"posts/f8cd28ba.html","text":"题目描述 给定一张无向图，求每个点被封锁之后有多少个有序点对(x,y)(x!=y,1&lt;=x,y&lt;=n)满足x无法到达y 题解 求割点，就是有些细节要注意 对于每个点，首先判断他是不是割点 如果对于一个儿子v，low[v]&gt;=dfn[u]low[v]&gt;=dfn[u]low[v]&gt;=dfn[u]，则说明这个点为割点 这时答案累计上size[v]∗(n−size[v])size[v]*(n-size[v])size[v]∗(n−size[v]) 在最后，还需要累计一个n−1+(sum+1)∗(n−sum−1)n-1+(sum+1)*(n-sum-1)n−1+(sum+1)∗(n−sum−1),其中sum表示所有符合割点条件的儿子的size总和 如果不是割点，答案为2∗(n−1)2*(n-1)2∗(n−1)，即自己到达不了任何点 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 100009 ll n; int m; vector&lt;int&gt; son[maxn]; int low[maxn],dfn[maxn],cnt=0; int root=1; ll size[maxn]; ll ans[maxn]; bool gd[maxn]; void tarjan(int x,int fa) { size[x]=1; cnt++; dfn[x]=low[x]=cnt; int sons=0,sum=0; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; //if(to==fa)continue; if(!dfn[to]) { tarjan(to,x); size[x]+=size[to]; low[x]=min(low[x],low[to]); if(low[to]&gt;=dfn[x]) {//这个儿子无论如何也回不来 //要把它标记成割点 sons++; ans[x]+=(size[to])*(n-size[to]); sum+=size[to]; if(x!=root||sons&gt;=2)gd[x]=1; } }else { low[x]=min(low[x],dfn[to]); } } if(!gd[x])ans[x]=(n-1)*2; else ans[x]+=n-1+(sum+1)*(n-sum-1); } signed main() { scanf(\"%lld%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); son[x].push_back(y); son[y].push_back(x); } root=1; tarjan(1,1); for(int i=1;i&lt;=n;i++) { printf(\"%lld\\n\",ans[i]); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://lzylzy.cf/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"Tarjan","slug":"Tarjan","permalink":"https://lzylzy.cf/tags/Tarjan/"}]},{"title":"P1118 [USACO06FEB]Backward Digit Sums G/S","date":"2021-08-24T03:37:20.000Z","path":"posts/5c15c3b2.html","text":"题目描述 链接 $ n \\leq 12$ 题解 搜索，复杂度完全能承受 发现原始的n个数字有对答案的贡献有一个系数k[i]k[i]k[i] 而且和杨辉三角 是相通的 所以只要从小到大搜索即可 加一个可行性剪枝，当前答案比sum大了就跳出 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 15 int n,sum; int a[maxn][maxn]; int b[maxn]; bool use[maxn]; void dfs(int step,int ans) { if(ans&gt;sum)return; if(ans==sum&amp;&amp;step==n+1) { for(int i=1;i&lt;=n;i++) { printf(\"%d \",b[i]); } printf(\"\\n\"); exit(0); } for(int i=1;i&lt;=n;i++) { if(!use[i]) { use[i]=1; b[step]=i; dfs(step+1,a[n][step]*i+ans); use[i]=0; } } } signed main() { scanf(\"%d%d\",&amp;n,&amp;sum); a[1][1]=1; for(int i=2;i&lt;=n;i++) { for(int j=1;j&lt;=i;j++) { a[i][j]=a[i-1][j]+a[i-1][j-1]; } } dfs(1,0); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"搜索","slug":"搜索","permalink":"https://lzylzy.cf/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"P2216 [HAOI2007]理想的正方形","date":"2021-08-18T11:09:26.000Z","path":"posts/70642401.html","text":"题目描述 给定一个n×mn\\times mn×m的矩阵，对于每个$k\\times k $的矩形，其权值为最大值减去最小值 求最小权值 n,m≤100n,m\\leq 100n,m≤100 题解 滑动窗口的二维版 于是思路是优先队列优化dp 其实二维ST表也不是不行 但是卡在复杂度上界 想起当年静态二维RMQ写了2k树套树 一上午看到代码就想吐 我们可以一步步来，先对于每一行求出每个数前k个数字的最大最小值 然后以此类推求出每个矩形的最大最小值 虽然复杂度看起来是n方，但STL还是慢的离谱，不开O2甚至能T一个点 下次手写单调队列了/kk #include&lt;cstdio&gt; #include&lt;queue&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 1009 int n,m; int k; int a[maxn][maxn]; int f[maxn][maxn],g[maxn][maxn],ff[maxn][maxn],gg[maxn][maxn]; signed main() { scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { scanf(\"%d\",&amp;a[i][j]); } } for(int j=1;j&lt;=n;j++) { priority_queue&lt;pair&lt;int,int&gt; &gt; q2; priority_queue&lt;pair&lt;int,int&gt; ,vector&lt;pair&lt;int,int&gt; &gt; ,greater&lt;pair&lt;int,int&gt; &gt; &gt; q; for(int i=1;i&lt;=m;i++) { while(!q.empty()&amp;&amp;i-q.top().second&gt;=k)q.pop(); while(!q2.empty()&amp;&amp;i-q2.top().second&gt;=k)q2.pop(); q.push(make_pair(a[j][i],i)); q2.push(make_pair(a[j][i],i)); f[j][i]=q.top().first; g[j][i]=q2.top().first; } } for(int i=1;i&lt;=m;i++) { priority_queue&lt;pair&lt;int,int&gt; &gt; q2; priority_queue&lt;pair&lt;int,int&gt; ,vector&lt;pair&lt;int,int&gt; &gt; ,greater&lt;pair&lt;int,int&gt; &gt; &gt; q; for(int j=1;j&lt;=n;j++) { while(!q.empty()&amp;&amp;j-q.top().second&gt;=k)q.pop(); while(!q2.empty()&amp;&amp;j-q2.top().second&gt;=k)q2.pop(); q.push((make_pair(f[j][i],j))); q2.push((make_pair(g[j][i],j))); ff[j][i]=q.top().first; gg[j][i]=q2.top().first; } } int ans=inf; for(int i=k;i&lt;=n;i++) { for(int j=k;j&lt;=m;j++) { ans=min(gg[i][j]-ff[i][j],ans); //cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" max:\"&lt;&lt;gg[i][j]&lt;&lt;\" min:\"&lt;&lt;ff[i][j] &lt;&lt;endl; } } printf(\"%d\\n\",ans); return 0; } /* f[i]表示i点往左n个数字的最小值 g[i]表示 最大值 ff[i][j]表示i,j为右下角的矩阵最小值 gg[i][j]表示 最大值 */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"}]},{"title":"P3959 [NOIP2017 提高组] 宝藏","date":"2021-08-17T08:35:00.000Z","path":"posts/77392b20.html","text":"题目描述 现在的NOIP题面一个比一个长。 题目链接 重点： n≤12n\\le12n≤12 题解 看数据范围知状压dp，考虑如何设计状态 因为要计算答案，我们的dp状态里必须要记录层数，即经过点的数量 于是有f[i][j]f[i][j]f[i][j]表示深度为iii，经过的点集为jjj的最小代价 接下来考虑转移 我们可以枚举一个点集kkk，kj没有交集，k表示更新的下一层节点 接下来暴力判断能不能从j转移到k，顺便找出最短距离 转移式为f[i+1][j∣k]=min(f[i+1][j∣k],f[i][j]+dis)f[i+1][j|k]=min(f[i+1][j|k],f[i][j]+dis)f[i+1][j∣k]=min(f[i+1][j∣k],f[i][j]+dis) 再就是重边一定要判断 由于n太小了 邻接矩阵就能解决问题 code #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 20 int n,m; int to[maxn][maxn]; int f[maxn][1&lt;&lt;maxn]; int p[maxn][maxn]; signed main() { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); x--,y--; if(to[x][y]==0||z&lt;to[x][y])to[x][y]=to[y][x]=z; } memset(f,0x3f,sizeof(f)); for(int i=0;i&lt;n;i++) { f[0][1&lt;&lt;i]=0; } for(int i=0;i&lt;=n;i++) { for(int j=0;j&lt;(1&lt;&lt;n);j++) { if(f[i][j]==1061109567)continue; for(int k=1;k&lt;(1&lt;&lt;n);k++)//枚举下一层 { if((j&amp;k)==0) {//判断能不能接上 int dis=0; bool tag=1; for(int l=0;l&lt;n;l++)//枚举k里面的1 { bool ok=0; if((k&amp;(1&lt;&lt;l))==0)continue; int disa=inf; for(int q=0;q&lt;n;q++) { if((j&amp;(1&lt;&lt;q))==0)continue;//j里面有个1 if(to[l][q])//能到 { ok=1; disa=min(disa,(i+1)*to[l][q]); } } dis+=disa; if(!ok) { tag=0; break; } } if(tag) { //cout&lt;&lt;\"I:\"&lt;&lt;i&lt;&lt;\" from\"&lt;&lt;j&lt;&lt;\" to\"&lt;&lt;k&lt;&lt;\" dis:\"&lt;&lt;dis&lt;&lt;endl; f[i+1][j|k]=min(f[i+1][j|k],f[i][j]+dis); } } } } } int ans=inf; for(int i=0;i&lt;n;i++)ans=min(ans,f[i][(1&lt;&lt;n)-1]); printf(\"%d\\n\",ans); return 0; } /* f[i][j]表示当前深度为i 联通的点集为j dis= */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"},{"name":"状压","slug":"状压","permalink":"https://lzylzy.cf/tags/%E7%8A%B6%E5%8E%8B/"}]},{"title":"CF858D Polycarp's phone book","date":"2021-08-15T11:48:01.000Z","path":"posts/e7cc4df9.html","text":"题目描述 有 n 个长度为 9 且只包含数字字符且 互不相同 的串。 需要对于每个串找到一个 长度最短 的识别码，使得这个识别码 当且仅当 为这个串的子串。 1≤n≤7∗1041\\leq n\\leq7*10^41≤n≤7∗104 题解 虽然可以用map糊过，但我们选择字典树 考虑暴力，我们可以把所有子串插入字典树，然后暴力枚举 但这样空间不够 再想想优化，其实我们可以不用把每个子串都插入 只需要插入每个串的所有后缀 接着再枚举所有子串匹配即可 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 5000005 char a[70009][10]; int n,root=1; int p[70009]; int tr[maxn][10]; int vis[maxn]; bool buok[maxn]; int cnt=2; bool tag=0; int timemark=1; void Add(int pos,int s,int t) { int now=root; for(int i=s;i&lt;=t;i++) { int x=a[pos][i]-'0'; if(!tr[now][x])tr[now][x]=++cnt; if(!vis[now])vis[now]=timemark; else if(vis[now]!=timemark)buok[now]=1; now=tr[now][x]; } if(!vis[now])vis[now]=timemark; else if(vis[now]!=timemark)buok[now]=1; } int l=0; bool Query(int pos,int s,int t) { l=0; int now=root; for(int i=s;i&lt;=t;i++) { int x=a[pos][i]-'0'; p[++l]=x; now=tr[now][x]; //cout&lt;&lt;x; } //cout&lt;&lt;endl; if(buok[now]==1)return 0; return 1; } signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%s\",a[i]); } tag=0; for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;9;j++) { Add(i,j,8); } timemark++; } for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;9;j++) { bool flag=0; for(int k=0;k+j&lt;9;k++) { if(Query(i,k,k+j)) { // cout&lt;&lt;\"I:\"&lt;&lt;i&lt;&lt;endl; for(int q=1;q&lt;=l;q++)printf(\"%d\",p[q]); printf(\"\\n\"); flag=1; break; } } if(flag)break; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"字符串","slug":"字符串","permalink":"https://lzylzy.cf/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"trie树","slug":"trie树","permalink":"https://lzylzy.cf/tags/trie%E6%A0%91/"}]},{"title":"ABC214F substrings","date":"2021-08-15T03:46:38.000Z","path":"posts/6c80bb47.html","text":"题目描述 给定一个字符串 给定一个字符串，求有多少没有连续字母出现的不同子序列 字符串长度为2×1052 \\times 10^52×105 题解 官方题解 看起来像是dp题，于是列个式子 我们先不考虑重复的问题 设f[i]f[i]f[i]表示以i为结尾且字母iii必须被选择的方案数 有f[i]=∑f[j],1&lt;=j&lt;=i−1f[i]=\\sum f[j],1&lt;=j&lt;=i-1f[i]=∑f[j],1&lt;=j&lt;=i−1​ 接下来想如果出现重复字符怎么办 我们发现，对于s[i]=s[j]s[i]=s[j]s[i]=s[j]，即字符相等时，任何jjj以前的答案都无需再次统计 因为我们可以认为用iii​位置上的字符替换jjj​位置，则f[j]f[j]f[j]​就包括从1到j的所有答案 关于边界，f[0]=1 加上一些其他的小判断即可，不知道为什么官方题解就没这么多事情qwq #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 200009 char s[maxn]; int f[maxn]; #define mod 1000000007 signed main() { scanf(\"%s\",s+1); int n=strlen(s+1); f[1]=1,f[0]=1; for(int i=1;i&lt;=n;i++) { bool flag=0; if(s[i]==s[i-1])flag=1; if(s[i]==s[i-1]&amp;&amp;i-2==0)continue;//这个是前两个字符一样，第二个字符答案为0 for(int j=i-2;j&gt;=0;j--) { f[i]=(f[j]+f[i])%mod; if(s[i]==s[j]&amp;&amp;j==1)break; if(s[i]==s[j+1]||flag)break;//如果连续两个一样，光统计上一个字符的前一位答案即可 } //cout&lt;&lt;f[i]&lt;&lt;endl; } ll ans=0; for(int i=1;i&lt;=n;i++)ans=(ans+f[i])%mod; printf(\"%lld\\n\",ans%mod); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"AT","slug":"AT","permalink":"https://lzylzy.cf/tags/AT/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"}]},{"title":"P4064 [JXOI2017]加法 ","date":"2021-08-12T11:45:33.000Z","path":"posts/2f836d22.html","text":"题目描述 题解 一眼看出二分，看不出来左转 J 组。 我们二分答案，即Ai的最小值 接着对于每一位，如果这一位本身的值达不到mid，就不断地使用覆盖它的区间，这个数大于mid为止 对于使用什么区间，我们采用 贪心 的思想 即 每次选择覆盖当前数位的，右界最大的区间 对于这个东西，我们可以选择单调队列维护 注意这个单调队列是必须的，按照左界为第一关键字，右界为第二关键字，排序完成后仍然需要维护队列，在数组中直接处理是有问题的 一组hack数据 输入： 1 3 3 2 1 2 1 1 1 2 2 3 1 3 输出： 3 至于区间增加，直接用差分数组O(1)解决 code: #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define int ll int n,m,k,val; #define maxn 200009 int a[maxn],mx; struct node{ int l,r; }s[maxn]; int cmp(node a,node b) { if(a.l!=b.l)return a.l&lt;b.l; else return a.r&gt;b.r; } int qs[maxn]; bool check(int x) { //所有的数字值为x // cout&lt;&lt;\"X:\"&lt;&lt;x&lt;&lt;endl; int pval=0,nowv,l=1,sum=0; //前缀和 当前和 用了多少个加法 memset(qs,0,sizeof(qs)); //差分数组 priority_queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++)//判断n个点行不行 { pval+=qs[i]; //累加前缀和 nowv=pval+a[i]; //算出当前值 if(nowv&gt;=x)continue; while(!q.empty()&amp;&amp;q.top()&lt;i)q.pop(); //先把不能用的删掉，然后添加新的区间 while(l&lt;=m&amp;&amp;s[l].l&lt;=i) { if(s[l].r&gt;=i)q.push(s[l].r); l++; } int num=(x-nowv)/val; if((x-nowv)%val!=0)num++; //计算要加几个区间 sum+=num; if(sum&gt;k)return 0; while(num--) { if(q.empty()||q.top()&lt;i)return 0; qs[q.top()+1]-=val; pval+=val; q.pop(); } } // cout&lt;&lt;\"OK\"&lt;&lt;endl; return 1; } signed main() { int T; scanf(\"%lld\",&amp;T); while(T--) { scanf(\"%lld%lld%lld%lld\",&amp;n,&amp;m,&amp;k,&amp;val); mx=inf; for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;a[i]); mx=min(mx,a[i]); } for(int i=1;i&lt;=m;i++) { scanf(\"%lld%lld\",&amp;s[i].l,&amp;s[i].r); } sort(s+1,s+1+m,cmp); int l=mx,r=mx+val*m,ans; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(check(mid)) { l=mid+1;ans=mid; }else r=mid-1; // cout&lt;&lt;endl; } printf(\"%lld\\n\",ans); } return 0; } /* 1 4 4 3 2 2 3 9 1 1 2 1 3 3 4 4 4 4 */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"贪心","slug":"贪心","permalink":"https://lzylzy.cf/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","permalink":"https://lzylzy.cf/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"P3952 [NOIP2017 提高组] 时间复杂度","date":"2021-07-16T06:05:14.000Z","path":"posts/cd474eb5.html","text":"题目描述 为一段程序计算复杂度。 [题目链接](P3952 [NOIP2017 提高组] 时间复杂度) 题解 大模拟，但是要注意很多细节。 A++语言的循环结构如下： F i x y 循环体 E 总体思路是，用stack记录循环嵌套，数一数最多嵌套了多少层 接着是细节问题 处理循环有哪些问题？ 1.变量名重复 由于变量名只是单个小写字母，所以这个可以利用map或者数组判重 在变量销毁时出栈的时候顺便清空标记即可 2.过量弹出 简单的说，EEEEE太多了 出栈之前记得判断非空 3.不弹出 结束的时候栈不是空的就不行 4.循环变量 1 第一个为数字，第二个为n时 进行n次 正常处理 2 第一个为n 第二个为数字 这种不会进行 注意在这个循环出栈之前所有的循环只占变量名不累计时间 3 两个全是n 进行一次，不累加时间，占用变量名 4 两个全是数字 这里要判断，如果1&gt;2 进行操作2 否则进行操作3 栈中维护哪些元素？ 总结一下上面的，我们发现需要维护的变量是三个 对整个复杂度的贡献。这个数字在正常进行且循环次数为n时是1，否则是0 这个循环有没有执行。如果没有执行，在弹出时我们要检查一下程序是不是要继续进行 这个循环占用的变量名 注意细节。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int TT; signed main() { scanf(\"%d\",&amp;TT); while(TT--) { int t=0; int l; char ch[10]; bool err=0; map&lt;char,int&gt; used; stack&lt; pair&lt; char,pair &lt; int , bool &gt; &gt; &gt; st; scanf(\"%d\",&amp;l); scanf(\"%s\",ch); for(int i=0;i&lt;=strlen(ch);i++) { if('0'&lt;=ch[i]&amp;&amp;ch[i]&lt;='9') { if(ch[i-1]=='(') { t=0;break; }else if(ch[i-1]=='^') { t=ch[i]-'0'; }else t=t*10+ch[i]-'0'; } } int ans=0,now=0,running=1;; for(int i=1;i&lt;=l;i++) { scanf(\"%s\",ch); if(ch[0]=='F')//开始循环 { scanf(\"%s\",ch); if(used[ch[0]]==-1)err=1; used[ch[0]]=-1; char opt=ch[0]; scanf(\"%s\",ch); int num1=0,num2=0; bool go=1; bool tag1=(ch[0]=='n'); if(!tag1)for(int j=0;j&lt;strlen(ch);j++)num1=num1*10+ch[j]-'0'; scanf(\"%s\",ch); bool tag2=(ch[0]=='n'); if(!tag1)for(int j=0;j&lt;strlen(ch);j++)num2=num2*10+ch[j]-'0'; int key=0; if((tag1&amp;&amp;tag2)||(!tag1&amp;&amp;!tag2&amp;&amp;num1&lt;num2)) { key=0,go=1; ans=max(ans,now); }if(!tag1&amp;&amp;tag2) { now+=running; ans=max(ans,now); key=running; }else if((tag1&amp;&amp;!tag2)||(!tag1&amp;&amp;!tag2&amp;&amp;num1&gt;num2))//不会进行 { go=0,running--; } st.push(make_pair(opt,make_pair(key,go))); }else { if(!st.empty()) { char opt=st.top().first; now-=st.top().second.first; if(!st.top().second.second)running++; used[opt]=0; st.pop(); }else err=1; } } if(!st.empty())err=1; if(err)printf(\"ERR\\n\"); else if(ans==t)printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"模拟","slug":"模拟","permalink":"https://lzylzy.cf/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"P4072 [SDOI2016]征途","date":"2021-07-13T07:54:23.000Z","path":"posts/4c07089e.html","text":"题目描述 从S地到T地的路可以划分成n段，相邻两段路的分界点设有休息站。 Pine计划用m天到达T地。除第m天外，每一天晚上Pine都必须在休息站过夜。所以，一段路必须在同一天中走完。 Pine希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。 帮助Pine求出最小方差是多少。 输出方差乘以M的平方 题解 首先推式子 接下来就很好做了，只需要最小化平方和，使用斜率优化即可 code： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 3009 int n,m; ll d[maxn]; ll f[maxn][maxn]; ll q[maxn]; ll kk=0; int head=1,tail=1; double Y(int j) { return f[kk-1][j]+d[j]*d[j]; } double X(int j) { return d[j]; } double slope(int x,int y) { return 1.0*(double)(Y(y)-Y(x))/(X(y)-X(x)); } signed main() { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;d[i]); d[i]+=d[i-1]; } for(int i=1;i&lt;=n;i++)f[1][i]=d[i]*d[i]; for(kk=2;kk&lt;=m;kk++) { head=1;tail=0; for(int i=1;i&lt;=n;i++) { ll k=d[i]*2; while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&lt;k)head++; int j=q[head]; f[kk][i]=f[kk-1][j]+(d[i]-d[j])*(d[i]-d[j]); while(head&lt;tail&amp;&amp;slope(q[tail],i)&lt;slope(q[tail-1],i))tail--; q[++tail]=i; } } printf(\"%lld\\n\",f[m][n]*m-d[n]*d[n]); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://lzylzy.cf/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"}]},{"title":"P1087 [NOIP2004 普及组] FBI 树","date":"2021-07-11T13:38:53.000Z","path":"posts/69c73527.html","text":"题目描述 题目链接 题解 模拟 简单构建即可，甚至不用把树建出来 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n; #define maxn 2500 char a[maxn]; int s[maxn]; void dfs(int l,int r) { //cout&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl; if(l&gt;r)return; char k; if(s[r]-s[l-1]==0)k='B'; else if(s[r]-s[l-1]==r-l+1)k='I'; else k='F'; int mid=(l+r)&gt;&gt;1; if(r-l+1&lt;=1) { putchar(k); return; } dfs(l,mid); dfs(mid+1,r); putchar(k); } signed main() { scanf(\"%d\",&amp;n); scanf(\"%s\",a+1); for(int i=1;i&lt;=(1&lt;&lt;n);i++) { s[i]=s[i-1]+a[i]-'0'; } dfs(1,(1&lt;&lt;n)); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"模拟","slug":"模拟","permalink":"https://lzylzy.cf/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"P1383 高级打字机","date":"2021-07-11T13:36:41.000Z","path":"posts/7ff6e237.html","text":"题目描述 支持两个操作，在文末添加一个字符，或撤销前x次操作 可以撤销撤销操作（ 题解 主席树板子 对于撤销操作，只需要继承前k个节点的根就行 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n; #define maxn 1000009 int rt[maxn],cnt=1; struct node{ int ls,rs; int val; char data; }tr[maxn&lt;&lt;5]; int Build(int l,int r) { int x=++cnt; if(l==r)return x; int mid=(l+r)&gt;&gt;1; tr[x].ls=Build(l,mid); tr[x].rs=Build(mid+1,r); return x; } int add(int x,int l,int r,char val) { int root=++cnt; tr[root]=tr[x]; if(l==r) { tr[root].val+=1;tr[root].data=val; return root; } int mid=(l+r)&gt;&gt;1; if(tr[tr[root].ls].val!=mid-l+1)tr[root].ls=add(tr[root].ls,l,mid,val); else tr[root].rs=add(tr[root].rs,mid+1,r,val); tr[root].val=tr[tr[root].ls].val+tr[tr[root].rs].val; return root; } char query(int x,int l,int r,int val) { if(l&gt;=r)return tr[x].data; int mid=(l+r)&gt;&gt;1; int k=tr[tr[x].ls].val; if(k&gt;=val)return query(tr[x].ls,l,mid,val); else return query(tr[x].rs,mid+1,r,val-k); } signed main() { scanf(\"%d\",&amp;n); int k=0; Build(1,n); for(int i=1;i&lt;=n;i++) { char opt[5]; int x; scanf(\"%s\",opt); if(opt[0]=='T') { scanf(\"%s\",opt); k++; rt[k]=add(rt[k-1],1,n,opt[0]); }else if(opt[0]=='U') { scanf(\"%d\",&amp;x); k++; rt[k]=rt[k-x-1]; }else if(opt[0]=='Q') { scanf(\"%d\",&amp;x); printf(\"%c\\n\",query(rt[k],1,n,x)); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"线段树","slug":"线段树","permalink":"https://lzylzy.cf/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"主席树","slug":"主席树","permalink":"https://lzylzy.cf/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"P2633 Count on a tree","date":"2021-07-11T13:34:41.000Z","path":"posts/f91f2cad.html","text":"题目描述 树上两点间路径第k小 强制在线 题解 主席树大法好 这回的问题从区间变成了树上，但是变化不大 以前区间我们继承的是前一个节点 现在只需要继承父亲节点即可 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 300009 int n,m,p; int a[maxn],b[maxn],dep[maxn],cnt=0; struct node{ int ls; int rs; int val; }tr[maxn&lt;&lt;5]; int rt[maxn],fa[maxn][31]; vector&lt;int&gt; son[maxn]; int Build(int l,int r) { int x=++cnt; int mid=(l+r)&gt;&gt;1; if(l==r)return x; tr[x].ls=Build(l,mid); tr[x].rs=Build(mid+1,r); tr[x].val=0; return x; } int add(int x,int l,int r,int val) { int root=++cnt; tr[root]=tr[x]; tr[root].val++; int mid=(l+r)&gt;&gt;1; if(l==r)return root; if(val&lt;=mid)tr[root].ls=add(tr[root].ls,l,mid,val); else tr[root].rs=add(tr[root].rs,mid+1,r,val); return root; } void dfs(int x,int from) { fa[x][0]=from; dep[x]=dep[from]+1; rt[x]=add(rt[from],1,p,b[x]); for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(to!=from)dfs(to,x); } } int query(int a,int b,int c,int d,int l,int r,int val) { //a+b-c-d if(l==r)return l; int la=tr[tr[a].ls].val; int lb=tr[tr[b].ls].val; int lc=tr[tr[c].ls].val; int ld=tr[tr[d].ls].val; int mid=(l+r)&gt;&gt;1,k=la+lb-lc-ld; if(k&gt;=val)return query(tr[a].ls,tr[b].ls,tr[c].ls,tr[d].ls,l,mid,val); else return query(tr[a].rs,tr[b].rs,tr[c].rs,tr[d].rs,mid+1,r,val-k); } int GetLca(int x,int y) { if(dep[x]&lt;dep[y])swap(x,y); int k=dep[x]-dep[y],l=0; while(k) { if(k&amp;1)x=fa[x][l]; l++;k&gt;&gt;=1; } if(x==y)return x; for(int i=30;i&gt;=0;i--) { if(fa[x][i]!=fa[y][i]) { x=fa[x][i];y=fa[y][i]; } } return fa[x][0]; } signed main() { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); b[i]=a[i]; } for(int i=1;i&lt;n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); son[x].push_back(y); son[y].push_back(x); } sort(a+1,a+1+n); p=unique(a+1,a+1+n)-a-1; for(int i=1;i&lt;=n;i++)b[i]=lower_bound(a+1,a+p+1,b[i])-a; rt[0]=Build(1,p); dfs(1,0); for(int i=1;i&lt;=30;i++) { for(int j=1;j&lt;=n;j++) { fa[j][i]=fa[fa[j][i-1]][i-1]; } } int last=0; for(int i=1;i&lt;=m;i++) { int u,v,k; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;k); u=u^last; int lca=GetLca(u,v); last=query(rt[u],rt[v],rt[lca],rt[fa[lca][0]],1,p,k); printf(\"%d\\n\",a[last]); last=a[last]; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"线段树","slug":"线段树","permalink":"https://lzylzy.cf/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"主席树","slug":"主席树","permalink":"https://lzylzy.cf/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"CF487E Tourists","date":"2021-07-11T13:28:06.000Z","path":"posts/7d516526.html","text":"题目描述 给定一张图，求两点间路径权值最小值 支持修改 题解 大恶心题 对于没有修改的部分，用圆方树就能实现。 然后对于修改操作，利用圆方树是棵树的性质，在方点处用multiset存储所有儿子节点的权值 这样一来每次只需要修改一个点就能解决问题 最后的细节是如果LCA是方点需要再次更新答案 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; #include&lt;set&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 200009 int n,m,q; int val[maxn]; multiset&lt;int&gt; S[maxn*2]; vector&lt;int&gt; son[maxn],t[maxn]; int num=0; int dfn[maxn],low[maxn]; int tp=0,stk[maxn]; int cnt=0; void tarjan(int x) { dfn[x]=low[x]=num++; stk[++tp]=x; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(!dfn[to]) { tarjan(to); low[x]=min(low[x],low[to]); if(dfn[x]==low[to]) { cnt++; for(int k=0;k!=to;tp--) { k=stk[tp]; //S[cnt].insert(val[k]); t[k].push_back(cnt); t[cnt].push_back(k); } //S[cnt].insert(val[x]); t[x].push_back(cnt); t[cnt].push_back(x); } }else low[x]=min(low[x],dfn[to]); } } struct node{ int l,r; int val; }tr[maxn*4]; int size[maxn*2],fa[maxn*2],Son[maxn*2],top[maxn*2]; int pos[2*maxn],dfk[maxn*2]; int dep[maxn*2]; int tmk=0; void dfs1(int x) { size[x]=1; for(int i=0;i&lt;t[x].size();i++) { int to=t[x][i]; if(!size[to]) { fa[to]=x; dep[to]=dep[x]+1; dfs1(to); size[x]+=size[to]; if(size[to]&gt;size[Son[x]])Son[x]=to; } } } void dfs2(int x,int tp) { tmk++; pos[x]=tmk; dfk[tmk]=x; top[x]=tp; if(Son[x])dfs2(Son[x],tp); for(int i=0;i&lt;t[x].size();i++) { int to=t[x][i]; if(to!=fa[x]&amp;&amp;to!=Son[x])dfs2(to,to); } } void Build(int x,int l,int r) { tr[x].l=l; tr[x].r=r; if(l==r) { tr[x].val=val[dfk[l]]; return; } int mid=(l+r)&gt;&gt;1; Build(x*2,l,mid); Build(x*2+1,mid+1,r); tr[x].val=min(tr[x*2].val,tr[x*2+1].val); } //单点修改 区间查询 void add(int x,int pos,int val) { if(tr[x].l==tr[x].r&amp;&amp;tr[x].l==pos) { tr[x].val=val; return; } int mid=(tr[x].l+tr[x].r)&gt;&gt;1; if(pos&lt;=mid)add(x*2,pos,val); else add(x*2+1,pos,val); tr[x].val=min(tr[x*2].val,tr[x*2+1].val); } int query(int x,int l,int r) { if(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r)return tr[x].val; int mid=(tr[x].l+tr[x].r)&gt;&gt;1; int res=inf; if(l&lt;=mid)res=query(x*2,l,r); if(r&gt;mid)res=min(res,query(x*2+1,l,r)); return res; } signed main() { scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q); cnt=n; for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;val[i]); } for(int i=1;i&lt;=m;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); son[x].push_back(y); son[y].push_back(x); } tarjan(1); dfs1(1); dfs2(1,1); for(int i=1;i&lt;=n;i++) { if(fa[i])S[fa[i]].insert(val[i]); } for(int i=n+1;i&lt;=cnt;i++) { val[i]=*S[i].begin(); } Build(1,1,cnt); while(q--) { char opt[3]; int x,y; scanf(\"%s%d%d\",opt,&amp;x,&amp;y); if(opt[0]=='C') { add(1,pos[x],y); if(fa[x]) { S[fa[x]].erase(S[fa[x]].lower_bound(val[x])); S[fa[x]].insert(y); if(val[fa[x]]!=*S[fa[x]].begin()) { val[fa[x]]=*S[fa[x]].begin(); add(1,pos[fa[x]],val[fa[x]]); } } val[x]=y; }else { int Ans=inf; while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]])swap(x,y); Ans=min(Ans,query(1,pos[top[x]],pos[x])); x=fa[top[x]]; } if(pos[x]&gt;pos[y])swap(x,y); Ans=min(Ans,query(1,pos[x],pos[y])); if(x&gt;n) { Ans=min(Ans,val[fa[x]]); } printf(\"%d\\n\",Ans); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"圆方树","slug":"圆方树","permalink":"https://lzylzy.cf/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://lzylzy.cf/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}]},{"title":"P3926 SAC E#1 - 一道不可做题 Jelly","date":"2021-07-11T13:23:44.000Z","path":"posts/73c8616c.html","text":"题目描述 很奇怪的模拟题 题目链接 题解 懒得写 搬运kkk（ 如果 a &gt; c，答案是 a+⌊x r⌋。 如果 a = c，有两种情况： 如果 x≤q，答案是 c。 如果 x &gt; q，答案是 c+⌊(x−q) / r ⌋。 如果 a &lt; c，有三种情况： 如果 x≤ (c−a)p，答案是 a+⌊x /p⌋。 如果 (c−a)p≤x≤ (c−a)p+q，答案是 c 如果 x &gt; (c−a)p+q，答案是 c+⌊(x−(c−a)p−q) / r ⌋ #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; ll a,c,p,q,r,x; signed main() { scanf(\"%lld%lld%lld%lld%lld%lld\",&amp;a,&amp;c,&amp;p,&amp;q,&amp;r,&amp;x); if(x&lt;=(c-a)*p&amp;&amp;a&lt;c) { cout&lt;&lt;x/p+a&lt;&lt;endl; return 0; } if(a&lt;c)x-=(c-a)*p,a=c; if(x&lt;=q&amp;&amp;a==c) { cout&lt;&lt;c&lt;&lt;endl; return 0; } if(a==c)x-=q; cout&lt;&lt;x/r+a&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"模拟","slug":"模拟","permalink":"https://lzylzy.cf/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"P6166 [IOI2012]scrivener","date":"2021-07-11T13:20:38.000Z","path":"posts/bab63e92.html","text":"题目描述 支持两个操作，在文末添加一个字符，或撤销前x次操作 可以撤销撤销操作（ 题解 看撤销想主席树 然后这就是很简单的主席树板子题 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n; #define maxn 1000009 struct node{ int ls,rs; int val; char data; }tr[maxn&lt;&lt;4]; int rt[maxn],cnt=0; int Build(int l,int r) { int x=++cnt; if(l==r)return x; int mid=(l+r)&gt;&gt;1; tr[x].ls=Build(l,mid); tr[x].rs=Build(mid+1,r); return x; } char query(int x,int l,int r,int val) { if(l==r)return tr[x].data; int mid=(l+r)&gt;&gt;1; int k=tr[tr[x].ls].val; if(k&gt;=val)return query(tr[x].ls,l,mid,val); else return query(tr[x].rs,mid+1,r,val-k); } int add(int x,int l,int r,char val) { int root=++cnt; tr[root]=tr[x]; tr[root].val++; if(l==r) { tr[root].data=val; return root; } int mid=(l+r)&gt;&gt;1; if(tr[tr[root].ls].val&lt;mid-l+1)tr[root].ls=add(tr[x].ls,l,mid,val); else tr[root].rs=add(tr[root].rs,mid+1,r,val); tr[root].val=tr[tr[root].ls].val+tr[tr[root].rs].val; return root; } signed main() { scanf(\"%d\",&amp;n); rt[0]=Build(1,n/10); int k=0; for(int i=1;i&lt;=n;i++) { char opt[3]; scanf(\"%s\",opt); int x; if(opt[0]=='T') { scanf(\"%s\",opt); k++; rt[k]=add(rt[k-1],1,n,opt[0]); }else if(opt[0]=='U') { scanf(\"%d\",&amp;x); k++; rt[k]=rt[k-x-1]; }else { scanf(\"%d\",&amp;x); x++; printf(\"%c\\n\",query(rt[k],1,n,x)); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"线段树","slug":"线段树","permalink":"https://lzylzy.cf/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"主席树","slug":"主席树","permalink":"https://lzylzy.cf/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"P5658 [CSP-S2019] 括号树","date":"2021-07-11T13:12:37.000Z","path":"posts/760b4b07.html","text":"题目描述 给定一棵树，每个节点有一个左括号或右括号 求所有节点到根路径上合法子串的数量的异或和 题解 思维题，需要一些树的思想。 我们设F[i]表示根节点到i路径上的答案，考虑如何更新 显然可以继承父亲，然后分类讨论 如果这个点是右括号，我们得从父亲找出有没有左括号跟它匹配 所以对于每个点，记last[i]为上一个左括号在哪出现 还需要标记有几个左括号没被使用 记为flag[i] 为了计算答案（子串），我们得记录一个Line，表示最多连续有几个配对成功的括号群 line的更新比较复杂，在右括号时，如果匹配失败，需要清零 如果右括号在父亲上匹配成功，line需要继承匹配到的那个左括号点的line 如果是左括号，我们只需要继承答案，修改last为自身，Line清空即可 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 500009 #define int ll int last[maxn];//上一个没配对的括号 int f[maxn];//到i的答案 int fa[maxn]; char a[maxn]; int n; int line[maxn];//已经有几个连续的括号 bool flag[maxn]; signed main() { scanf(\"%lld\",&amp;n); scanf(\"%s\",a+1); fa[1]=n+1; last[1]=-1; last[n+1]=-1; for(int i=2;i&lt;=n;i++) { scanf(\"%lld\",&amp;fa[i]); last[i]=-1; } if(a[1]=='(')last[1]=1; for(int i=2;i&lt;=n;i++) { if(a[i]=='(') { //左括号 加进去继承 f[i]=f[fa[i]]; last[i]=i; line[i]=0; }else { if(last[fa[i]]==-1) { f[i]=f[fa[i]]; line[i]=0;//断了 last[i]=-1; }else { line[i]=line[fa[last[fa[i]]]]+1;//更新line f[i]=f[fa[i]]+line[i]; last[i]=last[fa[last[fa[i]]]]; flag[i]=1; } } } ll ans=0; for(int i=1;i&lt;=n;i++) { ans=ans^(i*f[i]); //cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;f[i]&lt;&lt;\" \"&lt;&lt;last[i]&lt;&lt;\" \"&lt;&lt;line[i]&lt;&lt;\" \"&lt;&lt;flag[i]&lt;&lt;endl; } printf(\"%lld\\n\",ans); return 0; } /* 11 ()(())((()) 1 1 2 4 5 5 7 8 9 10 */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"模拟","slug":"模拟","permalink":"https://lzylzy.cf/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"P2543 [AHOI2004]奇怪的字符串","date":"2021-07-11T13:08:47.000Z","path":"posts/84fe2a2a.html","text":"题目描述 上古省选题 求最长公共子序列。 题解 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 10009 char a[maxn],b[maxn]; int f[2][maxn]; //f[i][j]表示a的前i位，b的前j位的LCS signed main() { scanf(\"%s\",a+1); scanf(\"%s\",b+1); int lena=strlen(a+1),lenb=strlen(b+1); for(int i=1;i&lt;=lena;i++) { for(int j=1;j&lt;=lenb;j++) { if(a[i]==b[j]) { f[i&amp;1][j]=f[(i-1)&amp;1][j-1]+1; } f[i&amp;1][j]=max(f[i&amp;1][j],max(f[(i-1)&amp;1][j],f[i&amp;1][j-1])); } } printf(\"%d\\n\",f[lena&amp;1][lenb]); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"}]},{"title":"P1037 [NOIP2002 普及组] 产生数","date":"2021-07-11T13:05:16.000Z","path":"posts/8cb1d9bf.html","text":"题目描述 给定k个变化规则和一个整数n 求能产生多少不同的数字 题解 主要考察高精度 对于数字的变化，我们可以用佛洛依德求出每个数字有多少种变化，然后再连乘起来就能得到答案。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x3f3f3f3f; typedef long long ll; #define maxn 20 #define ex(x) (x==-1?inf:x) int n,k; string a; string ans=\"1\"; int x[maxn],y[maxn]; int f[maxn][maxn]; string cheng(string a,int b) { int jw=0; for(int i=a.size()-1;i&gt;=0;i--) { int now=a[i]-'0'; now*=b; now+=jw; jw=now/10; now%=10; a[i]=now+'0'; } if(jw==0)return a; queue&lt;int&gt; q; while(jw) { q.push(jw%10);jw/=10; } string s=\"\"; while(!q.empty()) { s+=(char)(q.front()+'0'); q.pop(); } return s+a; } signed main() { memset(f,0,sizeof(f)); cin&gt;&gt;a; scanf(\"%d\",&amp;k); for(int i=1;i&lt;=k;i++) { scanf(\"%d%d\",&amp;x[i],&amp;y[i]); if(y[i]==0) { k--,i--; continue; } f[x[i]][y[i]]=1; } for(int i=0;i&lt;=10;i++)f[i][i]=1; for(int l=0;l&lt;=9;l++) { for(int i=0;i&lt;=9;i++) { for(int j=0;j&lt;=9;j++) { if(i!=j&amp;&amp;j!=l&amp;&amp;l!=i) f[i][j]|=f[i][l]&amp;f[l][j]; } } } for(int i=0;i&lt;a.size();i++) { int p=0; for(int j=0;j&lt;=9;j++) { if(f[a[i]-'0'][j]==1) { p++; // cout&lt;&lt;a[i]&lt;&lt;\" \"&lt;&lt;j&lt;&lt;endl; } } if(p!=0)ans=cheng(ans,p); // cout&lt;&lt;a[i]&lt;&lt;\" \"&lt;&lt;p&lt;&lt;endl; } cout&lt;&lt;ans&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"高精度","slug":"高精度","permalink":"https://lzylzy.cf/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"模拟","slug":"模拟","permalink":"https://lzylzy.cf/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"P5017 [NOIP2018 普及组] 摆渡车","date":"2021-07-11T10:43:07.000Z","path":"posts/fa0062c2.html","text":"题目描述 有n名同学要乘坐摆渡车从人大附中前往人民大学，第 i位同学在第 ti有一辆摆渡车在工作，但摆渡车容量可以视为无限大。摆渡车从人大附中出发、 把车上的同学送到人民大学、再回到人大附中（去接其他同学），这样往返一趟总共花费m分钟（同学上下车时间忽略不计）。摆渡车要将所有同学都送到人民大学。 凯凯很好奇，如果他能任意安排摆渡车出发的时间，那么这些同学的等车时间之和最小为多少呢？ 题解 没想到普及T3就是奇奇怪怪的斜率优化 f[i]表示截止到时刻i车出发总共让学生等待的时间 枚举一个j ij差大于m cnt[i]表示截止到时刻i 有cnti个人来等车 sum[i]表示截止到时刻i 一个人都没走 所有人的等车时间总和 f[i]=f[j]+i∗(cnt[i]−cnt[j])−(sum[i]−sum[j])f[i]=f[j]+i*(cnt[i]-cnt[j])-(sum[i]-sum[j])f[i]=f[j]+i∗(cnt[i]−cnt[j])−(sum[i]−sum[j]) #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n,m; #define maxn 4000105 int t[maxn]; int f[maxn]; int q[maxn]; int head=1,tail=0; int cnt[maxn],sum[maxn]; inline double slope(int u, int v) { return (double) (f[v] + sum[v] - f[u] - sum[u]) / (cnt[u] == cnt[v] ? 1e-9 : cnt[v] - cnt[u]); } signed main() { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;t[i]); cnt[t[i]]++; sum[t[i]]+= t[i]; } sort(t+1,t+1+n);//从小到大 for(int i=1;i&lt;=t[n]+m;i++) { cnt[i] += cnt[i - 1]; sum[i] += sum[i - 1]; } for(int i=0;i&lt;=t[n]+m;i++) { if(i-m&gt;=0) { while(head&lt;tail&amp;&amp;(slope(q[tail-1],q[tail])&gt;=slope(q[tail],i-m)))tail--; q[++tail]=i-m; } while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&lt;=i)head++; int j=q[head]; f[i]=cnt[i]*i-sum[i];//不发车，发不出去 if(head&lt;=tail)f[i]=min(f[i],f[j]+i*(cnt[i]-cnt[j])-(sum[i]-sum[j])); } int ans=inf; for(int i=t[n];i&lt;=t[n]+m;i++)ans=min(ans,f[i]); printf(\"%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://lzylzy.cf/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"}]},{"title":"P5019 [NOIP2018 提高组] 铺设道路","date":"2021-07-11T10:25:55.000Z","path":"posts/46a8d1e6.html","text":"题目描述 地面上有n个坑，每个坑深度为d[i] 每次可以选择连续一段深度不为0的坑，使他们的深度-1 求最少操作数。 题解 贪心题。 分两种情况讨论 $ d[i]&lt;d[i-1]$ 上一个坑更深。这样当前坑一定可以在上一个坑被填时顺便填满，所以不占操作数。 d[i]&gt;=d[i−1]d[i]&gt;=d[i-1]d[i]&gt;=d[i−1] 当前坑更深。由于上一个坑已经填满，所以我们把当前坑填满要多用$ a[i]-a[i-1]$次操作。 结束。 code： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n; #define maxn 100009 int a[maxn]; signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); } ll ans=a[1]; for(int i=2;i&lt;=n;i++) { if(a[i]&gt;a[i-1])ans+=a[i]-a[i-1]; } printf(\"%lld\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"贪心","slug":"贪心","permalink":"https://lzylzy.cf/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"P2365 任务安排","date":"2021-07-11T10:10:42.000Z","path":"posts/a975b051.html","text":"题目描述 n 个任务排成一个序列在一台机器上等待完成（顺序不得改变），这 n个任务被分成若干批，每批包含相邻的若干任务。 从零时刻开始，这些任务被分批加工，第 i个任务单独完成所需的时间为 ti。在每批任务开始前，机器需要启动时间 s，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。 每个任务的费用是它的完成时刻乘以一个费用系数 fi。请确定一个分组方案，使得总费用最小。 题解 由于n的范围是5000，O(n^2)的算法也能通过，不过这里使用斜率优化。 先推最朴素的转移式。设F[i]为完成第i个任务所需的总费用 枚举一个断点 jjj，从j+i到i为一组进行 由于开动机器S对以后所有的任务都会有影响，所以这里提前计算开动一次机器对以后的影响 $ f[i]=f[j]+t[i](c[i]-c[j])+s(c[n]-c[j])$ 这里t表示时间的前缀和，c表示费用系数的前缀和 注意我们只需要加上当前任务的花费，而不需要算出这一批所有任务的花费 接着观察这个式子，套用斜率优化的模板 我们把式子移项，直到变成y=kx+b的形式 其中 y只和j有关 k只和i有关 x只和j有关 b只和i有关 得到 $ y=f[j]-s*c[j]$ k=t[i]k=t[i]k=t[i] x=c[j]x=c[j]x=c[j] b=f[i]−s∗c[n]−t[i]∗c[i]b=f[i]-s*c[n]-t[i]*c[i]b=f[i]−s∗c[n]−t[i]∗c[i] 这样就能结束战斗。 code: #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n,s; #define maxn 5009 int a[maxn],c[maxn],t[maxn]; int f[maxn]; int q[maxn]; double X(int j){return c[j];} double Y(int j){return f[j]-c[j]*s;} double slope(int x,int y) { return 1.0*(double)(Y(y)-Y(x))/(X(y)-X(x)); } signed main() { scanf(\"%d%d\",&amp;n,&amp;s); for(int i=1;i&lt;=n;i++) { scanf(\"%d%d\",&amp;t[i],&amp;c[i]); t[i]+=t[i-1];c[i]+=c[i-1]; } int head=1,tail=1; for(int i=1;i&lt;=n;i++) { int k=t[i]; while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&lt;k)head++; int j=q[head]; f[i]=f[j]+t[i]*(c[i]-c[j])+s*(c[n]-c[j]); while(head&lt;tail&amp;&amp;slope(q[tail],i)&lt;slope(q[tail-1],i))tail--; q[++tail]=i; } printf(\"%d\\n\",f[n]); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://lzylzy.cf/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"}]},{"title":"P2850 [USACO06DEC]Wormholes G","date":"2021-05-29T13:11:46.000Z","path":"posts/549718b.html","text":"题目描述 判断有没有负环，多组数据 题解 判断负环的几个思路 Floyd 最简单且容易理解的方法 邻接矩阵xy值相同时，如果有点的值为负数，则出现了负环 因为负数 表示自己可以通过负权边到达自己，也就是说出现了负环 Bellman-ford 这个算法通过不断迭代计算最短路，因为每轮迭代扫描所有边，第k轮迭代结束，走过k条边的最短路都会被计算完成 当某条最短路的长度大于n，那么一定出现了负环 spfa 判断一个点的入队次数，如果&gt;=n说明有负环，因为松弛贡献&gt;=n说明这条最短路的长度在n以上 在判断负环这方面，dfs版的spfa表现更加优秀，因为dfs只需要判断一个节点访问两次就可以发现负环 更具体地，当一个节点在栈内，证明这个点正在更新别人，而再次访问到自己，证明自己更新自己，则出现负环 code（dfs-spfa） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 509 vector&lt;int&gt; son[maxn],val[maxn]; int n,m,w; int dis[maxn]; void add(int x,int y,int z) { son[x].push_back(y); val[x].push_back(z); } bool flag=0; bool in[maxn]; void spfa(int x) { if(in[x])flag=1;//一个点访问两次就是负环 if(flag)return; in[x]=1; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(dis[to]&gt;dis[x]+val[x][i]) { dis[to]=dis[x]+val[x][i]; spfa(to); } } in[x]=0; } signed main() { int T; scanf(\"%d\",&amp;T); while(T--) { for(int i=1;i&lt;=n;i++) { son[i].clear();val[i].clear(); } scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;w); for(int i=1;i&lt;=m;i++) { int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); add(x,y,z);add(y,x,z); } for(int i=1;i&lt;=w;i++) { int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); add(x,y,-z); } memset(dis,0x3f,sizeof(dis)); memset(in,0,sizeof(in)); flag=0; for(int i=1;i&lt;=n;i++) { spfa(i); if(flag)break; } if(flag)printf(\"YES\\n\"); else printf(\"NO\\n\"); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"SPFA","slug":"SPFA","permalink":"https://lzylzy.cf/tags/SPFA/"},{"name":"最短路","slug":"最短路","permalink":"https://lzylzy.cf/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"P6568 [NOI Online #3 提高组] 水壶","date":"2021-05-19T12:09:58.000Z","path":"posts/7ff9b54a.html","text":"题目描述 有 n个容量无穷大的水壶，它们从 1∼n 编号，初始时 i号水壶中装有 Ai单位的水。 你可以进行不超过 k次操作，每次操作需要选择一个 的编号 x，然后把 x 号水壶中的水全部倒入 x+1号水壶中。 最后你可以任意选择恰好一个水壶，并喝掉水壶中所有的水。现在请你求出，你最多能喝到多少单位的水。 题解 贪心题，主要是思维 因为只能喝一个壶里的水 所以想要喝到最多的水 我们肯定把所有k个连续的水壶里的水倒在一起 于是问题变成给一段数 求连续k+1个数的和的最大值 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; ll n,k; #define maxn 1000009 ll a[maxn]; signed main() { scanf(\"%lld%lld\",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;a[i]); } ll s=0,ans=0; k++; for(int i=1;i&lt;=n;i++) { s+=a[i]; if(i&gt;k)s-=a[i-k]; ans=max(s,ans); } printf(\"%lld\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"贪心","slug":"贪心","permalink":"https://lzylzy.cf/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"P6187 [NOI Online #1 提高组] 最小环","date":"2021-05-18T13:06:25.000Z","path":"posts/c3ed7f1a.html","text":"题目描述 给定n个数连成一个环，对于每个k，重新排列这n个数是的任意两个距离为k的数的乘积之和最大 题解 NOI OL里很好的一道贪心题目 首先应该分析如何能使乘积的和最大 这样我们就要让大数和大数乘 小数和小数乘 观察样例不难发现这个方法 可以求出n k的gcd记为p 则n/p就是每个互相独立的环的长度 我们记n/p为t 这样把最大的挨着第二大的以此类推放入第一个环 第t+1大的挨着第t+2大的放入下一个环 最后进行一下优化 发现n和数字都给定了 所以t不变，答案就不会变 记忆化一下 存储算过对应t的答案即可 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n,m; #define maxn 400009 ll a[maxn]; int gcd(int a,int b) { if(b==0)return a; return gcd(b,a%b); } ll vis[maxn]; ll b[maxn]; ll work(int k) { int t=n/gcd(n,k);//每t个数一个独立的循环节 if(vis[t])return vis[t]; ll ans=0; int c=n; for(int i=1;i&lt;=n;i+=t) { for(int j=0;j&lt;t-2;j++) { ans+=a[i+j]*a[i+j+2]; } ans+=a[i]*a[i+1]+a[i+t-1]*a[i+t-2]; } return vis[t]=ans; } signed main() { scanf(\"%d%d\",&amp;n,&amp;m); ll s=0; for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;a[i]); s+=a[i]*a[i]; } sort(a+1,a+1+n); while(m--) { int k; scanf(\"%d\",&amp;k); if(k==0)printf(\"%lld\\n\",s); else printf(\"%lld\\n\",work(k)); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"贪心","slug":"贪心","permalink":"https://lzylzy.cf/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"P5058 [ZJOI2004]嗅探器","date":"2021-05-16T10:39:43.000Z","path":"posts/142b1c13.html","text":"题目描述 给定一张图和S T，求编号最小的割点 无解输出No Solution 题解 应该是圆方树的入门题 首先考虑无解的情况，一种是ST根本不连通，或是ST在同一个点双连通分量中 接着考虑如何计算答案 根据圆方树的一个性质 两圆点之间经过的圆点是两点之间所有路径经过的点的并集 再通俗一点，两圆点路径上的所有圆点都是割点 于是我们只需要在树上遍历两个点之间的路径就可以了 可以用倍增 LCA等方法，这时你已经可以拿到满分了 但是既然都做到这了 我们可以接着想想 如何简化这个求法 一般我们默认根为1 不过现在可以直接把根指定为S 经过一遍dfs遍历即可知道每个点的父亲 就可以解决问题 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 400009 int n; vector&lt;int&gt; son[maxn],t[maxn]; int S,T; int cnt,top=0,stk[maxn]; int num=0,dfn[maxn],low[maxn]; bool same=0; void tarjan(int x) { num++; dfn[x]=low[x]=num; stk[++top]=x; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(!dfn[to]) { tarjan(to); low[x]=min(low[x],low[to]); if(low[to]==dfn[x]) { cnt++; bool flag=0; for(int k=0;k!=to;top--) { k=stk[top]; t[cnt].push_back(k); t[k].push_back(cnt); if(k==S||k==T) { if(flag)same=1; else flag=1; } } t[x].push_back(cnt); t[cnt].push_back(x); if(x==S||x==T) { if(flag)same=1; else flag=1; } } }else low[x]=min(low[x],dfn[to]); } } int fa[maxn]; void dfs(int x) { for(int i=0;i&lt;t[x].size();i++) { int to=t[x][i]; if(!fa[to]) { fa[to]=x; dfs(to); } } } signed main() { scanf(\"%d\",&amp;n); cnt=n; while(1) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); if(x==0&amp;&amp;y==0)break; son[x].push_back(y); son[y].push_back(x); } scanf(\"%d%d\",&amp;S,&amp;T); tarjan(S); if(!dfn[T]||same) { printf(\"No solution\\n\"); return 0; } dfs(S); int x=fa[T],ans=inf; while(x!=S) { ans=min(ans,x); x=fa[x]; } printf(\"%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"圆方树","slug":"圆方树","permalink":"https://lzylzy.cf/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://lzylzy.cf/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}]},{"title":"P4606 [SDOI2018]战略游戏","date":"2021-05-15T03:13:21.000Z","path":"posts/94b375e3.html","text":"题目描述 给定一个连通图，每次给定一个点集S，求有多少可能的点，删掉后使得S中至少两点不连通 题解 圆方树经常用来解决图上路径问题 我们知道圆方树的一个性质，即两圆点之间经过的圆点是两点之间所有路径经过的点的并集 更通俗地，两圆点之间的园点都是这两个点的割点 而这题把两个点扩展到了|S|个，我们的思路还是同样的 我们对原图建出圆方树，发现答案就是一个最小的覆盖所有给定圆点的集合 这个集合当中的圆点个数，再减去|S| 接下来的问题是如何统计其中的圆点 我们把每条从圆点出发向上的边权值设为1 更具体地，可以通过一遍dfs 当向下走而目标是圆点时，这条边有权值，否则为0 接下来按照dfs序排序 排序之后求出所有dfs序相邻点之间路径的权值和 这个和就是所有边权值和的两倍 统计完之后，如果深度最小的点是圆点 记得把答案+1 因为它没有贡献向上的边 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 400009 int n,m; int low[maxn],dfn[maxn],stk[maxn]; int dep[maxn]; int dfk[maxn],ff=0; int top=0,cnt=n; int fa[maxn][20],num=0; vector&lt;int&gt; son[maxn],t[maxn]; int a[maxn]; int s[maxn];//这个点到根路径上的和 int cmp(int a,int b) { return dfk[a]&lt;dfk[b]; } void tarjan(int x) { stk[++top]=x; num++; low[x]=dfn[x]=num; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(!dfn[to]) { tarjan(to); low[x]=min(low[x],low[to]); if(low[to]==dfn[x])//找到一个点双 { cnt++; for(int k=0;k!=to;top--) { k=stk[top]; t[cnt].push_back(k); t[k].push_back(cnt); } t[x].push_back(cnt); t[cnt].push_back(x); } }else low[x]=min(low[x],dfn[to]); } } void dfs(int x) { dfk[x]=++ff; for(int i=0;i&lt;t[x].size();i++) { int to=t[x][i]; if(!fa[to][0]) { fa[to][0]=x; dep[to]=dep[x]+1; s[to]=s[x]; if(to&lt;=n)s[to]++; dfs(to); } } } int lca; int LCA(int x,int y) { if(dep[x]&lt;dep[y])swap(x,y); int k=dep[x]-dep[y],l=0; int ans=s[x]+s[y]; while(k) { if(k&amp;1)x=fa[x][l]; l++;k&gt;&gt;=1; } if(x==y) { lca=x; return ans-2*s[lca]; } for(int i=19;i&gt;=0;i--) { if(fa[x][i]!=fa[y][i]) { x=fa[x][i],y=fa[y][i]; } } lca=fa[x][0]; return ans-2*s[lca]; } signed main() { int T; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%d\",&amp;n,&amp;m); num=0;cnt=n;ff=0;top=0; memset(s,0,sizeof(s)); memset(low,0,sizeof(low)); memset(dfn,0,sizeof(dfn)); memset(dfk,0,sizeof(dfk)); memset(fa,0,sizeof(fa)); memset(dep,0,sizeof(dep)); for(int i=0;i&lt;=2*n;i++) { son[i].clear();t[i].clear(); } for(int i=1;i&lt;=m;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); son[x].push_back(y); son[y].push_back(x); } tarjan(1); dfs(1); for(int i=1;i&lt;=19;i++) { for(int j=1;j&lt;=n;j++) { fa[j][i]=fa[fa[j][i-1]][i-1]; } } int q; scanf(\"%d\",&amp;q); while(q--) { int l; scanf(\"%d\",&amp;l); for(int j=1;j&lt;=l;j++) { scanf(\"%d\",&amp;a[j]); } sort(a+1,a+1+l,cmp); int sum=0; for(int i=1;i&lt;l;i++) { sum+=LCA(a[i],a[i+1]); } sum+=LCA(a[1],a[l]); sum/=2; sum-=l; if(lca&lt;=n)sum++; printf(\"%d\\n\",sum); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"圆方树","slug":"圆方树","permalink":"https://lzylzy.cf/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://lzylzy.cf/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"LCA","slug":"LCA","permalink":"https://lzylzy.cf/tags/LCA/"},{"name":"倍增","slug":"倍增","permalink":"https://lzylzy.cf/tags/%E5%80%8D%E5%A2%9E/"}]},{"title":"圆方树 && P4630 [APIO2018] Duathlon 铁人两项","date":"2021-05-04T03:18:46.000Z","path":"posts/ff118e30.html","text":"题目描述 给定一张简单无向图，问有多少对三元组 ⟨s,c,f⟩（s,c,fs,c,f 互不相同）使得存在一条简单路径从 s 出发，经过 c 到达 f。 题解 圆方树入门 兔队讲的超级透彻 建议先去读他的文章（ 讲的通俗一点 个人觉得最重要的是下面这句 即同一个点双中的两不同点 u,v 之间一定存在一条简单路径经过给定的在同一个点双内的另一点 w。 一个方点表示一个点双，和方点相连的所有点都是点双中的点 于是对于固定的s f，所有可能c的个数就是路径上经过的圆点 还有所有经过的方点的相邻圆点数量之和 接下来是圆方树的一个常用技巧：路径统计时，点赋上合适的权值。 本题中，每个方点的权值为对应点双的大小，而每个圆点权值为 −1。 这样赋权后则有两圆点间圆方树上路径点权和，恰好等于原图中简单路径并集大小减 2。 圆点赋值都为-1 这样可以在两端都有方点的时候减去重复计算的部分 还可以在最后减去开始和结尾两个点 恰好算出答案 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 200009 int n,m; int low[maxn*2],dfn[maxn*2]; ll cnt=0,num=0,dfk=0; ll ans=0; vector&lt;int&gt; son[maxn*2],t[maxn*2]; int stk[maxn],top=0; ll val[maxn*2]; void tarjan(int x)//构建圆方树，赋值 { dfn[x]=low[x]=++dfk; stk[++top]=x; num++; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(!dfn[to]) { tarjan(to); low[x]=min(low[x],low[to]); if(low[to]==dfn[x]) { //出现了一坨点双 cnt++; val[cnt]=0; for (int x = 0; x != to; --top) { x = stk[top]; t[cnt].push_back(x); t[x].push_back(cnt); ++val[cnt]; } val[cnt]++; int k=x; t[k].push_back(cnt); t[cnt].push_back(k); } }else { low[x]=min(low[x],dfn[to]); } // cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;dfn[x]&lt;&lt;\" \"&lt;&lt;low[x]&lt;&lt;endl; } } int size[maxn*2]; void dfs(int x,int fa)//从x出发 { //num是圆点 //size是这个子树里的圆点 size[x]=(x&lt;=n); for(int i=0;i&lt;t[x].size();i++) { int to=t[x][i]; if(to==fa)continue; dfs(to,x); ans+=2ll*val[x]*size[x]*size[to]; size[x]+=size[to]; } ans+=2ll*val[x]*size[x]*(num-size[x]); } signed main() { scanf(\"%d%d\",&amp;n,&amp;m); cnt=n; memset(val,-1,sizeof(val)); for(int i=1;i&lt;=m;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); son[x].push_back(y); son[y].push_back(x); } for(int i=1;i&lt;=n;i++) { if(!dfn[i]) { num=0; tarjan(i); top=0;//根节点不会出栈 dfs(i,0); } } printf(\"%lld\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"圆方树","slug":"圆方树","permalink":"https://lzylzy.cf/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"}]},{"title":"P2986 [USACO10MAR]Great Cow Gathering G","date":"2021-02-28T14:20:17.000Z","path":"posts/b8b65d.html","text":"题目描述 点有点权边有边权，求树的重心 暴力 最好想的方法是枚举选择的节点，然后挨个计算这个节点的费用 复杂度是O(n^2) 正解 暴力需要枚举每一个节点，我们想，如果能从上一个节点的答案推出下一个节点的答案，是不是就能省去一个n的复杂度 于是变成了树形dp问题 设计状态 树形dp状态往往跟子树有关 设size[i]表示以i为根的子树总共有多少头牛 dis[i]表示i子树所有的儿子都走到点i的总费用 f[i]表示以i点作为重心的总费用，最小的f[i]即为答案 求解方法 dfs，这里可以两次dfs 第一次预处理出size和dis数组 第二次计算f 当有了f[fa],size和dis数组时可以O(1)转移，读者不妨手推一下式子 dfs2中有关于转移的注释 code #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const long long inf=10000000000000000; typedef long long ll; #define int ll int n; int sum=0; #define maxn 100009 vector&lt;int&gt; son[maxn],val[maxn]; int size[maxn];//以i为根的子树有多少个牛 int c[maxn]; int dis[maxn];//子树i的所有儿子到i的总费用 int mindis=inf,ans; int f[maxn];//选择i的总费用 void dfs(int x,int fa) { size[x]=c[x]; dis[x]=0; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(to!=fa) { dfs(to,x); size[x]+=size[to]; dis[x]+=dis[to]+val[x][i]*size[to]; } } //cout&lt;&lt;x&lt;&lt;\" size:\"&lt;&lt;size[x]&lt;&lt;\" dis:\"&lt;&lt;dis[x]&lt;&lt;endl; } void dfs2(int x,int fa,int dist) { if(x!=1)f[x]=f[fa]-dis[x]-size[x]*dist+(sum-size[x])*dist; /* 对于一个f[i]，大体思路是求出上面的节点走父亲过来的费用 再加上dis[i] 求上面节点的总牛数是(sum-size[x]) 乘以过来的费用dist 再加上上面所有节点到fa的费用,f[fa]-dis[x]-size[x]*dist, 就是父亲的总费用减去自己子树里节点到父亲的费用 */ f[x]+=dis[x]; if(f[x]&lt;mindis) { mindis=f[x]; } for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(to!=fa) { dfs2(to,x,val[x][i]); } } } signed main() { // freopen(\"2986.in\",\"r\",stdin); scanf(\"%lld\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;c[i]); sum+=c[i]; } for(int i=1;i&lt;n;i++) { int x,y,z; scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z); son[x].push_back(y); val[x].push_back(z);//x-&gt;y son[y].push_back(x); val[y].push_back(z); } dfs(1,0); dfs2(1,0,0); printf(\"%lld\\n\",mindis); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"}]},{"title":"P2120 [ZJOI2007]仓库建设（斜率优化）","date":"2021-02-24T13:18:25.000Z","path":"posts/a8ee3eef.html","text":"题目描述 有N个工厂，第i个有Pi件产品，和第一个工厂的距离是Xi 现在对于所有工厂i，要么花费Ci建立一个无限容量的仓库，要么把所有产品运送到最近的仓库且 只能运往编号更大的仓库 一个产品运送1单位距离的费用是1 求最小费用 n \\leq 10^6 ，开ll 题解 朴素 一看是dp题目，不妨先把朴素的式子写出来 不难想到设Fi表示处理前i个工厂并且在i处建设仓库的最小费用 枚举一个j Fi=Fj+Ci+（运送j+1,j+2…i-1号工厂所有物品到i的费用） 下面分析括号里的这一部分 对于一个工厂a，他运送货物到i的费用是 (X[a]−X[i])∗Pa(X[a]-X[i])*Pa(X[a]−X[i])∗Pa​ 拆开，得到 X[a]∗Pa−X[i]∗PaX[a]*Pa - X[i]*PaX[a]∗Pa−X[i]∗Pa​ 因此我们要做的就是快速求出一段X[a]∗PaX[a]*PaX[a]∗Pa​ 和 PaPaPa​ 的和，这样就能算出连续一段工厂运送物品的费用 显然可以用前缀和维护，我们设sum[i]表示 X[a]*Pa 的前缀和，sump[i]表示$ Pa $ 的前缀和 于是得到式子 f[i]=f[j]+c[i]+sum[j]−sum[i]+x[i]∗(sump[i]−sump[j])f[i]=f[j]+c[i]+sum[j]-sum[i]+x[i]*(sump[i]-sump[j])f[i]=f[j]+c[i]+sum[j]−sum[i]+x[i]∗(sump[i]−sump[j]) 时间复杂度是平方级别，40pts到手 斜率优化 可能我的方法不大一样，冬令营听来的QwQ 我们把式子移项，直到变成y=kx+b的形式 其中 y只和j有关 k只和i有关 x只和j有关 b只和i有关 建议手推一下，得到下面的样子 x[i]* sump[j] -sump[i]*x[i]+f[i]+sum[i]-c[i] = f[j] +sum[j] 于是 k=x[i],x=sump[j],b=-sump[i]*x[i]+f[i]+sum[i]-c[i],y=f[j]+sum[j] 于是可以套上斜率优化的模板了 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 10010000 #define int ll int sum[maxn],sump[maxn]; int f[maxn]; int x[maxn]; int n; int head=1,tail=1; int q[maxn]; int c[maxn]; double X(int a) { return sump[a]; } double Y(int a) { return f[a] +sum[a]; } double slope(int a,int b) { return 1.0*(double)(Y(b)-Y(a))/(double)(X(b)-X(a)); } signed main() { scanf(\"%lld\",&amp;n); for(int i=1;i&lt;=n;i++) { int xx,p; scanf(\"%lld%lld%lld\",&amp;xx,&amp;p,&amp;c[i]); x[i]=xx; sum[i]=sum[i-1]+xx*p; sump[i]=sump[i-1]+p; } for(int i=1;i&lt;=n;i++) { //先搞队头 斜率小于k的通通扔掉 int k=x[i]; while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&lt;k)head++; int j=q[head]; f[i]=f[j]+sum[j]+c[i]-sum[i]+x[i]*(sump[i]-sump[j]); while(head&lt;tail&amp;&amp;slope(q[tail],i)&lt;slope(q[tail-1],i))tail--; q[++tail]=i; } printf(\"%lld\\n\",f[n]); return 0; } /* f[i]表示处理完前i个工厂的费用 f[i]=f[j]+sum[j]+c[i]+sump[i]*x[i]-sum[i]-x[i]*sump[j] x[i]*sump[j] -sump[i]*x[i]+f[i]+sum[i]-c[i] = f[j] +sum[j] k x b y 一定在第i个工厂建仓库，后面都往下运 */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://lzylzy.cf/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"}]},{"title":"P2922 [USACO08DEC]Secret Message G","date":"2021-02-15T14:09:33.000Z","path":"posts/d06a5ae0.html","text":"题目描述 贝茜正在领导奶牛们逃跑．为了联络，奶牛们互相发送秘密信息． 信息是二进制的，共有 M条，反间谍能力很强的约翰已经部分拦截了这些信息，知道了第 i 条二进制信息的前 bi位，他同时知道，奶牛使用 N（N≤50000）条暗号．但是，他仅仅知道第 j条暗号的前 cj位。 对于每条暗号 j，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条暗号有着相同的前缀。当然，这个前缀长度必须等于暗号和那条信息长度的较小者。 在输入文件中，位的总数不会超过 500000。 题解 显然是字典树的板子题 在统计答案时，对于访问到的每一个节点 加上end[x]，在最后一个节点加上sum[x] 因为一个串是另一个串的前缀并没有说关系 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 500009 int End[maxn]; int ch[maxn][20]; ///ch[u][i]表示节点u的i字符指针指向的节点，若值为0，表示没有这个节点 int sum[maxn]; //经过这个节点的字符个数 int n,m; int b[maxn];//要添加的字符串 int cnt=1; void add(int k) { int now=1; for(int i=1;i&lt;=k;i++) { if(!ch[now][b[i]])//当前节点没有被建立 { ch[now][b[i]]=++cnt; } //既然访问了now这个点肯定要统计 now=ch[now][b[i]]; sum[now]++; //cout&lt;&lt;i&lt;&lt;\" and \"&lt;&lt;b[i]&lt;&lt;\" \"&lt;&lt;now&lt;&lt;endl; } End[now]++; } int query(int k) { int ans=0,now=1; for(int i=1;i&lt;=k;i++) { if(!ch[now][b[i]])return ans; now=ch[now][b[i]]; ans+=End[now]; } return ans-End[now]+sum[now]; } signed main() { scanf(\"%d%d\",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++) { int k; scanf(\"%d\",&amp;k); for(int j=1;j&lt;=k;j++)scanf(\"%d\",&amp;b[j]); add(k); } for(int i=1;i&lt;=n;i++) { int k; scanf(\"%d\",&amp;k); for(int j=1;j&lt;=k;j++) { scanf(\"%d\",&amp;b[j]); } printf(\"%d\\n\",query(k)); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"trie树","slug":"trie树","permalink":"https://lzylzy.cf/tags/trie%E6%A0%91/"}]},{"title":"P1344 [USACO4.4]追查坏牛奶Pollutant Control","date":"2021-01-24T12:02:18.000Z","path":"posts/a106f089.html","text":"题目描述 你第一天接手三鹿牛奶公司就发生了一件倒霉的事情：公司不小心发送了一批有三聚氰胺的牛奶。很不幸，你发现这件事的时候，有三聚氰胺的牛奶已经进入了送货网。这个送货网很大，而且关系复杂。你知道这批牛奶要发给哪个零售商，但是要把这批牛奶送到他手中有许多种途径。送货网由一些仓库和运输卡车组成，每辆卡车都在各自固定的两个仓库之间单向运输牛奶。在追查这些有三聚氰胺的牛奶的时候，有必要保证它不被送到零售商手里，所以必须使某些运输卡车停止运输，但是停止每辆卡车都会有一定的经济损失。你的任务是，在保证坏牛奶不送到零售商的前提下，制定出停止卡车运输的方案，使损失最小。 输入格式 第一行: 两个整数N(2&lt;=N&lt;=32)、M(0&lt;=M&lt;=1000), N表示仓库的数目，M表示运输卡车的数量。仓库1代 表发货工厂，仓库N代表有三聚氰胺的牛奶要发往的零售商。 第2…M+1行: 每行3个整数Si,Ei,Ci。其中Si,Ei表示这 辆卡车的出发仓库，目的仓库。Ci(0 &lt;= C i &lt;= 2,000,000) 表示让这辆卡车停止运输的损失。 输出格式 两个整数C、T：C表示最小的损失，T表示在损失最小的前提下，最少要停止的卡车数。 典型的最小割题目，但是第二问需要思考一下 由于最小割=最大流，所以我们可以直接通过 $ Dinic $ 求出最小割 但如何做到求最小割的时候边数最小？ 一种思路是建一张边权为1的图跑最小割来求得边数 当然我们完全可以用最大流一次搞定 我们把所有的边权都加上一个特别小 小到不会影响答案的数，例如千分之一或万分之一 这样最小割的时候就能选出最少的边而答案不会变 具体地说，在建图时，每条边的边权W=w*a+1,a 为大于M的数 在算出答案后, ans/a是最小割，ans%a是最少边数 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; #define inf 10000000000000000 typedef long long ll; #define int ll #define maxn 2009 struct node{ int to; int val; int rev; }; vector&lt;node&gt; son[maxn]; int n,m; void add(int x,int y,int z) { son[x].push_back(node{y,z*maxn+1,son[y].size()}); son[y].push_back(node{x,0,son[x].size()-1});; } int S,T; int d[maxn]; bool bfs() { memset(d,-1,sizeof(d)); queue&lt;int&gt; q; d[S]=0; q.push(S); while(!q.empty()) { int x=q.front(); q.pop(); for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i].to; if(son[x][i].val&amp;&amp;d[to]==-1) { d[to]=d[x]+1; q.push(to); } } } if(d[T]==-1)return 0; return 1; } int dfs(int x,int low) { if(x==T||low==0)return low; int totflow=0; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i].to; int rev=son[x][i].rev; int val=son[x][i].val; if(val&amp;&amp;d[to]==d[x]+1) { int a=dfs(to,min(low,val)); son[x][i].val-=a; son[to][rev].val+=a; low-=a; totflow+=a; if(low==0)return totflow; } } if(low!=0)d[x]=-1; return totflow; } signed main() { scanf(\"%lld%lld\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y,z; scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z); add(x,y,z); } ll ans=0; S=1,T=n; while(bfs()) { ans+=dfs(S,inf); } printf(\"%lld %lld\\n\",ans/maxn,ans%maxn); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"网络流","slug":"网络流","permalink":"https://lzylzy.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"ABC187-D Choose Me ","date":"2021-01-09T06:20:29.000Z","path":"posts/e37a67de.html","text":"Problem statement 有n个城市，A，T两个人参加竞选 如果T在i城市进行演讲，则该城市所有人都会给T投票 否则，A的支持者给A投票，T的支持者不会投票 贪心问题 显然做出一场演讲会使对手失去ai票 自己得到(ai+bi)票 所以每场演讲的贡献是(ai*2+bi) 按照这个顺序对所有城市排序之后贪心即可 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define int ll #define maxn 200009 struct node{ ll a,b; }a[maxn]; int n; int cmp3(node a,node b) { if(a.a*2+a.b==b.a*2+b.b)return a.a&gt;b.a; return a.a*2+a.b&gt;b.a*2+b.b; } signed main() { scanf(\"%lld\",&amp;n); ll sum=0; for(int i=1;i&lt;=n;i++) { scanf(\"%lld%lld\",&amp;a[i].a,&amp;a[i].b); sum+=a[i].a; } ll sum2=sum,s=0;; int p1=maxn; sort(a+1,a+1+n,cmp3); for(int i=1;i&lt;=n;i++) { sum2-=a[i].a; s+=a[i].a+a[i].b; if(s&gt;sum2) { p1=min(p1,i);break; } } printf(\"%lld\\n\",p1); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"AT","slug":"AT","permalink":"https://lzylzy.cf/tags/AT/"},{"name":"贪心","slug":"贪心","permalink":"https://lzylzy.cf/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"ABC187-E - Through Path","date":"2021-01-09T06:04:42.000Z","path":"posts/3efff2f9.html","text":"Problem Statement 给定一棵无根树，每次对一条边$ (a,b)$ 进行操作 让所有a不经过b就能到达的节点权值+k 或者让所有b不经过a就能到达的节点权值+k 2≤N≤2×1052 \\le N \\le 2 \\times 10^52≤N≤2×105 显然是树链剖分的板子 由于每次操作的都是一条边两端的点 于是可以观察性质 整棵树分为上下两部分 操作是给黄色部分+k或是绿色部分+k 同样的，无论哪个点为根，能够到达的点不会变化 所以以1为根，给深度较大的点的子树+k 或是给整棵树+k，给给深度较大的点的子树-k #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; #define inf 0x7fffffff #define ll long long using namespace std; #define int ll #define maxn 600009 #define mod 10000000000000000 int dfn[maxn],cnt,pos[maxn],son[maxn],en[maxn],top[maxn],size1[maxn],fa[maxn],deep[maxn]; vector&lt;int&gt; v[maxn]; struct node{ int l,r; int val,mark; }tr[maxn*4]; int n,m; int a[maxn],b[maxn]; void dfs(int rt) { size1[rt]=1; for(int i=0;i&lt;v[rt].size();i++) { int to=v[rt][i]; if(!size1[to]) { fa[to]=rt; deep[to]=deep[rt]+1; dfs(to); size1[rt]+=size1[to]; if(size1[to]&gt;size1[son[rt]])son[rt]=to; } } } void dfs(int x,int tp) { top[x]=tp; cnt++; pos[x]=cnt; dfn[cnt]=x; if(son[x]!=0)dfs(son[x],tp); for(int i=0;i&lt;v[x].size();i++) { int to=v[x][i]; if(!top[to])dfs(to,to); } en[x]=cnt; } void Build(int x,int l,int r) { tr[x].l=l,tr[x].r=r; if(l==r) { tr[x].mark=0; tr[x].val=0; return; } int mid=(l+r)&gt;&gt;1; Build(x*2,l,mid); Build(x*2+1,mid+1,r); tr[x].mark=0; tr[x].val=tr[x*2].val+tr[x*2+1].val; tr[x].val%=mod; } void relese(int x) { if(tr[x].mark==0||tr[x].l==tr[x].r)return; tr[x*2].val+=(tr[x*2].r-tr[x*2].l+1)*tr[x].mark; tr[x*2].mark+=tr[x].mark; tr[x*2+1].val+=(tr[x*2+1].r-tr[x*2+1].l+1)*tr[x].mark; tr[x*2+1].mark+=tr[x].mark; tr[x*2].val%=mod; tr[x*2].mark%=mod; tr[x*2+1].mark%=mod; tr[x*2+1].val%=mod; tr[x].mark=0; } void Add(int x,int l,int r,int val) { if(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r) { tr[x].val+=(tr[x].r-tr[x].l+1)*val; tr[x].val%=mod; tr[x].mark+=val; tr[x].mark%=mod; return; } //cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl; relese(x); int mid=(tr[x].l+tr[x].r)&gt;&gt;1; if(l&lt;=mid)Add(x*2,l,r,val); if(r&gt;mid)Add(x*2+1,l,r,val); tr[x].val=tr[x*2].val+tr[x*2+1].val; tr[x].val%=mod; } int Sum(int x,int l,int r) { if(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r) { return tr[x].val; } relese(x); int mid=(tr[x].l+tr[x].r)&gt;&gt;1; int ans=0; if(l&lt;=mid) ans+=Sum(x*2,l,r); if(r&gt;mid) ans+=Sum(x*2+1,l,r); ans%=mod; return ans; } void LCA_add(int x,int y,int val) { while(top[x]!=top[y]) { if(deep[top[x]]&lt;deep[top[y]])swap(x,y); Add(1,pos[top[x]],pos[x],val); x=fa[top[x]]; } //if(x!=y) //{ if(pos[x]&gt;pos[y])swap(x,y); Add(1,pos[x],pos[y],val); // } } int LCA_sum(int x,int y) { int res=0; while(top[x]!=top[y]) { if(deep[top[x]]&lt;deep[top[y]])swap(x,y); res+=Sum(1,pos[top[x]],pos[x]); res%=mod; x=fa[top[x]]; } if(pos[x]&gt;pos[y])swap(x,y); res+=Sum(1,pos[x],pos[y]); return res%mod; } bool wped[maxn]; signed main() { scanf(\"%lld\",&amp;n); for(int i=1;i&lt;n;i++) { int x,y; scanf(\"%lld%lld\",&amp;x,&amp;y); v[x].push_back(y); v[y].push_back(x); a[i]=x,b[i]=y; } int r=1; dfs(r); dfs(r,r); Build(1,1,n); scanf(\"%lld\",&amp;m); while(m--) { int opt,x,y; scanf(\"%lld%lld%lld\",&amp;opt,&amp;x,&amp;y); if(deep[a[x]]&gt;deep[b[x]]) { swap(a[x],b[x]);wped[x]=1; } if(wped[x]==1)opt++; if(opt==1||opt==3) { Add(1,pos[1],en[1],y); Add(1,pos[b[x]],en[b[x]],-y); }else if(opt==2) { Add(1,pos[b[x]],en[b[x]],y); } } for(int i=1;i&lt;=n;i++) { printf(\"%lld\\n\",Sum(1,pos[i],pos[i])); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"AT","slug":"AT","permalink":"https://lzylzy.cf/tags/AT/"},{"name":"线段树","slug":"线段树","permalink":"https://lzylzy.cf/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树剖","slug":"树剖","permalink":"https://lzylzy.cf/tags/%E6%A0%91%E5%89%96/"}]},{"title":"P4138 [JOISC2014] 挂饰","date":"2021-01-01T14:29:39.000Z","path":"posts/7ab2df.html","text":"题目描述 JOI君有N个装在手机上的挂饰，编号为1…N。 JOI君可以将其中的一些装在手机上。 JOI君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有1个。 此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果JOI君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。 JOI君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。 输入格式 第一行一个整数N，代表挂饰的个数。 接下来N行，第i行(1&lt;=i&lt;=N)有两个空格分隔的整数Ai和Bi，表示挂饰i有Ai个挂钩，安装后会获得Bi的喜悦值。 输出格式 输出一行一个整数，表示手机上连接的挂饰总和的最大值 1≤N≤2000 题解 显然对于传统的背包，本题多了“增加容量”这一选项 相当于“占用的空间”可以为负数 ，即增加空间 于是可以先设计出状态，设 f[i][j]f[i][j]f[i][j] 表示前i件物品 有j个空闲的挂钩 考虑转移，先枚举每件物品 还要考虑越界的情况 即 $ j-a[i].num&lt;0$ 表示我们要求的空闲挂钩数太少了 直接跳过即可 转移方程为 $ f[i][j]=max(f[i-1][j],f[i-1][max(0,j-a[i].num)+1]+a[i].joy); $ #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x3f3f3f3f; typedef long long ll; int n; #define maxn 2009 int f[maxn][maxn]; /* f[i][j]表示前i个物品 当前j个挂钩时候的最大值 */ struct node{ int num,joy; }a[maxn]; int cmp(node a,node b) { return a.num&gt;b.num; } signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d%d\",&amp;a[i].num,&amp;a[i].joy); f[0][i]=-inf;f[i][n+1]=-inf; } f[0][0]=f[0][n+1]=-inf; sort(a+1,a+1+n,cmp); f[0][1]=0; for(int i=1;i&lt;=n;i++) { for(int j=n;j&gt;=0;j--) { f[i][j]=max(f[i-1][j],f[i-1][max(0,j-a[i].num)+1]+a[i].joy); } } int ans=-inf; for(int i=0;i&lt;=n;i++)ans=max(ans,f[n][i]); printf(\"%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"}]},{"title":"ABC180 E - Traveling Salesman among Aerial Cities","date":"2020-12-20T07:59:53.000Z","path":"posts/4765f64c.html","text":"题意 [传送门][https://atcoder.jp/contests/abc180/tasks/abc180_e] 在一个三维空间内 任意两点(a,b,c)(a,b,c)(a,b,c) (p,q,r)(p,q,r)(p,q,r)的距离定义为 ∣p−a∣+∣q−b∣+max⁡(0,r−c)|p-a|+|q-b|+\\max(0,r-c)∣p−a∣+∣q−b∣+max(0,r−c) 求从1号点出发 遍历所有点至少一次后再回到一号点的最短距离 2≤N≤172 \\leq N \\leq 172≤N≤17 解决 观察n的范围像是状压 设f[i][j]f[i][j]f[i][j]表示j状态下到达i城市时候的最小花费 枚举一个点k 若j的二进制中第i位为1且第k位为0，则 $ f[k][j|(1&lt;&lt;k)]=min(f[k][j|(1&lt;&lt;k)],f[i][j]+dis[i][k]);$ 其中dis[i][k]dis[i][k]dis[i][k]表示i到k的最短距离 可以使用Floyd等最短路算法解决 记得先枚举状态再枚举节点 最后扫描每个节点的目标状态（全是1） 找出目标状态再一次回到1号点的最小花费 此处 因为图上距离的定义 所以我们不必再多枚举其他节点 code #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n; #define maxn 20 int x[maxn],y[maxn],z[maxn]; ll f[maxn][1048579]; ll dis[maxn][maxn]; ll Dis(int m,int f) { ll a=x[m],b=y[m],c=z[m]; ll p=x[f],q=y[f],r=z[f]; return abs(p-a)+abs(q-b)+max(0ll,r-c); } void Init() { for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { dis[i][j]=Dis(i,j); } dis[i][i]=0; } for(int k=0;k&lt;n;k++) { for(int i=0;i&lt;n;i++) { if(i==k)continue; for(int j=0;j&lt;n;j++) { if(i!=j&amp;j!=k) { dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); } } } } } signed main() { scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++) { scanf(\"%d%d%d\",&amp;x[i],&amp;y[i],&amp;z[i]); } Init(); memset(f,0x3f,sizeof(f)); f[0][1]=0; for(int j=1;j&lt;(1&lt;&lt;(n));j++) { for(int i=0;i&lt;n;i++) { if(!(j&amp;(1&lt;&lt;i)))continue; for(int k=0;k&lt;n;k++) { if((j&amp;(1&lt;&lt;k)))continue; // cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;k&lt;&lt;\" \"&lt;&lt;dis[i][k]&lt;&lt;endl; f[k][j|(1&lt;&lt;k)]=min(f[k][j|(1&lt;&lt;k)],f[i][j]+dis[i][k]); } } } ll ans=inf; int j=(1&lt;&lt;(n))-1; for(int i=1;i&lt;n;i++) { ans=min(ans,f[i][j]+dis[i][0]); //cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;f[i][j]&lt;&lt;endl; } printf(\"%lld\\n\",ans); return 0; } 官方英文题解 Since the triangular inequalities hold among the costs of traveling between the cities, so there is no need to travel from one city to another via other cities other than those two cities. Searching all the orders of visiting towns requires a total of O(N!∗N)O(N!∗N) time, in which the answer cannot be obtained in time under the constraints this time. The problem can be solved by the following DP: DP[i][S]=DP[i][S]= The minimum cost when you are currently at city ii and the set of towns you have already visited is SS DP[i][S]=min{DP[j][S∖{i}]+dist(i,j)∣j∈S∖{i}}DP[i][S]=min{DP[j][S∖{i}]+dist(i,j)∣j∈S∖{i}} Here, you may hold the set SS itself as a key, but you can treat those sets as integers by associating them with binaries, for example, Associating {0,3,5}{0,3,5} with 20+23+25=4120+23+25=41. That’s why this kind of DP is sometimes called bitDP. The integer obtained by the correspondence, f(S)f(S), satisfies the following properties: i∈S⟺i∈S⟺ The ii-th bit of f(S)f(S) is 11 T⊂S⟺(f(T) bitwiseor f(S))=f(S)⟹f(T)≤f(S)T⊂S⟺(f(T) bitwiseor f(S))=f(S)⟹f(T)≤f(S) so operations and properties on sets can be represented concisely by bit operations. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"AT","slug":"AT","permalink":"https://lzylzy.cf/tags/AT/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"}]},{"title":"P3138 [USACO16FEB]Load Balancing S","date":"2020-12-12T14:03:04.000Z","path":"posts/9b7b174.html","text":"题目描述 Farmer John 的 N(N&lt;=10^5)头奶牛散布在整个农场上。整个农场是一个无限大的二维平面，第 ii 头奶牛的坐标是 xi,yi（保证 均为正奇数，且 x_最大值为1e6），且没有任意两头奶牛在同一位置上。 FJ 希望修建一条竖直方向的栅栏，它的方程是 x=a，他还希望修建一条水平方向的栅栏，它的方程是 y=b。为了防止栅栏经过奶牛，a,b均要求是偶数。容易发现，这两个栅栏会在 (a,b) 处相交，将整个农场分割为四个区域。 FJ 希望这四个区域内的奶牛数量较为均衡，尽量避免一个区域奶多而另一个区域奶牛少的情况。令 MM 为四个区域里奶牛最多区域的奶牛数量，请帮 FJ 求出 M 的最小值。 输入格式 第一行一个整数 NN。 接下来 N 行，每行两个整数 x_i,y_i，描述第 i头奶牛的位置。 输出格式 输出 M 的最小值。 解决 最大值最小是典型的二分描述 于是初步思路为二分M的值 接下来的判断操作转化为：给定M 确定是否有两条线把整个图像分成四个矩形 而每个矩形内奶牛数量小于M 此处利用双指针法 即一开始让y为1，尽可能把x变大 每次让y+1 不断减小x直到(x,y)合法 每次判断复杂度即为O(N) 如何判断合法？ 简单地说，我们需要在O(logN)或O(1)的时间内 计算一个矩形中点的个数 此题为弱化版 只有一千个点 但是点的范围为10^6 所以可以离散化之后使用二维前缀和解决。 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n; #define maxn 10009 struct node{ int x,y; }a[maxn]; int cmp(node a,node b) { if(a.x==b.x)return a.y&lt;b.y; return a.x&lt;b.x; } int cmp2(node a,node b) { if(a.y==b.y)return a.x&lt;b.x; return a.y&lt;b.y; } int f[maxn][maxn],maxx,maxy; inline int Get(int x1,int y1,int x2,int y2) { return f[x2][y2]+f[x1][y1]-f[x1][y2]-f[x2][y1]; } void Init()//二维前缀和初始化 { for(int i=1;i&lt;=maxx;i++) { for(int j=1;j&lt;=maxy;j++) { //if(f[i][j]==1)cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;endl; f[i][j]+=f[i][j-1]+f[i-1][j]-f[i-1][j-1]; } } } bool check(int x) { int lx=1,ly=1; int sum=0; while(1) { sum=Get(0,0,lx,ly); if(sum&gt;x||lx&gt;maxx) { lx--; break; } lx++; } while(lx&gt;=1&amp;&amp;ly&lt;=maxy) { //验证lx,ly剩下三块是否符合要求 if(Get(lx,0,maxx,ly)&lt;=x&amp;&amp;Get(lx,ly,maxx,maxy)&lt;=x&amp;&amp;Get(0,ly,lx,maxy)&lt;=x) { //cout&lt;&lt;lx&lt;&lt;\" \"&lt;&lt;ly&lt;&lt;\" \"&lt;&lt;x&lt;&lt;endl; return 1; } ly++; while(Get(0,0,lx,ly)&gt;x&amp;&amp;lx&gt;=1) { lx--; } } return 0; } signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d%d\",&amp;a[i].x,&amp;a[i].y); } sort(a+1,a+1+n,cmp); int last=-1; for(int i=1;i&lt;=n;i++) { if(a[i].x==last)last=a[i].x,a[i].x=a[i-1].x; else last=a[i].x,a[i].x=a[i-1].x+1; maxx=max(maxx,a[i].x); } sort(a+1,a+1+n,cmp2); for(int i=1;i&lt;=n;i++) { if(a[i].y==last)last=a[i].y,a[i].y=a[i-1].y; else last=a[i].y,a[i].y=a[i-1].y+1; f[a[i].x][a[i].y]=1; maxy=max(maxy,a[i].y); } //离散化完成 Init(); int l=0,r=n,ans; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(check(mid)) { ans=mid; r=mid-1; }else l=mid+1; } printf(\"%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"二分","slug":"二分","permalink":"https://lzylzy.cf/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"Atcoder  ABC180游记","date":"2020-10-17T13:00:22.000Z","path":"posts/125d13bd.html","text":"2020.10.17 纪念人生第一场At 还是太菜 ABC只写了前四题就走人了 A-box 从n个球的盒子里拿出来A个 放进去B个 求现在盒子里有多少球 没料到第一题如此良心，是考察基本语法的问题 为啥At不能用万能头啊 假装这里有代码 B - Various distances 给定n维空间上一个点 求它和源点的曼哈顿距离 欧几里得距离 切比雪夫距离 由于题目给定了计算公式，所以模拟即可 记得开long long #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; ll Abs(ll x) { if(x&lt;0)return -x; return x; } ll man=0,euc=0,che=-inf; signed main() { int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { ll x; scanf(\"%lld\",&amp;x); che=max(che,Abs(x)); man+=abs(x); euc+=x*x; } printf(\"%lld\\n%.10lf\\n%lld\\n\",man,sqrt(euc),che); return 0; } C - Cream puff 给定一个数字 求它所有因数 n&lt;=10^12 发现n很大，不能直接枚举 可以从1到根号n枚举i 然后使用stack存下来n/i 倒序输出即可完成后面一半的解 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; signed main() { ll n; scanf(\"%lld\",&amp;n); stack&lt;ll&gt; st; for(ll i=1;i&lt;=sqrt(n);i++) { if(n%i==0) { printf(\"%lld\\n\",i); st.push(n/i); } } if(st.top()*st.top()==n)st.pop();//细节，平方数要pop一下 while(!st.empty()) { printf(\"%lld\\n\",st.top()); st.pop(); } return 0; } D - Takahashi Unevolved 真正开始有难度的地方 要么让x*a，要么让x+b 在X不超过Y的前提下 求最大操作次数 1&lt;x&lt;y&lt;=10^18 1&lt;A&lt;10^9 发现数据范围超大 不可能枚举 我们发现，当X&gt;B时，做乘法一定时亏损的，因为即使是乘以2也比加上B要差 所以先一直用乘法，直到X&gt;B的时候就开始一直用加法 代码有很多细节所以被卡了好久 QwQ #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;cstring&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; ll x,y,a,b; signed main() { scanf(\"%lld%lld%lld%lld\",&amp;x,&amp;y,&amp;a,&amp;b); ll step=0; while(x&lt;=b&amp;&amp;x&lt;y)//使劲做乘法 { step++; x*=a; } y--; if(step) { //这个时候倒退一步 看看做乘法优秀还是加法优秀 x/=a; x=min(x*a,x+b); if(x&gt;y)//做乘法的时候就超标了 { printf(\"%lld\\n\",step-1); return 0; } } ll more=(y-x)/b; printf(\"%lld\\n\",step+more); return 0; } /* 要么让x*a，要么让x+b 在X不超过Y的前提下 求最大操作次数 似乎增加一次之后再做乘法就是亏 所以先乘法 直到亏了之后就一直做加法 一直做乘法，直到x大于b */ EF看着就没有思路，如果有时间会把题解搬过来的 E - Traveling Salesman among Aerial Cities [传送门][https://lzylzy.cf/posts/4765f64c.html] 于是第一次At就这这样结束了QwQ 加了56的rating 排名2.3k 还是太菜 qwq document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://lzylzy.cf/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"P3387 【模板】缩点","date":"2020-10-08T08:43:59.000Z","path":"posts/4796086f.html","text":"给定一个 n个点 m条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。 允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。 算法：Tarjan 缩点 + DAGdp 发现图上可能有环，而重复经过的点只计算一次，我们可以把环缩成点，这样这个点的权值就是环内点权之和 而环与环之间如何连边呢？扫描原来点连出的每一条边，如果两端的点不在同一个强连通分量里，则把两个强连通分量连边 这样问题就变成dag（有向无环图）最长路问题 我们先用拓扑排序找出拓扑序，接着用能到达当前点每一个点来更新当前的答案，所以还要反向建边一次 写的很丑，还望dalao们多多指教 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n,m; #define maxn 100009 int a[maxn]; int scc[maxn],scc_cnt=0,cnt=0; int dfn[maxn],low[maxn],st[maxn],top=0; int val[maxn],in[maxn],l[maxn],f[maxn]; vector&lt;int&gt; son[maxn],e[maxn],rev[maxn]; bool vis[maxn]; void tarjan(int x) { cnt++; dfn[x]=low[x]=cnt; st[++top]=x; vis[x]=1; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(vis[to]) { low[x]=min(low[x],dfn[to]); }else if(!dfn[to]) { tarjan(to); low[x]=min(low[x],low[to]); } } if(low[x]!=dfn[x])return; int k; scc_cnt++; do{ k=st[top]; top--; scc[k]=scc_cnt; val[scc_cnt]+=a[k]; vis[k]=0; }while(k!=x); } signed main() { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); } for(int i=1;i&lt;=m;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); son[x].push_back(y); } for(int i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i); for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;son[i].size();j++) { int to=son[i][j]; if(scc[i]!=scc[to]) { e[scc[i]].push_back(scc[to]); in[scc[to]]++; rev[scc[to]].push_back(scc[i]); } } } queue&lt;int&gt; q; for(int i=1;i&lt;=scc_cnt;i++) { if(in[i]==0)q.push(i); } int k=0; while(!q.empty()) { int now=q.front(); q.pop(); l[++k]=now; for(int i=0;i&lt;e[now].size();i++) { int to=e[now][i]; in[to]--; if(in[to]==0)q.push(to); } } int ans=0; for(int i=1;i&lt;=scc_cnt;i++) { f[l[i]]=val[l[i]]; for(int j=0;j&lt;rev[l[i]].size();j++) { int to=rev[l[i]][j]; f[l[i]]=max(f[l[i]],f[to]+val[l[i]]); } ans=max(ans,f[l[i]]); } printf(\"%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://lzylzy.cf/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}]},{"title":"P1262 间谍网络","date":"2020-10-03T12:55:34.000Z","path":"posts/8459da52.html","text":"给定一张有向图，可以通过购买一个点解锁它能到达的所有点，求收买整个图的最小花费 如果无法收买 输出任意一个不能被收买的点 n&lt;=3000 判断可行性 显然我们从可以被收买的点处开始dfs 如果成功遍历整个图 则说明可以完全被收买 解法 根据贪心的思想，我们应该优先购买那些入度为0的 因为如果从其他点可以到达这个点，那么购买前面的点还能省下购买这个点的钱 而如果出现了环，我们可以用拓展性极强的tarjan解决问题，大体是说在每个环中找到能够被收买而花费最小的点 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 3009 int dfn[maxn]; int low[maxn]; int st[maxn]; int cnt=0,scc_cnt=0; int scc[maxn]; int n,m; int p; vector&lt;int&gt; son[maxn]; int a[maxn],b[maxn]; bool vis[maxn]; int ok[maxn]; int minx[maxn];//每一个连通块里的最小花费 int s=0; void dfs(int x) { vis[x]=1; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(!vis[to])dfs(to); } } void tarjan(int x) { dfn[x]=++cnt; low[x]=cnt; vis[x]=1; st[++s]=x; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(!dfn[to])//没有被访问 { tarjan(to); low[x]=min(low[x],low[to]); }else if(vis[to])//成环了 { low[x]=min(low[x],dfn[to]); }//否则是通向了另一个强连通分量 啥也不干 } if(low[x]!=dfn[x])return; int k; scc_cnt++; minx[scc_cnt]=inf; do { k=st[s--]; vis[k]=0; scc[k]=scc_cnt;//这个点属于scc_cnt个连通块 if(ok[k])minx[scc_cnt]=min(minx[scc_cnt],ok[k]); }while(k!=x); } int in[maxn]; signed main() { //freopen(\"a.in\",\"r\",stdin); scanf(\"%d\",&amp;n); scanf(\"%d\",&amp;p); for(int i=1;i&lt;=p;i++) { scanf(\"%d%d\",&amp;a[i],&amp;b[i]); ok[a[i]]=b[i]; } scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); son[x].push_back(y); in[y]++; } //检查连通性 for(int i=1;i&lt;=p;i++) { dfs(a[i]); } for(int i=1;i&lt;=n;i++) { if(!vis[i]) { printf(\"NO\\n%d\\n\",i); return 0; } } memset(vis,0,sizeof(vis));//循环利用 //开始tarjan for(int i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i); //统计答案 memset(vis,0,sizeof(vis));//循环利用 int ans=0; for(int i=1;i&lt;=n;i++) { if(in[i]==0&amp;&amp;ok[i]) { ans+=ok[i]; dfs(i); } } for(int i=1;i&lt;=n;i++) { if(!vis[i]) { dfs(i); ans+=minx[scc[i]]; } } printf(\"YES\\n%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://lzylzy.cf/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"}]},{"title":"P5021 赛道修建","date":"2020-10-02T12:37:11.000Z","path":"posts/918782fb.html","text":"NOIP2018 D1T3 给定一棵带边权的无根树，试找到M条边不重复的路径，使得长度和最短的路径长度尽量长 N&lt;=5w 转化 长度和最短的路径长度尽量长 很明显是一个二分答案 也就是说 我们把问题转化为一个判定问题 只需要求出有没有长度达到mid的M条路径就可以 解决 通过递归的方式实现 考虑一个节点的所有儿子，把他们的边权排序 我们需要求出的是儿子中匹配出满足长度的链数 和 匹配完成之后剩下的最长边 显然 我们可以单独选择一条长度大于mid的赛道 而且这是最优秀的选择 当然我们也可以选择两条边匹配 从而完成一条总和大于mid的赛道 并且至多两个儿子可以拼在一起，因为赛道只能拐一次弯 而我们在匹配结束后只能留下一条边与他的儿子或者父亲的最大值匹配在一起 这样有两种方式来构造满足条件的赛道 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"贪心","slug":"贪心","permalink":"https://lzylzy.cf/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","permalink":"https://lzylzy.cf/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"P4310 绝世好题","date":"2020-10-01T03:57:43.000Z","path":"posts/434887bc.html","text":"一道dp题目 暴力 一个比较容易的思路是用f[i]表示以i为结尾的最长长度 显然$ f[i]=1+max(f[j] \\space | \\space (j \\space and \\space i !=0)) $ 这个方程可以使用O(n^2)的复杂度实现 优化 为了表述方便 用 a[i]j 表示 a[i]二进制下第j位的值 这样方程可以转化为 $ f[i]=1+max(f[j] \\space | \\space (a[i]k=1,a[j]k=1)) $ 如果先枚举满足a[i]k=1a[i]k=1a[i]k=1的k，那么 $ f[i]=1+max(f[j] \\space | \\space (a[j]k=1)) $ 显然后面这项与i无关，可以维护 我们设数组b b[k]表示满足a[j]k=1的f[j]最大值 b可以用f[i]来更新 于是方程变为 $ f[i]=1+max(b[k] \\space | \\space (a[i]k=1)) $ 解决问题 细节参考代码 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 100009 int n; int f[maxn],b[maxn],a[maxn]; signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); } int ans=0; for(int i=1;i&lt;=n;i++) { for(int k=0;k&lt;=30;k++) { if(a[i]&amp;(1&lt;&lt;k)) { f[i]=max(f[i],1+b[k]); } } for(int k=0;k&lt;=30;k++) { if(a[i]&amp;(1&lt;&lt;k)) { b[k]=max(b[k],f[i]); } } ans=max(ans,f[i]); } printf(\"%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"}]},{"title":"CF638C Road Improvement","date":"2020-10-01T03:33:40.000Z","path":"posts/57405a0b.html","text":"题目描述： 给定一棵有 N 个节点的树，你可以使用两支相邻节点的队伍来修筑它们之间的道路 且 每支队伍一天只能工作一次。问最少需要多少天把所有路修完。输出方最短时间和具体方案。 N≤200000 输入格式： 第一行一个整数 N*，表示有 N 个节点，接下来 N-1 行，每行两个整数 u , v ，表示节点 u v 间连有一条路。 题目大意是说维修所有的边，但维修一条边就要占用两端的节点 也就是说最少的所需天数就是 节点最大的度数 如何求出具体的方案呢？ 显然对于每个节点来说，他不可能和他所有的兄弟和父亲同一天维修 根据这个条件dfs就可以给每条边记录下维修顺序了 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n; #define maxn 200009 vector&lt;int&gt; son[maxn]; vector&lt;int&gt; id[maxn]; vector&lt;int&gt; ans[maxn]; int d[maxn]; int md=0; bool vis[maxn]; void dfs(int rt,int last) { vis[rt]=1; int num=0; for(int i=0;i&lt;son[rt].size();i++) { int to=son[rt][i]; if(vis[to])continue; num++; if(num==last)num++; ans[num].push_back(id[rt][i]); dfs(to,num); } } signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); son[x].push_back(y); id[x].push_back(i); son[y].push_back(x); id[y].push_back(i); d[x]++; d[y]++; md=max(md,max(d[x],d[y])); } dfs(1,0); printf(\"%d\\n\",md); for(int i=1;i&lt;=md;i++) { int l=ans[i].size(); printf(\"%d \",l); for(int j=0;j&lt;l;j++)printf(\"%d \",ans[i][j]); printf(\"\\n\"); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"贪心","slug":"贪心","permalink":"https://lzylzy.cf/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"CF898D Alarm Clock","date":"2020-10-01T03:28:21.000Z","path":"posts/2513c9a5.html","text":"每天晚上Vitalya会设置 n 个闹钟以便明早醒来。每个闹钟都会正好响一分钟，并正好在那一分钟的开始响起，结束停止。给定ai来表示第i个闹钟响起的时间。如果在连续的 m 分钟内有至少 k 个闹钟响起，Vitalya就会醒来。注意Vitalya只会考虑在那一段时间中开始响起的闹钟，即不考虑在之前已经响起而未停止响的闹钟。 Vitalya十分疲劳，他想睡整整一天而不起床。您的任务是计算出需要关掉的闹钟总数的最小值。开始时所有闹钟都是打开状态。 输入输出格式 输入格式 第一行包含三个整数 n , m , k (1&lt;=k&lt;=n&lt;=2e5, 1&lt;=m&lt;=1e6)，分别表示闹钟总个数个数和Vitalya醒来的条件中连续时间段的长度和闹钟响起的个数。 第二行包含n个整数a1,a2,…an(1&lt;=ai&lt;=1e6)，分别表示第i个闹钟响起的时间（单位：分钟）。注意ai为乱序。Vitalya的国度一天有1e6分钟。 输出格式 输出最少需要关闭的闹钟个数。 一道贪心题目 由于不能 在连续m分钟内响起k个闹钟 ，所以先把闹钟时间排序 接着看看有没有k个闹钟连续m分钟内出现 如果有出现，我们关掉最后一个闹钟 这样是最优策略 因为既可以让前面k-1个闹钟不会吵醒人，而又能最大限度限制后面连续闹钟的出现 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n,m,k; #define maxn 200009 int a[maxn]; signed main() { scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;a[i]); sort(a+1,a+1+n); queue&lt;int&gt; q; int s=0; q.push(a[1]); if(k==1) { cout&lt;&lt;n&lt;&lt;endl; return 0; } for(int i=2;i&lt;=n;i++) { if(a[i]&gt;1000000)break; if(!q.empty())while(!q.empty()&amp;&amp;a[i]-q.front()&gt;=m)q.pop(); if(!q.empty()&amp;&amp; q.size()==k-1) { s++; continue; } q.push(a[i]); } printf(\"%d\\n\",s); return 0; } ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"贪心","slug":"贪心","permalink":"https://lzylzy.cf/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"电磁感应加热在供暖中的应用","date":"2020-10-01T03:26:25.000Z","path":"posts/d12f746c.html","text":"电磁感应加热器（Electromagnetic induction heater）:基于电磁感应加热原理制造出的加热控制器。 电磁感应加热来源于法拉第发现的电磁感应现象，即交变的磁场在导体中产生感应电流，从而导致导体发热。自从发现电流通过导线发生热效应后，世界上便出现了很多从事研究制造电热器的发明家。1890年，瑞典技术人员发明了第一台感应熔炼炉——开槽式有芯炉；1893年，美国出现了电熨斗雏形；1909年，电灶的出现实现了从电能转化为热能的过程；1916年，美国人发明了闭槽有芯炉，电磁感应技术逐渐进入实用化阶段。 加热原理 电磁感应加热的原理是感应加热电源产生的交变电流通过感应器（即线圈）产生交变磁场，导磁性物体置于其中切割交变磁力线，从而在物体内部产生交变的电流（即涡流），涡流使物体内部的原子高速无规则运动，原子互相碰撞、摩擦而产生热能，从而起到加热物品的效果。即是通过把电能转化为磁能，使被加热钢体感应到磁能而发热的一种加热方式。这种方式它从根本上解决了电热片，电热圈等电阻式通过热传导方式加热的效率低下问题。磁电旋热能机组是采用磁场感应电流(又称为涡旋电流)的加热原理；交流工频供电通过控制器产生交变磁场，切割磁力线而在换热器金属部分产生的交变电流(即涡旋电流)，涡旋电流使换热器铁分子高速无规则运动，分子互相碰撞、摩擦而产生热能，如使用石墨钢锅加热温度可以达到1000度以上；特点是加热温度高，换热面积大，转换基本没有流失。 节电原理 传统的加热行业，普遍采用是的电阻丝和石英加热方式，而这种传统的加热方式，其热效率比较低，电阻丝和石英主要是靠通电后，自身发热然后再把热量传递到料筒上，从而起到加热物品的效果，这种加热效果的热量利用率最高只有50%左右，另外的50%左右的热量都散发到空气中，所有传统的电阻丝加热方式的电能损失高达50%以上。而通过电磁感应加热，是通过电流产生磁场，使得铁质金属管道自身发热，再加上隔热材质，防止管道热量的散发，热利用率高达95%以上，理论上间节电效果可达到50%以上，但考虑到不同质量的电磁感应加热控制器的能量转换效率是不太相同的，以及不同的生产设备和环境，所有电磁加热节能的效果一般至少能够达到30%，最高能够达到70%。 技术优势 1.高效节能、快速加热采用内热加热方式，即通过电磁感应使料筒内部金属管自身发热，平均预热时间比电阻圈加热方式缩短2/3，同时热效率高达98% 以上，节电效果可达30%-70%。 2．降低生产成本、提高产品质量加热部分采用特种电缆结构，本身不会产生热量，可承受500℃以上的温度，使用寿命可达5年以上，后期基本无维护费用。因电磁加热是通过电磁感应使料筒自动发热，热利用率高达98% 以上，能够充分、均匀的给原料加热，从而提高产品质量。 3．运行可靠、可控可调主机采用最先进的工业用机板，微电子控制，多路智能闭环系统和完善的保护功能，有效避免了主机老化现象，可充分保证设备长期安全、稳定地运行。 4．改善工作环境设备表面常温，人体可触摸，大大改善了生产现场的工作环境，有力提高工人生产积极性，减少了传统的降温设施费用。本着“以人为本”的理念，创造更加绿色、节能、安全、舒适的生产环境。 5.电磁加热机组由于磁力线作用控制水中的Ca(HCO3)2（碳酸氢钙）受热分解析出的CaCO3（方解石）为针状文石结晶，它可在水中任意形成核结晶，不会在受热的金属表面上形成坚硬的水垢。解决了供暖上最难克服的问题。因为不需要软化水，所以不会对水源产生污染。 由于磁化水是小分子团，能够进入到已经胶结的水垢层当中去，所以一段时间后磁化水能将原有胶结的水 垢分解，达到清理水垢的目。 6.水电彻底分离。采用电磁感应加热技术，非接触式加热，水电分离，100%解决安全问题。 7.软启软关。主控电路部分通过软启动软关断技术，解决了开关机瞬间电流过大对设备可 能造成的损坏。 8.使用寿命长。磁电旋热能机组所用的大功率模块（IGBT）和控制板均产自德国英飞凌，工作时间达到7万小时，并且该机组产热过程不需要机械做工，因此不会产生机械磨损，所以热效率不会降低，在供暖上均可用40年。 是否有害 电磁加热感应节能设备就加热一直受到是否辐射危害人体健康的疑问。电磁感应加热采用磁场感应电流(又称为涡流)的加热原理，它是通过电子线路板组成部分产生交变磁场、当线圈绕在含铁质料筒表面时，料筒即切割交变磁力线而在料筒表面金属部分产生交变的电流(即涡流)，涡流使料筒铁分子高速无规则运动，分子互相碰撞、摩擦而产生热能，使用时会产生一定的辐射。那么，什么频率范围的电磁波对人有害呢? 单位换算：1MHz=1000KHZ=1000 000Hz ， 电磁加热机芯频率为：20~40KHz IEEE(国际电子电机工程协会)所定对的范围： 1磁场从0.1MHz左右到300MHz左右的频率范围内，所产生的磁场，其磁场强度超过3毫高斯，即对人体有害，90MHz 至300MHz的磁场伤害最大，而愈向上愈接近0.1MHz的磁场 伤害愈小，到0.1MHz以下磁场的伤害问题，就更加微不足道了。当然在有害范围其强度在3毫高斯以下，一般而言被视为安全范围。 2、电场从1.4MHz左右~300MHz的频率范围内所产生的电场，其电场强度超过1mv/m，即对人体有害，强度愈强伤害愈大，而若强度一样，则27MHz左右至300MHz的电场伤害最大，到1.4MHz以下电场的伤害问题，也一样微不足道。又电场与磁场单独存在时，不会像电磁波有向外放射行进的现像，只在其强度范围内有摇摆的波动而已。电 3、电磁波则90MHz到300MHz的电磁波伤害最大，300MHz以上愈靠近12000MHz，其伤害程度愈小，故由此得知，大哥大之频率900MH及1800MHz，皆在有害范围内。至于工业加热电磁机芯，频率为20~40KHz，属于正常音频信号(20~40kHz范围)，对人体无损。所以请广大用户放心使用电磁加热器。 应用范围 学校供暖，泳池加热，生活热水，宿舍供暖，住宅供暖，酒店供暖，会所供暖，商场供暖，健身房洗浴。 电磁蒸汽机组在工业上的应用 技术原理 磁电旋热能机组是采用磁场感应电流(又称为涡旋电流)的加热原理；交流工频供电通过控制器产生交变磁场，切割磁力线而在换热器金属部分产生的交变电流(即涡旋电流)，涡旋电流使换热器铁分子高速无规则运动，分子互相碰撞、摩擦而产生热能，如使用石墨钢锅加热温度可以达到1000度以上；特点是加热温度高，换热面积大，转换基本没有流失。 技术优势 蒸汽发生器：热媒水小于30升，炉体内部直径小于150mm，无需在锅检所及安检部门办理锅炉登记注册及以后的年检手续 安装快捷：可进行分布式安装，安装于用热设备旁边，不受安装环境的限制，有水有电即可，减少系统及管输热损。 升温快：基本做到即开即用，无需提前预热。 高效节能：根据实验，对比电阻式蒸汽锅炉，节能40-80% 绿色环保：无废水，废渣，废气排放。 蒸汽品质高：产生过饱和蒸汽,每立方米含水量小于饱和蒸汽标准值。 使用寿命长：无机械作功，设备热效率持续稳定。 智能控制：实现无人值守，温升、压力、排污均为自动控制，可达到补水不掉压，恒压输出；采用7英寸触摸屏，实现多点保护，保证机组正常运行。 水电分离：采用感应加热方式，电感线圈通过射频对炉体进行加热，水电彻底分离，无安全隐患。 软启软关：开机定频器无极调整，电流从零至额定功率缓慢上升， 无冲击电流，并且电容充电编程启动，对电网无冲击。 磁隔离驱动技术，解决了光藕驱动产生的干扰问题。 采用高速DSP移相算法，每个输出周期经过精密计算，达到最优节能目的。 系统控制采用多级EMI抑制，保证在恶劣电源条件下提供最优质的电源。 与燃气锅炉对比 对比项目 燃气蒸汽锅炉 磁电旋蒸汽机组 接口费用 有 无 燃料储存场地 有 无 锅炉登记注册 有 无 锅炉年检费用 有 无 消防检查 有 无 司炉工 有 无 污染排放 废气排放 无任何排放 安全性 有明火燃烧 无明火燃烧 分布式安装 不可以 可以 安装距离 距离车间100米 车间内就近安装 热效率 95%，逐年降低 97.7%，热效率稳定 能源品质 达不到理论值 电 标准恒定 蒸汽入力含水量 较高 极低 系统损耗 较高 极低 维护成本 较高 极低 运行成本（燃料） 价格随行就市 价格稳定，逐年降低 对比项目 燃煤(气)蒸汽锅炉 磁电旋蒸汽机组 排烟热损失 有 无 化学燃烧热损失 有 无 机械燃烧热损失 有 无 炉体散热损失 高 低 灰渣物理热损失 无 无 系统热损失 有 无 管输热损失 有 无 与传统锅炉热效率对比 工业应用中“饱和蒸汽”品质及热损分析 **饱和蒸汽定义：**当液体在密闭空间中蒸发时，液体分子通过液面进入上面空间，成为蒸气分子，由于蒸气分子处于紊乱的热运动之中，它们相互碰撞，和容器壁及液面发生碰撞，在和液面碰撞时，有的分子则被液体分子所吸引，而重新返回液体中成为液体分子，开始蒸发时，进入空间的分子数目多于返回液体中分子的数目，随着蒸发继续进行，空间蒸气分子的密度不断增大，因而返回液体中的分子数目也增多，当单位时间内进入空间的分子数目与返回液体中的分子数目相等时，则蒸发与凝结处于动平衡状态，这时虽然蒸发和凝结仍在进行，但空间中的蒸气分子的密度不再增加，此时的状态称为“饱和状态”。在饱和状态下的液体称为饱和液体，其对应的蒸汽是“饱和蒸汽”。 管输过程中蒸汽热损失： 保温管道散热损失。查表得知在最佳的保温状态下，保温管道（DN50,1Mpa）每100米散热量为3990Kcal/h，按蒸汽经济流速计算，占比约为5%。（如：达不到标准流速，及管道保温达不到理论数值，热损失将按比例加大。） 系统散热损失。10条生产线开4条，其余6条线的蒸汽管道持续处于高热蒸汽状态，热量损失大。 蒸汽流量损失。10条生产线开4条，流量由原来的5T/h降至2T/h。蒸汽主管道散热面积不变，散热量不变，管道散热损失由原来的5%增至12.5%。 疏水阀安装不符合要求。在蒸汽主管道上尤其是在地沟地段，每隔20米左右需正确按装一个疏水阀，增大排水量，提高蒸汽品质。 冷凝水不回收，排至室外。热量损失约15%。 蒸汽在管输中热焓值分析 吨饱和蒸汽在锅炉出力口热焓值为60万大卡，蒸汽分子含量约96%。每公斤水经相变吸收大约在液相下5倍的热量，在蒸汽传输过程中，由于管输散热和系统热损，以及流量热损，使蒸汽分子所含热量损失，损失热量的蒸汽分子相变为水分子（温度相同的过热水），而水分子所含热量为显热，在用热设备入力口处由于含水量的变化，其蒸汽的热焓值会大大降低，如果要准确测量设备实际用热量，需用热计量表。我们在通常使用热量时，通过蒸汽流量计及温度计来计算是不准确的，所以用热设备最终所使用的蒸汽是否每吨含热量为60万大卡就未知可否了。 ​ 4.电磁蒸汽机组优势 电磁蒸汽机组可分布式安装，安装于车间用热设备附近，无以上热损失，所以在实际改造中，经常能用小机组替换现有的大锅炉。例如在橡胶内胎企业，用240KW机组(0.33吨)替换原有的4吨锅炉；在保温材料厂用400KW机组(0.6吨)替换原有2吨锅炉。为客户节约生产成本，响应国家节能减排政策。 技术支持：15898802298@126.COM document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"电磁","slug":"电磁","permalink":"https://lzylzy.cf/tags/%E7%94%B5%E7%A3%81/"},{"name":"供暖","slug":"供暖","permalink":"https://lzylzy.cf/tags/%E4%BE%9B%E6%9A%96/"}]},{"title":"【LGR-076】洛谷 ⑨ 月月赛 I & Cnoi2020游记+T1T2题解","date":"2020-09-19T08:01:33.000Z","path":"posts/39cc6e8.html","text":"传送门 蒟蒻目前是提高省二菜鸡选手 趁着NOIP前两个月练练手 QwQ 总体感觉人还是很菜 T1T2写完一共花费1.5h左右，T3T4看了就走人 T1 [Cnoi2020]子弦 Cirno 有一个字符串 S，并希望你能求出 S 出现次数最多的非空子串的出现次数 观察一分钟发现 子串的长度越长，受到的限制就越多，出现的次数肯定越少 而长度最短的子串出现的次数肯定最多 长度最短为1，因而题目转化为求给定字符串里出现次数最多的字母的出现次数 用时：2min 提交：2 T2 [Cnoi2020]雷雨 幻想乡的纵切面可以抽象成一个 n×mn\\times mn×m 的矩形。 其中每一个 1×11 \\times 11×1的单元格$ (i,j) $都有一个 电阻计量值(虚构的概念) Ri,jR_{i,j}Ri,j​。 闪电从雷雨云上的 O(n,a)O(n,a)\\texttt{O}(n,a)O(n,a)O(n,a)O(n,a) 发出，击中了地面上的 红魔馆 $ \\texttt{A}(1,b)A(1,b) 与迷途竹林与 迷途竹林与迷途竹林 \\texttt{B}(1,c)$。 雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 O 到 A 与 B 的两条路径的并集的电阻计量值的和最小。 所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。 $ 0&lt;n,m≤1000,0≤R**i,j≤109,0&lt;a,b,c≤m $ 题目大意是给出一个网格图，每个格子都有权值 从第一行的一个点向最后一行的两个点走最短路径 特殊的是两条路径重复的地方只计算一次权值 容易想到的思路是枚举一个分开的点，先从出发点走到这里，再从这里分开各自走到终点 于是只要三次Dijkstra就可以实现这个做法 记得开long long 另外128的空间用得不能太浪费 比赛大部分时间都卡在空间上。。。 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf=100000000000000000; typedef long long ll; #define maxn 1001 int a,b,c,n,m; int r[maxn][maxn]; ll d[maxn*maxn],d1[maxn*maxn],d2[maxn*maxn]; #define pos(x,y) ((x-1)*m+y) int S; int gox[4]={0,-1,0,1}; int goy[4]={1,0,-1,0}; bool vis[maxn*maxn]; struct node{ int x,y; ll dis; bool operator &lt;(const node &amp;a)const{ return dis&gt;a.dis; } }; priority_queue&lt;node&gt; q; void dijkstra(ll d[],int sx,int sy) { memset(vis,0,sizeof(vis)); q.push((node){sx,sy,d[S]}); while(!q.empty()) { int nowx=q.top().x; int nowy=q.top().y; q.pop(); int now=pos(nowx,nowy); if(vis[now])continue; vis[now]=1; for(int i=0;i&lt;4;i++) { int tox=nowx+gox[i]; int toy=nowy+goy[i]; int to=pos(tox,toy); if(tox&lt;=0||toy&lt;=0||tox&gt;n||toy&gt;m)continue; if(d[to]&gt;d[now]+r[tox][toy]) { d[to]=d[now]+r[tox][toy]; q.push((node){tox,toy,d[to]}); } } } } signed main() { scanf(\"%d%d%d%d%d\",&amp;n,&amp;m,&amp;a,&amp;b,&amp;c); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { scanf(\"%d\",&amp;r[i][j]); } } S=pos(n,b); memset(d,0x3f,sizeof(d)); d[S]=r[n][b]; dijkstra(d,n,b); S=pos(n,c); memset(d1,0x3f,sizeof(d1)); d1[S]=r[n][c]; dijkstra(d1,n,c); S=pos(1,a); memset(d2,0x3f,sizeof(d2)); d2[S]=r[1][a]; dijkstra(d2,1,a); ll ans=inf; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { int x=pos(i,j); ans=min(ans,d[x]+d1[x]+d2[x]-2*r[i][j]); } } printf(\"%lld\\n\",ans); return 0; } /* 网格图上有三个点 从最上面的A出发到下面的B,C 这两条路的交集可以只计算一次长度 求最短路 倒着两边dij 把点权转化成边权 X-&gt;Y路径的边权是Y点的权值 初始值不是0 */ 耗时：1.5h 提交：10 T3T4一打眼就不会所以放弃~ 如果有时间会把赛后题解搬过来的uhhh document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"NOIP/CSP c++常用模板","date":"2020-09-13T08:33:25.000Z","path":"posts/f974946.html","text":"蒟蒻目前还是提高组选手，模板将会持续更新！目录： 线段树 对拍 exgcd st 树状数组 树剖 dijsktra spfa tarjan 匈牙利 埃筛 差分树状数组 dinic 快速幂取余 Exgcd #include&lt;bits/stdc++.h&gt; using namespace std; int exgcd(int a,int b,int &amp;x,int &amp;y) { if(b==0) { x=1; y=0; return a; } int r=exgcd(b,a%b,x,y); int t = x; x=y; y=t-a/b*y; return r; } int main() { int a,b; cin&gt;&gt;a&gt;&gt;b; int x,y; int p=exgcd(a,b,x,y); cout&lt;&lt;(x+b)%b&lt;&lt;endl; return 0; } 对拍 @echo off :loop 数据生成器.exe 快速排序.exe 优先队列.exe fc 快速排序.out 优先队列.out if not errorlevel 1 goto loop pause 线段树 #include &lt;stdio.h&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define maxn 100010 using namespace std; struct point{ int l,r; long long val,mark; }tr[maxn*4]; int m,n; int a[maxn]; void buildtree(int x,int l,int r) { tr[x].l=l; tr[x].r=r; if(l==r) { tr[x].val=a[l]; return; } int lch=x*2,rch=x*2+1; int mid=(l+r)/2; buildtree(lch, l, mid); buildtree(rch, mid+1, r); tr[x].val=tr[x*2].val+tr[x*2+1].val; } void release(int x) { if(tr[x].mark &amp;&amp; tr[x].l&lt;tr[x].r) { int lch=x*2,rch=x*2+1; tr[lch].val+=tr[x].mark*((long long)tr[lch].r-tr[lch].l+1); tr[lch].mark+=tr[x].mark; tr[rch].val+=tr[x].mark*((long long)tr[rch].r-tr[rch].l+1); tr[rch].mark+=tr[x].mark; } tr[x].mark=0; } void modify(int x,int l,int r,long long k) { release(x); if(l&lt;=tr[x].l &amp;&amp; tr[x].r&lt;=r) { tr[x].val+=k*((long long)tr[x].r-tr[x].l+1); tr[x].mark+=k; return; } int mid=(tr[x].l+tr[x].r)/2; if(l&lt;=mid) modify(x*2, l, r, k); if(mid&lt;r) modify(x*2+1, l, r, k); tr[x].val=tr[x*2].val+tr[x*2+1].val; } long long query(int x,int l,int r) { release(x); if(l&lt;=tr[x].l &amp;&amp; tr[x].r&lt;=r) return tr[x].val; int mid=(tr[x].l+tr[x].r)/2; long long ans=0; if(l&lt;=mid) ans+=query(x*2, l, r); if(r&gt;mid) ans+=query(x*2+1, l, r); return ans; } int main() { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); buildtree(1, 1, n); for(int i=1;i&lt;=m;i++) { int op; scanf(\"%d\",&amp;op); if(op==1) { int x,y; long long k; scanf(\"%d%d%lld\",&amp;x,&amp;y,&amp;k); modify(1, x, y, k); } else { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%lld\\n\",query(1, x, y)); } } } 树剖 #include&lt;bits/stdc++.h&gt; #define inf 0x7fffffff #define ll long long using namespace std; #define maxn 600009 int dfn[maxn],cnt,pos[maxn],son[maxn],en[maxn],top[maxn],size[maxn],fa[maxn],deep[maxn]; vector&lt;int&gt; v[maxn]; struct node{ int l,r; int val,mark; }tr[maxn*4]; int n,m,r,mod; int a[maxn]; void dfs(int rt) { size[rt]=1; for(int i=0;i&lt;v[rt].size();i++) { int to=v[rt][i]; if(!size[to]) { fa[to]=rt; deep[to]=deep[rt]+1; dfs(to); size[rt]+=size[to]; if(size[to]&gt;size[son[rt]])son[rt]=to; } } } void dfs(int x,int tp) { top[x]=tp; cnt++; pos[x]=cnt; dfn[cnt]=x; if(son[x]!=0)dfs(son[x],tp); for(int i=0;i&lt;v[x].size();i++) { int to=v[x][i]; if(!top[to])dfs(to,to); } en[x]=cnt; } void Build(int x,int l,int r) { tr[x].l=l,tr[x].r=r; if(l==r) { tr[x].mark=0; tr[x].val=a[dfn[l]]; return; } int mid=(l+r)&gt;&gt;1; Build(x*2,l,mid); Build(x*2+1,mid+1,r); tr[x].mark=0; tr[x].val=tr[x*2].val+tr[x*2+1].val; tr[x].val%=mod; } void relese(int x) { if(tr[x].mark==0||tr[x].l==tr[x].r)return; tr[x*2].val+=(tr[x*2].r-tr[x*2].l+1)*tr[x].mark; tr[x*2].mark+=tr[x].mark; tr[x*2+1].val+=(tr[x*2+1].r-tr[x*2+1].l+1)*tr[x].mark; tr[x*2+1].mark+=tr[x].mark; tr[x*2].val%=mod; tr[x*2].mark%=mod; tr[x*2+1].mark%=mod; tr[x*2+1].val%=mod; tr[x].mark=0; } void Add(int x,int l,int r,int val) { if(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r) { tr[x].val+=(tr[x].r-tr[x].l+1)*val; tr[x].val%=mod; tr[x].mark+=val; tr[x].mark%=mod; return; } //cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;l&lt;&lt;\" \"&lt;&lt;r&lt;&lt;endl; relese(x); int mid=(tr[x].l+tr[x].r)&gt;&gt;1; if(l&lt;=mid)Add(x*2,l,r,val); if(r&gt;mid)Add(x*2+1,l,r,val); tr[x].val=tr[x*2].val+tr[x*2+1].val; tr[x].val%=mod; } int Sum(int x,int l,int r) { if(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r) { return tr[x].val; } relese(x); int mid=(tr[x].l+tr[x].r)&gt;&gt;1; int ans=0; if(l&lt;=mid) ans+=Sum(x*2,l,r); if(r&gt;mid) ans+=Sum(x*2+1,l,r); ans%=mod; return ans; } void LCA_add(int x,int y,int val) { while(top[x]!=top[y]) { if(deep[top[x]]&lt;deep[top[y]])swap(x,y); Add(1,pos[top[x]],pos[x],val); x=fa[top[x]]; } //if(x!=y) //{ if(pos[x]&gt;pos[y])swap(x,y); Add(1,pos[x],pos[y],val); // } } int LCA_sum(int x,int y) { int res=0; while(top[x]!=top[y]) { if(deep[top[x]]&lt;deep[top[y]])swap(x,y); res+=Sum(1,pos[top[x]],pos[x]); res%=mod; x=fa[top[x]]; } if(pos[x]&gt;pos[y])swap(x,y); res+=Sum(1,pos[x],pos[y]); return res%mod; } signed main() { scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;r,&amp;mod); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); } for(int i=1;i&lt;n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); v[x].push_back(y); v[y].push_back(x); } dfs(r); dfs(r,r); Build(1,1,n); while(m--) { int opt; scanf(\"%d\",&amp;opt); if(opt==1) { int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); LCA_add(x,y,z); }else if(opt==2) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%d\\n\",LCA_sum(x,y)); }else if(opt==3) { int x,z; scanf(\"%d%d\",&amp;x,&amp;z); Add(1,pos[x],en[x],z); }else { int x; scanf(\"%d\",&amp;x); printf(\"%d\\n\",Sum(1,pos[x],en[x])); } // for(int i=1;i&lt;=n;i++) // { // printf(\"%d: %d\\n\",i,Sum(1,pos[i],pos[i])); // } } return 0; } 树状数组 #include&lt;bits/stdc++.h&gt; using namespace std; #define lowbit(x) x&amp;-x int n,m; const int maxn=500005; int c[maxn]; int a[maxn]; void Add(int x,int s) { while(x&lt;=n) { c[x]+=s; x+=lowbit(x); } } int Get(int x) { int ans=0; while(x) { ans+=c[x]; x-=lowbit(x); } return ans; } int main() { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); Add(i,a[i]); } while(m--) { int o,x,k; scanf(\"%d%d%d\",&amp;o,&amp;x,&amp;k); if(o==1) { Add(x,k); }else { printf(\"%d\\n\",Get(k)-Get(x-1)); } } return 0; } St表 #include&lt;bits/stdc++.h&gt; #define ll long long #define inf 0x7fffffff using namespace std; int n,m; #define maxn 100008 int d[maxn][99]; int a[maxn]; int main() { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); } for(int i=1;i&lt;=n;i++)d[i][0]=a[i]; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) { for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) { d[i][j]=max(d[i][j-1],d[i+(1&lt;&lt;(j-1))][j-1]); } } for(int i=1;i&lt;=m;i++) { int k=0; int l,r; scanf(\"%d%d\",&amp;l,&amp;r); while(1&lt;&lt;(k+1)&lt;=(r-l+1))k++; printf(\"%d\\n\",max(d[l][k],d[r-(1&lt;&lt;k)+1][k])); } return 0; } Dijkstra #include&lt;bits/stdc++.h&gt; #define inf 0x7fffffff #define ll long long #define maxn 500005 using namespace std; struct node{ int x,dis; bool operator &lt; (const node &amp;a)const { return dis&gt;a.dis; } }; int n,m; vector&lt;int&gt; son[maxn],v[maxn]; void Set(int prt,int to,int d) { son[prt].push_back(to); v[prt].push_back(d); } #define to son[rt.x][i] int dis[maxn],tim=0; bool vis[maxn]; priority_queue&lt;node&gt; q; void dijkstra(int s) { for(int i=1;i&lt;=n;i++) { dis[i]=inf; } memset(vis,0,sizeof(vis)); q.push((node){s,0}); dis[s]=0; while(!q.empty()) { node rt=q.top(); q.pop(); if(vis[rt.x]) { continue; } vis[rt.x]=1; for(int i=0;i&lt;son[rt.x].size();i++) { if(dis[to]&gt;dis[rt.x]+v[rt.x][i]) { dis[to]=dis[rt.x]+v[rt.x][i]; q.push((node){to,dis[to]}); } } } } int main() { int s; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=m;i++) { int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); Set(x,y,z); } dijkstra(s); for(int i=1;i&lt;=n;i++) { printf(\"%d \",dis[i]); } return 0; } Spfa #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff #define maxn 10009 int n,m,s; vector&lt;int&gt; son[maxn],v[maxn]; void Add(int x,int y,int val) { son[x].push_back(y); v[x].push_back(val); } struct node{ int x; int dis; }; int dis[maxn]; void spfa(int s) { for(int i=1;i&lt;=n;i++)dis[i]=inf; queue&lt;node&gt; q; q.push((node){s,0}); dis[s]=0; while(!q.empty()) { node now=q.front(); q.pop(); for(int i=0;i&lt;son[now.x].size();i++) { int to=son[now.x][i]; if(dis[to]&gt;dis[now.x]+v[now.x][i]) { dis[to]=dis[now.x]+v[now.x][i]; q.push((node){to,dis[to]}); } } } } signed main() { scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=m;i++) { int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); Add(x,y,z); } spfa(s); for(int i=1;i&lt;=n;i++) { printf(\"%d \",dis[i]); } return 0; } Tarjan int n,m; #define maxn 10009 vector&lt;int&gt; son[maxn]; int tim,size[maxn],belong[maxn],scc_cnt,cnt; bool bein[maxn]; int st[maxn]; int dfn[maxn],low[maxn]; void Tarjan(int rt) { dfn[rt]=low[rt]=++tim; st[++cnt]=rt; for(int i=0;i&lt;son[rt].size();i++) { int to=son[rt][i]; if(!dfn[to])//正向边 { Tarjan(to); low[rt]=min(low[rt],low[to]); }else if(!belong[to])//反向边 { low[rt]=min(low[rt],dfn[to]);//能不能取到一个更早的点 } } if(dfn[rt]==low[rt]) { //关键节点！！ scc_cnt++; int k; do{ k=st[cnt--]; belong[k]=scc_cnt; size[scc_cnt]++; }while(k!=rt); } } 二分图匹配 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff int n,m,e; #define maxn 3009 vector&lt;int&gt; son[maxn]; int hav[maxn]; int vis[maxn]; int timemark=0; bool dfs(int x) { for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; if(vis[to]==timemark)continue; vis[to]=timemark; if(!hav[to]||dfs(hav[to])) { hav[to]=x; return 1; } } return 0; } signed main() { scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;e); while(e--) { int u,v; scanf(\"%d%d\",&amp;u,&amp;v); if(v&gt;m||u&gt;n)continue; v+=1009;//!!! son[u].push_back(v); son[v].push_back(u); } int s=n; for(int i=1;i&lt;=n;i++) { timemark++; if(!dfs(i))s--; } printf(\"%d\\n\",s); return 0; } 线性素数筛 #include&lt;bits/stdc++.h&gt; #define inf 0x7fffffff #define ll long long using namespace std; bool p[10000000]; signed main() { int n,m; memset(p,1,sizeof(p)); p[1]=0; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=2;i&lt;=sqrt(10000000);i++) { if(p[i]) { for(int j=i*2;j&lt;=10000000;j+=i)p[j]=0; } } for(int i=1;i&lt;=m;i++) { int x; scanf(\"%d\",&amp;x); if(p[x])printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0; } 差分树状数组 #include&lt;bits/stdc++.h&gt; using namespace std; #define lowbit(x) x&amp;-x int n,m; const int maxn=500005; int c[maxn]; int a[maxn]; void Add(int x,int s) { while(x&lt;=n) { c[x]+=s; x+=lowbit(x); } } int Get(int x) { int ans=0; while(x) { ans+=c[x]; x-=lowbit(x); } return ans; } int main() { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); Add(i,a[i]); Add(i+1,-a[i]); } while(m--) { int o; scanf(\"%d\",&amp;o); if(o==1) { int x,y,k; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;k); Add(x,k); Add(y+1,-k); }else { int k; scanf(\"%d\",&amp;k); printf(\"%d\\n\",Get(k)); } } return 0; } dinic #include&lt;bits/stdc++.h&gt; #define inf 0x7fffffff #define ll long long using namespace std; #define maxn 10009 #define maxm 100009 struct node{ int val,to; int rev;//rev表示反边在to的vector当中下标是几 node(int _to,int _val,int _rev) { to=_to; val=_val; rev=_rev; } }; vector&lt;node&gt; son[maxn]; int d[maxn]; int n,m,s,t; void add(int x,int y,int w) { son[x].push_back(node(y,w,son[y].size())); son[y].push_back(node(x,0,son[x].size()-1)); } int ans=0; bool bfs() { memset(d,-1,sizeof(d)); queue&lt;int&gt; q; q.push(s); d[s]=0; while(!q.empty()) { int x=q.front(); q.pop(); for(int i=0;i&lt;son[x].size();i++) { int y=son[x][i].to; if(d[y]==-1 &amp;&amp; son[x][i].val) { q.push(y); d[y]=d[x]+1; } } } if(d[t]==-1)return 0; return 1; } int dfs(int x,int low)//x 表示当前节点，low表示当前到x的最小参量 { if(x==t||low==0) return low; int s=0; for(int i=0;i&lt;son[x].size();i++) { int y=son[x][i].to; int rev=son[x][i].rev; if(d[y]==d[x]+1&amp;&amp;son[x][i].val&gt;0) { int a=dfs(y,min(low,son[x][i].val));//当前 son[x][i].val-=a; son[y][rev].val+=a; low-=a; s+=a; if(low==0) return s; } } if(low!=0)//流到x的流量会有冗余，在这一轮dfs之后就在不会到x了 { d[x]=-1; } return s; } void dinic() { while(bfs()) { ans+=dfs(s,inf); } } int main() { scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;s,&amp;t); for(int i=1;i&lt;=m;i++) { int x,y,z; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); add(x,y,z); } //dinic dinic(); printf(\"%d\\n\",ans); return 0; } 快速幂取余 #include&lt;bits/stdc++.h&gt; #define ll long long ll d,p,k; ll cal(ll x,ll y) { ll ans=1; for(;y;x=x*x%k,y&gt;&gt;=1) if(y&amp;1)ans=ans*x%k; return ans; } using namespace std; int main() { cin&gt;&gt;d&gt;&gt;p&gt;&gt;k; cout&lt;&lt;d&lt;&lt;\"^\"&lt;&lt;p&lt;&lt;\" mod \"&lt;&lt;k&lt;&lt;\"=\"&lt;&lt;cal(d,p)%k&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P2476 [SCOI2008]着色方案","date":"2020-09-13T08:30:39.000Z","path":"posts/9189b2df.html","text":"本题为dp题，但状态设计奇特 类似题目：P1541乌龟棋 发现k,c[i]均特别小，可以从这里入手设计状态 显然，c[i]相同的状态可以忽略，只要在转移中乘上常数即可，而C[i]的范围只有5 可以$ f[a][b][c][d][e][f] $ 表示剩下一个（能给一个格子上色的）颜色有a种，以此类推 f[e]表示剩下五个的颜色，而f[f]表示上次使用了哪种颜色 在转移过程中，我们需要乘上使用的这种颜色的颜色数量 但是注意如果这种颜色上次使用了，乘的时候数量要-1 由于超级复杂，于是使用记忆化搜索实现 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; ll f[16][16][16][16][16][7]; //剩下1个的颜色有a种 剩下2个的颜色有b种 int n; int s[6]; const int mod = 1000000007; ll dfs(int a,int b,int c,int d,int e,int last) { if(f[a][b][c][d][e][last]!=-1)return f[a][b][c][d][e][last]; if(a+b+c+d+e==0)return 1; ll ans=0; if(a) ans=(ans+((a-(last==2))*dfs(a-1,b,c,d,e,1)))%mod; if(b) ans=(ans+((b-(last==3))*dfs(a+1,b-1,c,d,e,2)))%mod; if(c) ans=(ans+((c-(last==4))*dfs(a,b+1,c-1,d,e,3)))%mod; if(d) ans=(ans+((d-(last==5))*dfs(a,b,c+1,d-1,e,4)))%mod; if(e) ans=(ans+((e)*dfs(a,b,c,d+1,e-1,5)))%mod; return f[a][b][c][d][e][last]=ans; } signed main() { scanf(\"%d\",&amp;n); int z; for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;z); s[z]++; } memset(f,-1,sizeof(f)); printf(\"%lld\\n\",dfs(s[1],s[2],s[3],s[4],s[5],0)); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"dp","slug":"dp","permalink":"https://lzylzy.cf/tags/dp/"}]},{"title":"CF484B Maximum Value","date":"2020-09-06T12:09:14.000Z","path":"posts/f64fe18a.html","text":"又是最喜欢的暴力题 显然不能n^2枚举，所以复杂度要进行优化 考虑对于每一个数x，枚举他数据范围内的所有倍数 对于每一个倍数 n*x ，找出原数列中第一个小于它的数y（预处理或使用二分）并更新答案 显然这样做会使得y%x更大 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int n,m; int a[200009]; int f[5000009];//这个数字左边第一个数字是谁 signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); } sort(a+1,a+1+n); n=unique(a+1,a+1+n)-a-1; a[n+1]=inf; int t=1; for(int i=1;i&lt;=a[n]*2;i++) { if(i&gt;a[t]) { f[i]=a[t]; t++; } else f[i]=f[i-1]; } int ans=-inf; for(int i=1;i&lt;=n;i++) { int p=a[i]*2; while(p&lt;=a[n]+a[i]) { ans=max(ans,f[p]%a[i]); p+=a[i]; } } printf(\"%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"枚举","slug":"枚举","permalink":"https://lzylzy.cf/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"P2857 [USACO06FEB]Steady Cow Assignment G&&SP741 STEAD - Steady Cow Assignment","date":"2020-08-26T04:33:36.000Z","path":"posts/1c7359ca.html","text":"双指针法，一个头一个尾，表示所有的牛选择到的牛棚的座次都在这个区间里，答案就是（r-l+1） 验证所有的牛能不能都放开：牛向牛棚连权值为1的边，牛棚向汇点连权值为其容量的边 看看最大流是不是满流 如果是，返回1，区间长度-1，l+1 否则区间长度+1，r+1 双倍经验，双倍快乐 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 500009 struct node{ int to; int val; int rev; }; vector&lt;node&gt; e[maxn]; int S,T; int k,m,n; vector&lt;int&gt; sol[1009]; void add(int x,int y,int z) { e[x].push_back((node){y,z,e[y].size()}); e[y].push_back((node){x,0,e[x].size()-1}); } int d[maxn]; bool bfs() { memset(d,-1,sizeof(d)); queue&lt;int&gt; q; q.push(S); d[S]=0; while(!q.empty()) { int now=q.front(); q.pop(); for(int i=0;i&lt;e[now].size();i++) { int to=e[now][i].to; if(d[to]==-1&amp;&amp;e[now][i].val) { d[to]=d[now]+1; q.push(to); if(to==T)return 1; } } } return 0; } int dfs(int x,int low) { if(x==T||low==0)return low; int totflow=0; for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i].to; int val=e[x][i].val; int rev=e[x][i].rev; if(d[to]==d[x]+1&amp;&amp;val) { int a=dfs(to,min(low,val)); e[x][i].val-=a; e[to][rev].val+=a; totflow+=a; low-=a; if(low==0)return totflow; } } if(low)d[x]=-1; return totflow; } int b; int c[maxn]; int a[1009][30]; bool work(int x,int y) { for(int i=0;i&lt;n+b+4;i++)e[i].clear(); for(int i=1;i&lt;=n;i++) { add(S,i,1); for(int j=x;j&lt;=y;j++) { add(i,n+a[i][j],1); } } for(int i=1;i&lt;=b;i++)add(n+i,T,c[i]); int ans=0; while(bfs())ans+=dfs(S,inf); return ans==n; } signed main() { scanf(\"%d%d\",&amp;n,&amp;b); S=n+b+2,T=S+1; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=b;j++) { scanf(\"%d\",&amp;a[i][j]); } } for(int i=1;i&lt;=b;i++)scanf(\"%d\",&amp;c[i]); int j=1; int ans=inf; for(int i=1;i&lt;=b;i++) { while(!work(i,j)&amp;&amp;j&lt;=b) { j++; } if(work(i,j))//这里是防止j过了m跳出循环被错误记录 { ans=min(ans,j-i+1); } } printf(\"%d\\n\",ans); return 0; } //P2857 [USACO06FEB]Steady Cow Assignment G&amp;&amp;SP741 STEAD - Steady Cow Assignment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"网络流","slug":"网络流","permalink":"https://lzylzy.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"P2763 试题库问题","date":"2020-08-26T02:28:03.000Z","path":"posts/1fdb09b6.html","text":"这题有个坑点，每个题目只能对应一种类别，例如，对于要求1,2两种类型题目的试卷，不能只由一道包含1,2两种属性的题目组成，每道题目只能对应他属性中的一个 于是想到二分图，一边是试题，另一边是所属类别 从源点向题目链接流量为1的边，因为每个题目只能用一次 从类别向汇点链接流量为这个类别需要的题目数量的边，表示这个类别需要被选这么多次 跑最大流，判断如果不是满流就是无解 接下来准备输出方案，我们可以在残余的图上遍历每一个题目，看看他流向所属题目的出边哪一条流量为0，被选择了 这就证明这个题目连向了那个所属的类别，使用vector记录下来输出就可以了 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 500009 struct node{ int to; int val; int rev; }; vector&lt;node&gt; e[maxn]; int S,T; int k,m,n; vector&lt;int&gt; sol[1009]; void add(int x,int y,int z) { e[x].push_back((node){y,z,e[y].size()}); e[y].push_back((node){x,0,e[x].size()-1}); } int d[maxn]; bool bfs() { memset(d,-1,sizeof(d)); queue&lt;int&gt; q; q.push(S); d[S]=0; while(!q.empty()) { int now=q.front(); q.pop(); for(int i=0;i&lt;e[now].size();i++) { int to=e[now][i].to; if(d[to]==-1&amp;&amp;e[now][i].val) { d[to]=d[now]+1; q.push(to); if(to==T)return 1; } } } return 0; } int dfs(int x,int low) { if(x==T||low==0)return low; int totflow=0; for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i].to; int val=e[x][i].val; int rev=e[x][i].rev; if(d[to]==d[x]+1&amp;&amp;val) { int a=dfs(to,min(low,val)); e[x][i].val-=a; e[to][rev].val+=a; totflow+=a; low-=a; if(low==0)return totflow; } } if(low)d[x]=-1; return totflow; } signed main() { scanf(\"%d%d\",&amp;k,&amp;n); S=k+n+2,T=S+1; for(int i=1;i&lt;=k;i++) { int x; scanf(\"%d\",&amp;x); add(i+n,T,x); m+=x; } for(int i=1;i&lt;=n;i++) { int p; scanf(\"%d\",&amp;p); add(S,i,1); for(int j=1;j&lt;=p;j++) { int x; scanf(\"%d\",&amp;x); add(i,x+n,1); } } int ans=0; while(bfs())ans+=dfs(S,inf); if(ans!=m) { printf(\"No Solution!\\n\"); return 0; } for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;e[i].size();j++) { int to=e[i][j].to; if(!e[i][j].val&amp;&amp;to&gt;n&amp;&amp;to&lt;=n+k) { sol[to-n].push_back(i); break; } } } for(int i=1;i&lt;=k;i++) { printf(\"%d: \",i); for(int j=0;j&lt;sol[i].size();j++) { printf(\"%d \",sol[i][j]); } printf(\"\\n\"); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"网络流","slug":"网络流","permalink":"https://lzylzy.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"P4304 [TJOI2013]攻击装置 && P3355 骑士共存问题","date":"2020-08-25T04:39:28.000Z","path":"posts/10394e70.html","text":"通过图片发现，马只能从一个黄色点攻击到红色点 这就是一个二分图，把行列和为奇数的点连向源点，偶数连向汇点 互相能攻击到的格子记得连单向边 于是变成了一个二分图，求最大独立集=点数-最大匹配 关于不能放东西的点，可以当他不存在二分图中，直接跳过就完事 //P3355 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 400009 struct node{ int to; int val; int rev; }; vector&lt;node&gt; e[maxn]; int d[maxn]; int S,T; int n; void add(int x,int y,int z) { e[x].push_back((node){y,z,e[y].size()}); e[y].push_back((node){x,0,e[x].size()-1}); } bool bfs() { memset(d,-1,sizeof(d)); queue&lt;int&gt; q; q.push(S); d[S]=0; while(!q.empty()) { int now=q.front(); q.pop(); for(int i=0;i&lt;e[now].size();i++) { int to=e[now][i].to; if(d[to]==-1&amp;&amp;e[now][i].val) { q.push(to); d[to]=d[now]+1; } } } if(d[T]==-1)return 0; return 1; } int dfs(int x,int low) { if(x==T||low==0)return low; int totflow=0; for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i].to; int val=e[x][i].val; int rev=e[x][i].rev; if(val&amp;&amp;d[to]==d[x]+1) { int a=dfs(to,min(low,val)); e[x][i].val-=a; e[to][rev].val+=a; totflow+=a; low-=a; if(low==0)return totflow; } } if(low)d[x]=-1; return totflow; } int a[201][201]; int gox[8]={-1,-2,1,2,-1,-2,1,2}; int goy[8]={-2,-1,-2,-1,2,1,2,1}; #define pos(x,y) ((x-1)*n+y) char f[209]; signed main() { int m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); a[x][y]=1; } S=n*n+5,T=n*n+6; int sum=n*n; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(a[i][j]!=1) { if((i+j)&amp;1) { add(pos(i,j),T,1); continue; } add(S,pos(i,j),1); for(int k=0;k&lt;8;k++) { int nx=i+gox[k]; int ny=j+goy[k]; if(a[nx][ny]!=1&amp;&amp;nx&lt;=n&amp;&amp;nx&gt;0&amp;&amp;ny&lt;=n&amp;&amp;ny&gt;0) { add(pos(i,j),pos(nx,ny),1); } } }else sum--; } } while(bfs()) { sum-=dfs(S,inf); } printf(\"%d\\n\",sum); return 0; } //P4304 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 400009 struct node{ int to; int val; int rev; }; vector&lt;node&gt; e[maxn]; int d[maxn]; int S,T; int n; void add(int x,int y,int z) { e[x].push_back((node){y,z,e[y].size()}); e[y].push_back((node){x,0,e[x].size()-1}); } bool bfs() { memset(d,-1,sizeof(d)); queue&lt;int&gt; q; q.push(S); d[S]=0; while(!q.empty()) { int now=q.front(); q.pop(); for(int i=0;i&lt;e[now].size();i++) { int to=e[now][i].to; if(d[to]==-1&amp;&amp;e[now][i].val) { q.push(to); d[to]=d[now]+1; } } } if(d[T]==-1)return 0; return 1; } int dfs(int x,int low) { if(x==T||low==0)return low; int totflow=0; for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i].to; int val=e[x][i].val; int rev=e[x][i].rev; if(val&amp;&amp;d[to]==d[x]+1) { int a=dfs(to,min(low,val)); e[x][i].val-=a; e[to][rev].val+=a; totflow+=a; low-=a; if(low==0)return totflow; } } if(low)d[x]=-1; return totflow; } int a[201][201]; int gox[8]={-1,-2,1,2,-1,-2,1,2}; int goy[8]={-2,-1,-2,-1,2,1,2,1}; #define pos(x,y) ((x-1)*n+y) char f[209]; signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%s\",f); for(int j=0;j&lt;n;j++) { a[i][j+1]=f[j]-'0'; } } S=n*n+5,T=n*n+6; int sum=n*n; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(a[i][j]!=1) { if((i+j)&amp;1) { add(pos(i,j),T,1); continue; } add(S,pos(i,j),1); for(int k=0;k&lt;8;k++) { int nx=i+gox[k]; int ny=j+goy[k]; if(a[nx][ny]!=1&amp;&amp;nx&lt;=n&amp;&amp;nx&gt;0&amp;&amp;ny&lt;=n&amp;&amp;ny&gt;0) { add(pos(i,j),pos(nx,ny),1); } } }else sum--; } } while(bfs()) { sum-=dfs(S,inf); } printf(\"%d\\n\",sum); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"网络流","slug":"网络流","permalink":"https://lzylzy.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"P5295 [北京省选集训2019]图的难题","date":"2020-08-24T06:34:22.000Z","path":"posts/31d43541.html","text":"发现一个性质：一个图符合条件当且仅当满足任意一个点集满足 E&lt;=2*V-2 假设图中有2*V-2条边，为了符合条件，一定有一棵白色的生成树和黑色的生成树。 而如果多一条边，肯定会有一棵树增加一条边，变成环，不符合条件 所以我们判断任意一个子图是否满足E-2*V&lt;=-2 如果所有子图都满足条件就是yes 闭合子图：假设U为一个子图 且i∈U 则任意j满足i-&gt;J都必须在子图内 最大权闭合子图：每个点有点权，求权值最大的闭合子图 求法：所有点权为正的点向S连边，权值为点权；所有点权为负的点向T连边，权值为点权的绝对值 原图中的无向边权值为inf 我们先求出所有正点权的和S，再对这个图做最小割 如果割掉了连向T的边，说明这个点被选择了 如果割掉了连向S的边，说明这个点没被选 则最大权闭合子图的答案为S-dinic() 本题做法：边化成点，点权为1 原有的点点权为-2 这样选出最大子图权值总和为E-2*V 直接判断他和-2的大小关系即可 另外，我们要枚举哪个点被强制选中，因为空集是不合法的 code: #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x3f3f3f3f; typedef long long ll; #define maxn 500009 int a[500020][3]; int h[60020]; int v[60020]; int n,m,l,S,T; int tot; void add(int x,int y,int z) { tot++; a[tot][0]=h[x]; a[tot][1]=y; a[tot][2]=z; h[x]=tot; tot++; a[tot][0]=h[y]; a[tot][1]=x; a[tot][2]=0; h[y]=tot; } int bfs() { int now,p,i; memset(v,0,sizeof v); v[S]=1; queue&lt;int&gt;q; q.push(S); while(!q.empty()) { now=q.front(); q.pop(); for(i=h[now];i;i=a[i][0]) { if(!v[a[i][1]]&amp;&amp;a[i][2]) { v[a[i][1]]=v[now]+1; q.push(a[i][1]); if(a[i][1]==T) return 1; } } } return 0; } int dfs(int x,int y) { int u=y,k,i; if(x==T) return y; for(i=h[x];i;i=a[i][0]) { if(u&amp;&amp;a[i][2]&amp;&amp;v[a[i][1]]==v[x]+1) { k=dfs(a[i][1],min(a[i][2],u)); if(!k) v[a[i][1]]=0; u-=k; a[i][2]-=k; a[i^1][2]+=k; } } return y-u; } int ex[maxn],ey[maxn]; int work(int x) { memset(h,0,sizeof(h)); tot=1; for(int i=1;i&lt;=n;i++)//原来的点集 { if(i!=x) { add(i,T,2); } } for(int i=1;i&lt;=m;i++) { add(S,i+n,1); add(i+n,ex[i],inf); add(i+n,ey[i],inf); } int s=m-2;//强制选了一个点所以m-2 while(bfs()) while(int dd=dfs(S,inf)) { s-=dd; //cout&lt;&lt;s&lt;&lt;endl; } return s; } template&lt;class nT&gt; inline void read(nT &amp;x) { char c; while(c=getchar(),!isdigit(c)); x=c^48; while(c=getchar(),isdigit(c)) x=x*10+c-48; } signed main() { int q; scanf(\"%d\",&amp;q); while(q--) { scanf(\"%d%d\",&amp;n,&amp;m); S=n+m+3,T=n+m+2; for(int i=1;i&lt;=m;i++) { scanf(\"%d%d\",&amp;ex[i],&amp;ey[i]); } int ans=-inf; for(int i=1;i&lt;=n;i++) { ans=max(ans,work(i)); } if(ans&lt;=-2)printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"网络流","slug":"网络流","permalink":"https://lzylzy.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"P2774 方格取数问题","date":"2020-08-20T10:06:05.000Z","path":"posts/daa4c01e.html","text":"给定n*m的网格，要选择四个方向不相邻的数字，使得结果最大 我们转化题目 要求构造这样的结构： 能表示n个点 不选择一个数的代价为 $ a[i][j]$ 要么能反悔，要么选择出来就是最优解 显然容易想到网络流 建立一个二分图， 源点连向横纵坐标之和为奇数的格子，权值为a[i][j]a[i][j]a[i][j] 汇点连向横纵坐标之和为偶数的格子，权值为a[i][j]a[i][j]a[i][j] 两边的格子连双向边，权值为inf,表示中间这些边不能被割断 对这个图求最小割，割掉一条边表示不选择这个点，代价为 a[i][j]a[i][j]a[i][j] 最终状态图不联通，即没有选择相邻的点 用所有点权总和减去最小割即可 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 400009 struct node{ int to; int val; int rev; }; vector&lt;node&gt; e[maxn]; int n,m; int S,T; #define pos(i,j) (m*i+j) int d[maxn]; void add(int x,int y,int z) { e[x].push_back((node){y,z,e[y].size()}); e[y].push_back((node){x,0,e[x].size()-1}); } bool bfs() { memset(d,-1,sizeof(d)); queue&lt;int&gt; q; q.push(S); d[S]=0; while(!q.empty()) { int now=q.front(); q.pop(); for(int i=0;i&lt;e[now].size();i++) { int to=e[now][i].to; if(d[to]==-1&amp;&amp;e[now][i].val) { q.push(to); d[to]=d[now]+1; } } } if(d[T]==-1)return 0; return 1; } int dfs(int x,int low) { if(x==T||low==0)return low; int totflow=0; for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i].to; int rev=e[x][i].rev; int val=e[x][i].val; if(d[to]==d[x]+1&amp;&amp;val) { int a=dfs(to,min(low,val)); e[x][i].val-=a; totflow+=a; e[to][rev].val+=a; low-=a; if(low==0)return totflow; } } if(low)d[x]=-1; return totflow; } int gi[4]={0,1,0,-1}; int gj[4]={1,0,-1,0}; signed main() { scanf(\"%d%d\",&amp;n,&amp;m); S=0,T=pos(n,m)+2; int ans=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { int x; scanf(\"%d\",&amp;x); ans+=x; if((i+j)&amp;1) { add(S,pos(i,j),x);//奇数 for(int k=0;k&lt;4;k++) { int ni=i+gi[k]; int nj=j+gj[k]; if(ni&gt;=1&amp;&amp;nj&gt;=1&amp;&amp;ni&lt;=n&amp;&amp;nj&lt;=m) { // add(pos(ni,nj),pos(i,j),inf); add(pos(i,j),pos(ni,nj),inf); } } } else { add(pos(i,j),T,x); } } } while(bfs()) { ans-=dfs(S,inf); } printf(\"%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"网络流","slug":"网络流","permalink":"https://lzylzy.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"P2172 [国家集训队]部落战争","date":"2020-08-18T04:06:52.000Z","path":"posts/6ba2df32.html","text":"二分图的最小边覆盖 定义：用最少的边覆盖整个子图的边的数量 求法：n-最大匹配 本题具体做法 每个点拆为两个点，入点和出点 入点出点不连边，入点向能到达的所有点的出点连边 所有入点连向源点，所有出点连向汇点 发现这是一个二分图 为什么入点出点不连边？ 入点连向了源点，出点连向了汇点，再把入点出点连起来就全通了 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; #define maxn 100069 int d[maxn]; int m,n,r,c; int S,T; struct node{ int to; int val; int rev; }; vector&lt;node&gt; e[maxn]; void add(int x,int y,int v) { e[x].push_back((node){y,v,e[y].size()}); e[y].push_back((node){x,0,e[x].size()-1}); } int ans=0; bool bfs() { memset(d,-1,sizeof(d)); d[S]=0; queue&lt;int&gt; q; q.push(S); while(!q.empty()) { int x=q.front(); q.pop(); for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i].to; if(d[to]==-1&amp;&amp;e[x][i].val) { d[to]=d[x]+1; q.push(to); } } } if(d[T]==-1)return 0; return 1; } int dfs(int x,int low) { if(x==T||low==0)return low; int totflow=0; for(int i=0;i&lt;e[x].size();i++) { int y=e[x][i].to; int rev=e[x][i].rev; if(d[y]==d[x]+1&amp;&amp;e[x][i].val) { int a=dfs(y,min(e[x][i].val,low)); e[x][i].val-=a; e[y][rev].val+=a; low-=a; totflow+=a;; if(low==0)return totflow; } } if(low!=0) { d[x]=-1; } return totflow; } void dinic() { while(bfs()) { ans+=dfs(S,inf); } } signed main() { scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;r,&amp;c); char ch[99][99]; int gox[4]={r,c,r,c}; int goy[4]={c,r,-c,-r}; for(int i=1;i&lt;=n;i++) { scanf(\"%s\",ch[i]+1); } S=0,T=n*m+n*m+m+9; int sum=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { if(ch[i][j]=='.')//这是一个正常的点 { add(S,i*m+j,1);//源点到入点 add(i*m+j+n*m,T,1);//出点到汇点 for(int k=0;k&lt;4;k++) { int ni=i+gox[k]; int nj=j+goy[k]; if(ni&gt;0&amp;&amp;nj&gt;0&amp;&amp;nj&lt;=m&amp;&amp;ni&lt;=n&amp;&amp;ch[ni][nj]=='.') { add(i*m+j,ni*m+nj+n*m,inf);//入点到其他出点 } } }else sum++; } } int ans=0; while(bfs()) { ans+=dfs(S,inf); } printf(\"%d\\n\",n*m-ans-sum); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"网络流","slug":"网络流","permalink":"https://lzylzy.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"几个在线画图工具","date":"2020-08-16T09:39:55.000Z","path":"posts/d92d95d1.html","text":"一、黑色背景绿色字体…… https://www.ddosi.com/hs/index.html 二、 https://www.desmos.com/calculator 三、访问稍稍有点慢…… https://www.geogebra.org/classic document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"NOIP 2018 提高组初赛试题 题目-答案-简要解析","date":"2020-08-16T09:33:51.000Z","path":"posts/dadba983.html","text":"一、单项选择题（共 10 题，每题 2 分，共计 20 分； 每题有且仅有一个正确选项） \\1. 下列四个不同进制的数中，与其它三项数值上不相等的是（ ）。 A. (269) 16 B. (617) 10 C. (1151) 8 D. (1001101011) 2 答案：D 解析：进制转换，把所有的选项都转换成相同的进制即可。至于转成几进制，看个人喜好 \\2. 下列属于解释执行的程序设计语言是（ ）。 A. C B. C++ C. Pascal D. Python 答案：D 解析：可以理解为：需要编译的就是非解释性语言。本人印象最深的解释型语言是Java，有什么错写完一句就报出来。 C,C++,pascal都是需要编译的语言，就是非解释性语言 而python是交互式的，也是解释性语言 \\3. 中国计算机学会于（ ）年创办全国青少年计算机程序设计竞赛。 A. 1983 B. 1984 C. 1985 D. 1986 答案：B 解析：？？？我也不知道 \\4. 设根节点深度为 0，一棵深度为 h 的满 k（k&gt;1）叉树，即除最后一层无任何 子节点外，每一层上的所有结点都有 k 个子结点的树，共有（ ）个结点。 A. (k^{h+1}-1)/(k-1)(kh+1−1)/(k−1) B. k^{h-1}kh−1 C. k^hkh D. (k^{h-1})/(k-1)(kh−1)/(k−1) 答案：A 解析：等比数列求和。我是蒟蒻不会？多画两棵树自己试（逃 \\5. 设某算法的时间复杂度函数的递推方程是 T(n) = T(n - 1) + n（n 为正整数） 及 T(0) = 1，则该算法的时间复杂度为（ ）。 A. O(log n) B. O(n log n) C. O(n) D. O(n^2) 答案：D 解析： NOIP初赛中的时间复杂度分析题就是授人以鱼，考人以鱽鱾鲀鱿鲃鲂鲉鲌鲄鲆鲅鲇鲏鲊鲋鲐鲈鲍鲎鲝鲘鲙鲗鲓鲖鲞鲛鲒鲚鲜鲟鲔鲕鲑鲧鲬鲪鲫鲩鲣鲨鲡鲢鲤鲠鲥鲦鲺鲯鲹鲴鲶鲳鲮鲭鲵鲲鲰鲱鲻鲷鲸鳋鳊鳁鳀鲾鲼鳈鳉鳃鳄鲿鳇鳂鳆鳅鲽鳌鳒鳎鳏鳑鳐鳍鳘鳛鳕鳓鳙鳗鳚鳔鳖鳜鳟鳞鳝鳡鳠鳢鳣鳤。 引自洛谷日报（逃 求和……要把式子展开，变成 1+1+2+3+…+(n-1)+n=1+n*(n+1)/2然后忽略常数复杂度总和变成n^2 A. a d * b c * - B. - * a d * b c C. a * d - b * c D. - * * a d b c 答案：B 解析：先建一棵表达式树，先序遍历就是前缀表达式 \\7. 在一条长度为 1 的线段上随机取两个点，则以这两个点为端点的线段的期望 长度是（ ）。 A. 1 / 2 B. 1 / 3 C. 2 / 3 D. 3 / 5 答案：B 解析：全靠猜 我们设这个区间[l,r]l=0,因题目0&lt;r&lt;1 0-r长度的期望为1/2，显然l-r的期望会比0-r小……所以就是1/3了（ \\8. 关于 Catalan 数 Cn = (2n)! / (n + 1)! / n！，下列说法中错误的是（ ）。 A. Cn 表示有 n + 1 个结点的不同形态的二叉树的个数。 B. Cn 表示含 n 对括号的合法括号序列的个数。 C. Cn 表示长度为 n 的入栈序列对应的合法出栈序列个数。 D. Cn 表示通过连接顶点而将 n + 2 边的凸多边形分成三角形的方法个数。 答案：A 解析：基本知识？反正我不会QwQ 找个数带进去就行 \\9. 假设一台抽奖机中有红、蓝两色的球，任意时刻按下抽奖按钮，都会等概率 获得红球或蓝球之一。有足够多的人每人都用这台抽奖机抽奖，假如他们的 策略均为：抽中蓝球则继续抽球，抽中红球则停止。最后每个人都把自己获 得的所有球放到一个大箱子里，最终大箱子里的红球与蓝球的比例接近于 （ ）。 A. 1 : 2 B. 2 : 1 C. 1 : 3 D. 1 : 1 答案：D 解析：算出每一轮拿到红球的期望为1，拿到蓝球必定1个，所以比例会接近1:1 \\10. 为了统计一个非负整数的二进制形式中 1 的个数，代码如下： int CountBit(int x) { int ret = 0; while (x) { ret++; ________; } return ret; } 则空格内要填入的语句是（ ）。 A. x &gt;&gt;= 1 B. x &amp;= x - 1 C. x |= x &gt;&gt; 1 D. x &lt;&lt;= 1 答案：B 解析：排除法+手算 二 、 不定 项选择题（共 5 题，每题 2 分，共计 10 分 ；每题有一个或多个正确选 项，多选或少选均不得分 ） \\1. NOIP 初赛中，选手可以带入考场的有（ ）。 A. 笔 B. 橡皮 C. 手机（关机） D. 草稿纸 答案：AB 解析：凭感觉 \\2. 2-3 树是一种特殊的树，它满足两个条件： （1）每个内部结点有两个或三个子结点； （2）所有的叶结点到根的路径长度相同。 如果一棵 2-3 树有 10 个叶结点，那么它可能有（ ）个非叶结点。 A. 5 B. 6 C. 7 D. 8 答案：CD 解析：自己构造树 \\3. 下列关于最短路算法的说法正确的有（ ）。 A. 当图中不存在负权回路但是存在负权边时，Dijkstra 算法不一定能求出源 点到所有点的最短路。 B. 当图中不存在负权边时，调用多次 Dijkstra 算法能求出每对顶点间最短路 径。 C. 图中存在负权回路时，调用一次 Dijkstra 算法也一定能求出源点到所有点 的最短路。 D. 当图中不存在负权边时，调用一次 Dijkstra 算法不能用于每对顶点间最短 路计算。 答案：ABD 解析：dijstra算法不适用于负权图，而且它用于求单点到其他点的最短路 \\4. 下列说法中，是树的性质的有（ ）。 A. 无环 B. 任意两个结点之间有且只有一条简单路径 C. 有且只有一个简单环 D. 边的数目恰是顶点数目减 1 答案：ABD 解析：树的基本知识 \\5. 下列关于图灵奖的说法中，正确的有（ ）。 A. 图灵奖是由电气和电子工程师协会（IEEE）设立的。 B. 目前获得该奖项的华人学者只有姚期智教授一人。 C. 其名称取自计算机科学的先驱、英国科学家艾伦·麦席森·图灵。 D. 它是计算机界最负盛名、最崇高的一个奖项，有“计算机界的诺贝尔奖” 之称。 答案：BCD 解析：你觉得A能对吗 --------------------- 二、问题求解（每题5分，共10分） 1. 甲乙丙丁四人在考虑周末要不要外出郊游。 已知①如果周末下雨，并且乙不去，则甲一定不去；②如果乙去，则丁一定去；③如果丙去，则丁一定不去；④如果丁不去，而且甲不去，则丙一定不去。如果周末丙去了，则甲_____（去了/没去）(1分)，乙_____（去了/没去）(1分)，丁_____（去了/没去）(1分)，周末_____（下雨/没下雨）(2分)。 答案：去了，没去，没去，没下雨 解析：送分题，根据条件判断即可 2. 方程 a*b =(a or b) * (a and b)，在a, b都取[0、31]中的整数时，共有______组解。（*表示乘法；or表示按位或运算；and表示按位与运算） 解析：使得a|b== max(a,b),a&amp;b == min(a,b) 显然，a，b存在子集关系时上面的式子才能成立。 例如：1011|1001=1011=max(1011,1001) 可以自己举例验证QwQ 我们设b是a的子集，枚举a在二进制下有多少个1，即从5里面取i个1，i从0到5。每个i都是一个C(5, i) 接着枚举子集，有2^i中方案（每一个1都看看放还是不放） C(5,0)*2^0 +C(5,1)*21+…+C(5,5)*25 = 11 + 52 + 104 + 108 + 516 + 132 = 243 最后，由于我们限制了a&gt;b，所以答案要*2 但是a==b的情况会被多算，所以答案减去32 最后结果：2*243 – 32 = 452 四、阅读程序写结果（共 4 题，每题8 分，共计 32 分） \\#include int main() { int x; scanf(\"%d\", &amp;x); int res = 0; for (int i = 0; i &lt; x; ++i) { if (i * i % x == 1) { ​ ++res; } } printf(\"%d\", res); return 0; } 输入：15 输出：4 解析：简单模拟 \\#include int n, d[100]; bool v[100]; int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", d + i); v[i] = false; } int cnt = 0; for (int i = 0; i &lt; n; ++i) { if (!v[i]) { ​ for (int j = i; !v[j]; j = d[j]) { ​ v[j] = true; ​ } ​ ++cnt; } } printf(\"%d\\n\", cnt); return 0; } 输入：10 7 1 4 3 2 5 9 8 0 6 输出：6 解析：继续模拟（逃 \\#include using namespace std; string s; long longmagic(int l, int r) { long long ans = 0; for (int i = l; i &lt;= r; ++i) { ans = ans * 4 + s[i] - 'a' + 1; } return ans; } int main() { cin &gt;&gt; s; int len = s.length(); int ans = 0; for (int l1 = 0; l1 &lt; len; ++l1) { for (int r1 = l1; r1 &lt; len; ++r1) { ​ bool bo = true; ​ for (int l2 = 0; l2 &lt; len; ++l2) { ​ for (int r2 = l2; r2 &lt; len; ++r2) { ​ if (magic(l1, r1) == magic(l2, r2)&amp;&amp; (l1 != l2 || r1 != r2)) { ​ bo = false; ​ } ​ } ​ } ​ if (bo) { ​ ans += 1; ​ } } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } 输入：abacaba 输出：16 解析：magic(l,r)是l-r的hash，枚举两个子串，答案就是不重复出现的子串个数，手动枚举。 \\#include using namespace std; const int N =110; bool isUse[N]; int n, t; int a[N], b[N]; bool isSmall() { for (int i = 1; i &lt;= n; ++i) if (a[i] != b[i]) return a[i] &lt; b[i]; return false; } boolgetPermutation(int pos) { if (pos &gt; n) { return isSmall(); } for (int i = 1; i &lt;= n; ++i) { if (!isUse[i]) { ​ b[pos] = i; isUse[i] = true; ​ if (getPermutation(pos + 1)) { ​ return true; ​ } ​ isUse[i] = false; } } return false; } void getNext() { for (int i = 1; i &lt;= n; ++i) { isUse[i] = false; } getPermutation(1); for (int i = 1; i &lt;= n; ++i) { a[i] = b[i]; } } int main() { scanf(\"%d%d\", &amp;n, &amp;t); for (int i = 1; i &lt;= n; ++i) { scanf(\"%d\", &amp;a[i]); } for (int i = 1; i &lt;= t; ++i) { getNext(); } for (int i = 1; i &lt;= n; ++i) { printf(\"%d\", a[i]); if (i == n) putchar('\\n'); else putchar(''); } return 0; } 输入1：6 10 1 6 4 5 32 输出 1：2 1 3 5 6 4 (3 分) 输入2：6 200 1 5 3 4 26 输出 2：3 2 5 6 1 4 (5 分) 解析：这一大堆函数就是求这个排列的下一个……手算即可（当然如果你觉得200算不出来可以使用康托展开） 五、完善程序（共 2 题，每题 14 分，共计 28 分） \\1. 对于一个1到n的排列p(即1到n中每一个数在p中出现了恰好一次)，令qi为第i个位置之后第一个比pi值更大的位置，如果不存在这样的位置，则qi =n+1。 举例来说，如果n=5且p为1 5 4 2 3，则q为2 6 6 5 6。 下列程序读入了排列p，使用双向链表求解了答案。试补全程序。（第二空2分，其余3分） 数据范围 1 ≤ n ≤ 105。 \\#include using namespace std; const int N =100010; int n; int L[N], R[N],a[N]; int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { int x; cin &gt;&gt; x; a[x] = i ; } for (int i = 1; i &lt;= n; ++i) { R[i]= i + 1; L[i] = i - 1; } for (int i = 1; i &lt;= n; ++i) { L[ R[a[i]]] = L[a[i]]; R[L[a[i]]] = R[a[i] ]; } for (int i = 1; i &lt;= n; ++i) { cout &lt;&lt; R[i]&lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } 解析： 纯靠猜。1空发现没有直接读入，肯定有鬼……瞎猜一种方法就行 2空仿写下句…… 3,4空互相仿写…… 5空我们肯定要求这个数右边比他大的数的位置，所以输出R 当然我蒻看不懂，有心情研究的julao们可以再去找找…… \\2. 一只小猪要买 N 件物品(N 不超过 1000)。 它要买的所有物品在两家商店里都有卖。第 i 件物品在第一家商店的价格是 a[i]，在第二家商店的价格是 b[i]，两个价格都不小于 0 且不超过 10000。如果在第一家商店买的物品的总额不少于 50000，那么在第一家店买的物品都可以打 95 折（价格变为原来的 0.95 倍）。 求小猪买齐所有物品所需最少的总额。 输入：第一行一个数 N。接下来 N 行，每行两个数。第 i 行的两个数分别代表 a[i]，b[i]。 输出：输出一行一个数，表示最少需要的总额，保留两位小数。 试补全程序。（第一空 2 分，其余 3 分） #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int Inf = 1000000000; const int threshold = 50000; const int maxn = 1000; int n, a[maxn], b[maxn]; bool put_a[maxn]; int total_a,total_b; double ans; intf[threshold]; int main() { //第一部分 scanf(\"%d\",&amp;n); total_a= total_b = 0; for(int i = 0; i &lt; n; ++i) { scanf(\"%d%d\",a + i, b + i); if(a[i] &lt;= b[i]) total_a += a[i]; elsetotal_b += b[i]; } ans =total_a + total_b; total_a= total_b = 0; for(int i = 0; i &lt; n; ++i) { if( (1) ) { put_a[i]= true; total_a+= a[i]; }else { put_a[i]= false; total_b+= b[i]; } } if ((2) ) { printf(\"%.2f\",total_a * 0.95 + total_b); return0; } //第二部分 f[0]= 0; for(int i = 1; i &lt; threshold; ++i) f[i]= Inf; inttotal_b_prefix = 0; for(int i = 0; i &lt; n; ++i) if (!put_a[i]) { total_b_prefix += b[i]; for (int j = threshold - 1; j &gt;= 0; --j) { if ( (3) &gt;= threshold &amp;&amp; f[j] != Inf) ans = min(ans, (total_a + j +a[i]) * 0.95+ (4) ); f[j] = min(f[j] + b[i], j &gt;= a[i] ? (5) :Inf); } } printf(\"%.2f\",ans); return0; } 解析： 代码分为两个部分。 第一部分是一个贪心，我们假设满足了优惠条件，按照折后价格进行贪心，如果结果满足了优惠条件就直接输出，此时如果放弃某些b商品来买a不会再有更优策略 第二部分是一个dp……策略就是把原先买了b的东西买a以获得折扣 f[i,j]表示前i个物品，在额外在A店花了j元的情况下，购买B店物品花费的最小值。i呢？想想你的01背包是怎么优化的。 3空是一个转移判断条件，tot_a+j+a[i]是在a店话费的总钱数（本来花的钱+前面改了的钱+当前物品价格） 4空表示在b商店买的物品总价， total_b + f[j] - total_b_prefix 5空更新，看看这个商品在a商店买还是b商店买 太毒瘤了QwQ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"如何手动开大系统栈?","date":"2020-08-16T09:32:23.000Z","path":"posts/a4454329.html","text":"Dev-c++:手动开大系统栈，防止爆栈 在各大OJ上，系统栈都会开大，而在本地调试时，常用到云端下载的各种毒瘤数据，一不小心就可能在本机上爆掉系统栈，在oj上却没事。 Devc++：工具-&gt;编译选项-&gt;选择编译时加入以下命令-&gt;输入： -Wl,--stack=134217728 Dev-c++神奇操作，请看： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"安装完Dev-c++如何设置?Dev-c++神奇配置指北","date":"2020-08-16T09:29:21.000Z","path":"posts/d537899.html","text":"安装完Dev-c++后，我们通常会根据自己的喜好调整设置，以下是个人的做法，欢迎参考。 1.字体 字体在安装界面就可以更改。默认字体是consoles，个人喜欢下面的courier new 有些字体很奇怪，甚至根本不能显示。。。 2.符号补全 位置：工具-&gt;编译器选项-&gt;代码补全-&gt;完成符号 建议把所有的都打开，当然可以根据习惯调整。 3.缺省源 位置：工具-&gt;编译器选项-&gt;代码-&gt;缺省源 勾选“向项目初始源文件插入代码”，在下面一栏写入以下代码： #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff signed main() { return 0; } 解释：第一行万能头文件，不喜欢可以自己写别的 第二行不讲。。。 第三行的意思是当你写ll的时候系统就会认为你写了long long，比如你可以这么写： ll a=0; 第四行设置最大值，0x7fffffff是int的最大值，有的时候用的不好容易爆掉 最大值还有一个常用的0x3f3f3f3f,但我觉得这个太小了，用过一次被卡了。。。 signed main：signed就等于int，两者可以通用，为什么写signed呢？个人有一种习惯： #define int long long 这时main就会出编译错误。。。 根据喜好还可以加入freopen 这一步的作用是：每当你创建一个新文件，里面都会有这样一段代码，省去敲头文件的麻烦。 4.自动保存 省去断电重写的麻烦QwQ 位置：工具-&gt;编译器选项-&gt;自动保存 先勾选“启动编译器自动保存”，然后选择间隔时间 个人喜欢两分钟一保存 下面的不用动 5.代码警告 这是我用过最好的功能…… 当你写long long a;scanf(\"%d\",&amp;a);的时候就会报警提示，省去很多不必要的麻烦 位置：工具-&gt;编译选项-&gt;代码生成/优化-&gt;代码警告 把第二个显示最多警告信息变成yes 6.手动开大系统栈 在各大OJ上，系统栈都会开大，而在本地调试时，常用到云端下载的各种毒瘤数据，一不小心就可能在本机上爆掉系统栈，在oj上却没事。 目录：工具-&gt;编译选项-&gt;编译器 勾选 选择编译时加入以下命令，输入： -Wl,--stack=134217728 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P2290 [HNOI2004]树的计数","date":"2020-07-28T09:45:04.000Z","path":"posts/2bc1a32b.html","text":"前置知识：prufer序列 对于一颗无根树，可以生成一个唯一的长度为n-2的序列 转化1：从无根树到prefurprefu**r序列 以下过程引用洛谷博客，格式可能错乱，可以自行百度或去原文章访问 https://www.cnblogs.com/chenxiaoran666/p/Luogu2290.html 如果你不想看了解那么多 可以跳转到 **这道题需要的知识 ** 部分 现在，给你一棵树，我们要考虑如何把它变成prefurprefu**r序列。 我们需要重复进行以下操作，直至树中只剩下两个点： 找到一个度数为1，且编号最小的点。（其中编号最小保证了后面将会提到的pruferprufe**r序列的唯一对应性，同时也方便从pruferprufe**r序列转化回无根树） 把这个点的父亲节点加入序列，然后把这个点从树中删除。 然后我们就得到了一个长度为n-2n−2的序列，这就是pruferprufe**r序列。 所以它有什么实际意义呢？ 我也不知道。 以上面的图为例，我们可以模拟这一过程如下： 找到4号节点，将其父结点加入序列，然后将其删去。此时序列：{2}{2}。 找到5号节点，将其父结点加入序列，然后将其删去。此时序列：{2,3}{2,3}。 找到3号节点，将其父结点加入序列，然后将其删去。此时序列：{2,3,1}{2,3,1}。 找到6号节点，将其父结点加入序列，然后将其删去。此时序列：{2,3,1,2}{2,3,1,2}。 找到2号节点，将其父结点加入序列，然后将其删去。此时序列：{2,3,1,2,1}{2,3,1,2,1}。 所以，最后得到的pruferprufe**r序列就是{2,3,1,2,1}{2,3,1,2,1}。 转化22：从pruferprufe**r序列到无根树 还是以刚才那棵树为例吧，我们要考虑如何把它的prefurprefu**r序列变回它本身。 我们需要重复进行以下操作，直至点集中只剩下两个点：（初始化所有点都在点集中） 取出pruferprufe**r序列最前面的元素xx。 取出在点集中的、且当前不在pruferprufe**r序列中的最小元素yy。（这恰好呼应了前面提到过的选取编号最小的节点） 在x,yx,y之间连接一条边。（注意前面的取出相当于删除） 最后，我们在点集中剩下的两个点中连一条边。 显然这有n-1n−1条边，且绝对不会形成环，因此它是一棵树，且就是原树。 以上面的序列为例，我们可以模拟这一过程如下： 取出2,42,4连边。此时pruferprufe**r序列：{3,1,2,1}{3,1,2,1}，点集：{1,2,3,5,6,7}{1,2,3,5,6,7}。 取出3,53,5连边。此时pruferprufe**r序列：{1,2,1}{1,2,1}，点集：{1,2,3,6,7}{1,2,3,6,7}。 取出1,31,3连边。此时pruferprufe**r序列：{2,1}{2,1}，点集：{1,2,6,7}{1,2,6,7}。 取出2,62,6连边。此时pruferprufe**r序列：{1}{1}，点集：{1,2,7}{1,2,7}。 取出1,21,2连边。此时pruferprufe**r序列：{}{}，点集：{1,7}{1,7}。 最后再在1,71,7间连边，就可以得到原树了。 pruferprufe**r序列的性质及相关结论 讲了这么多，我们最关键的还是pruferprufe**r序列的一些性质，以及与其有关的一些结论。（毕竟前面也提到过，我也不知道这东西有什么实际意义） **重要性质：prufer*p**r**u**f*e*r*序列与无根树一一对应。 这应该显然吧，通过前面的介绍应该可以直接得出。 而由这个性质，我们才能推导出后面的结论。 **度数为d_i*d**i*的节点会在prufer*p**r**u**f**e*r*序列中出现d_i-1*d*i*−1次。 当某个节点度数为11时，会直接被删掉，否则每少掉一个相邻的节点，它就会在序列中出现11次。 因此共出现d_i-1d**i−1次。 *一个n*n*个节点的完全图的生成树个数为n^{n-2}*n*n*−2。 对于一个nn个点的无根树，它的pruferprufe**r序列长为n-2n−2，而每个位置有nn种可能性，因此可能的pruferprufe**r序列有n^{n-2}n**n−2种。 又由于pruferprufe**r序列与无根树一一对应，因此生成树个数应与pruferprufe**r序列种树相同，即n^{n-2}n**n−2。 对于给定度数为d_{1\\sim n}*d*1∼*n*的一棵无根树共有_ $ \\frac{(n-2)!}{\\prod{i=1}^n(d_i-1)!}∏*i*=1*n*(*d**i*−1)!(*n*−2)! $ 种情况。 由上面的性质可以知道，度数为d_id**i的节点会在pruferprufe**r序列中出现d_i-1d**i−1次。 则就是要求出d_i-1d**i−1个i(1\\le i\\le n)i(1≤i≤n)的全排列个数。 而上面那个式子就是可重全排列公式。（即全排列个数除以重复元素内部的全排列个数） 大致就是这些。 ——引自洛谷UID28382的大佬的题解 解决这题需要知道的 序列长度为n-2，每个数字出现度数-1次 解决问题 问题转化为给a序列，生成由n个数组成的长度为n-2的序列 每个数字出现次数为a[i]-1次 求方案数 类似摆花那题 使用递推解决 预处理组合数+long long可以避免精度爆炸 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int n; #define maxn 199 int a[maxn]; ll C[maxn][maxn]; signed main() { scanf(\"%d\",&amp;n); int sum=0; if(n==1) { int x; scanf(\"%d\",&amp;x); if(x!=0)printf(\"0\\n\"); else printf(\"1\\n\"); return 0; } for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); if(a[i]==0) { printf(\"0\\n\"); return 0; } a[i]--; sum+=a[i]; } if(sum!=n-2) { printf(\"0\\n\"); return 0; } for(int i=0;i&lt;=n;i++) { C[i][0]=1; for(int j=1;j&lt;=i;j++) { C[i][j]=C[i-1][j]+C[i-1][j-1]; } } /* 问题转化为，生成长度为n-2的序列，每个数字出现a[i]-1次 求有多少种序列 */ ll ans=1; int y=n-2; for(int i=1;i&lt;=n;i++) { ans*=C[y][a[i]]; y-=a[i]; } printf(\"%lld\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P6004 [USACO20JAN]Wormhole Sort S","date":"2020-07-28T09:41:14.000Z","path":"posts/f5582704.html","text":"从题目“最小宽度的最大值”看出二分答案 不是最小生成树 最小生成树求的是最小值 二分虫洞的最小宽度 每次check就把宽度大于等于x的边加入 对于所有a[i]!=ia[i]!=ia[i]!=i 的奶牛 看看 a[i]a[i]a[i] 和iii在不在同一连通块内 在的话说明这个奶牛可以到达自己的位置 如果有一只不在的话就return false 使用并查集实现 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int n,m; #define maxn 100009 #define inf 0x7fffffff int a[maxn]; struct node{ int a,b,w; }e[maxn]; int fa[maxn]; int Find(int x) { if(fa[x]==x)return x; return fa[x]=Find(fa[x]); } bool check(int x) { for(int i=1;i&lt;=n;i++) { fa[i]=i; } for(int i=1;i&lt;=m;i++) { if(e[i].w&gt;=x) { fa[Find(e[i].a)]=Find(e[i].b); } } for(int i=1;i&lt;=n;i++) { if(a[i]!=i) { if(Find(i)!=Find(a[i]))return 0; } } return 1; } signed main() { scanf(\"%d%d\",&amp;n,&amp;m); bool ok=1; for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); if(a[i]!=i)ok=0; fa[i]=i; } if(ok) { printf(\"-1\\n\"); return 0; } int l=inf,r=-inf,ans; for(int i=1;i&lt;=m;i++) { scanf(\"%d%d%d\",&amp;e[i].a,&amp;e[i].b,&amp;e[i].w); r=max(r,e[i].w); l=min(l,e[i].w); } while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(check(mid)) { l=mid+1; ans=mid; }else { r=mid-1; } } printf(\"%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1334 瑞瑞的木板","date":"2020-07-28T09:35:08.000Z","path":"posts/3b455b9e.html","text":"发现这题就是合并果子反过来 做法与合并果子相同，因为每次拆开的代价与合并果子中合并的代价其实相同 整个把顺序倒过来即可 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; priority_queue&lt;ll,vector&lt;ll&gt; ,greater&lt;ll&gt; &gt; q; #define maxn 20009 ll n; ll a[maxn]; int cmp(int a,int b) { return a&gt;b; } signed main() { scanf(\"%lld\",&amp;n); ll s=0; for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;a[i]); q.push(a[i]); } int cnt=1; s=0; for(int i=1;i&lt;n;i++) { ll p1=q.top(),q2; q.pop(); q2=q.top(); q.pop(); q.push(p1+q2); s+=p1+q2; //cout&lt;&lt;p&lt;&lt;endl; } printf(\"%lld\\n\",s); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1194 买礼物","date":"2020-07-28T09:31:57.000Z","path":"posts/55a00e88.html","text":"kruscal板子题 把有优惠活动的两个商品之间连一条边，跑最小生成树 不用管没有连接上的就可以 #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x7fffffff; typedef long long ll; int a,n; int m=0; struct node{ int x,y; int s; }e[500009]; bool cmp(node a,node b) { return a.s&lt;b.s; } int fa[509]; int Find(int x) { if(fa[x]==x)return x; return fa[x]=Find(fa[x]); } signed main() { scanf(\"%d%d\",&amp;a,&amp;n); for(int i=1;i&lt;=n;i++)fa[i]=i; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { int x; scanf(\"%d\",&amp;x); if(j&lt;=i&amp;&amp;x&lt;a&amp;&amp;x!=0) { e[++m].y=j; e[m].x=i; e[m].s=x; } } } sort(e+1,e+1+m,cmp); ll ans=a*n; for(int i=1;i&lt;=m;i++) { int x=e[i].x,y=e[i].y; if(Find(x)!=Find(y)) { fa[Find(x)]=Find(y); ans=ans-a+e[i].s; } } printf(\"%lld\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P6033 合并果子 加强版","date":"2020-07-28T09:28:06.000Z","path":"posts/e0bcdb1b.html","text":"合并果子的加强版，扩大了数据范围 Subtask 1（10 points）：1≤n≤81 \\leq n \\leq 81≤n≤8。 Subtask 2（20 points）：1≤n≤1031 \\leq n \\leq 10^31≤n≤103 Subtask 3（30 points）：1≤n≤1051 \\leq n \\leq 10^51≤n≤105 Subtask 4（40 points）：1≤n≤1071 \\leq n \\leq 10^71≤n≤107 对于全部的测试点，保证1≤ai≤105。1 \\leq a_i \\leq 10^5。1≤ai​≤105。 由于n太大，复杂度必须为O(N) 发现a[i]不大，可以使用桶排 不能使用优先队列，改用数组模拟 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll inf=10000000000000000;//小心inf #define maxn 10000009 #define f(x) x=(x==0?inf:x) ll n; int t[100009]; ll st1[maxn]; ll st2[maxn]; int h1=1,t1=0; int h2=1,t2=0; int read()//必须快读 { int x=0; char c=getchar(); while(c&lt;'0'||c&gt;'9') { c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { x=x*10+c-'0'; c=getchar(); } return x; } signed main() { //freopen(\"h.in\",\"r\",stdin); n=read(); ll s=0; for(int i=1;i&lt;=n;i++)//通排 { t[read()]++; } for(int i=1;i&lt;=100000;i++) { while(t[i]--) { st1[++t1]=i; } } for(int i=1;i&lt;n;i++) { ll w=st1[h1]; ll x=st1[h1+1]; ll y=st2[h2]; ll z=st2[h2+1]; f(w);f(x);f(y);f(z); ll ans=0; if(w&lt;y)//第一个用w { ans+=w; h1++; if(x&lt;y) { h1++; ans+=x; }else { h2++; ans+=y; } }else { ans+=y; h2++; if(w&lt;z) { h1++; ans+=w; }else { h2++; ans+=z; } } s+=ans; st2[++t2]=ans; } printf(\"%lld\\n\",s); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1241 括号序列","date":"2020-07-24T04:08:52.000Z","path":"posts/3c1d2f82.html","text":"原题目：扫描一遍原序列，对每一个右括号，找到在它左边最靠近它的左括号匹配，如果没有就放弃。 翻译：扫描一遍原序列，当找到一个右括号（即找到一个 ’ ) ’ 或者 ’ ] ’ 时），以它为起点向左找，找到一个没被标记成功匹配的左括号（即找到一个 ’ ( ’ 或者 ’ [ ’ ），如果两者匹配的话，标记它们成功 牵手 匹配，如果不匹配，或者找不到左括号的话，不做任何标记。 原题目：在以这种方式把原序列匹配完成后，把剩下的未匹配的括号补全。 翻译：上面扫描一遍标记完成功匹配的括号之后，扫描一遍序列，对于标记过的括号，则直接输出；对于没有标记的括号，则补全成对输出 举例：如果有个 ’ [ ’ 或 ’ ] ’ 没被标记匹配，则输出 [ ] 如果还不理解的话，给个测试样例： 输入：( [ ) ] ) 输出：( [ ( ) ] ) #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; bool ck(char a,char b) { if(a=='('&amp;&amp;b==')')return 1; if(a=='['&amp;&amp;b==']')return 1; swap(a,b); if(a=='('&amp;&amp;b==')')return 1; if(a=='['&amp;&amp;b==']')return 1; return 0; } char ans[2590]; int x=0; pair&lt;int,char&gt; adi[2590]; int y=0; int cy=1; signed main() { string a; cin&gt;&gt;a; stack&lt;char&gt; st; stack&lt;int&gt; pos; for(int i=0;i&lt;a.size();i++) { if(a[i]=='('||a[i]=='[') { st.push(a[i]); pos.push(x);//不能push i 因为中间插队的括号会导致位置错乱 }else { if(st.empty())//!!!!小心RE！ { if(a[i]==')')ans[++x]='('; else ans[++x]='['; ans[++x]=a[i];//小心WA~！ continue; } char p=st.top(); // cout&lt;&lt;\"CP:\"&lt;&lt;p&lt;&lt;\" \"&lt;&lt;a[i]&lt;&lt;endl; if(ck(p,a[i])) { st.pop(); pos.pop(); }else { if(a[i]==')')ans[++x]='('; else ans[++x]='['; } } ans[++x]=a[i]; } //cout&lt;&lt;x&lt;&lt;endl; while(!st.empty()) { char p=st.top(); int q=pos.top()+1; st.pop();pos.pop(); y++; adi[y].first=q; if(p=='(')adi[y].second=')'; else adi[y].second=']'; } if(y!=0)sort(adi+1,adi+1+y);//好像reverse就行 for(int i=1;i&lt;=x;i++) { cout&lt;&lt;ans[i]; if(y!=0&amp;&amp;adi[cy].first==i) { cout&lt;&lt;adi[cy].second; cy++; } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P4913 【深基16.例3】二叉树深度","date":"2020-07-16T12:36:23.000Z","path":"posts/32e85e5a.html","text":"可以建树之后进行dfs求出每个节点的深度找最大值 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff int n; #define maxn 1000009 vector&lt;int&gt; son[maxn]; int ans=-inf; void dfs(int now,int dep) { ans=max(ans,dep); for(int i=0;i&lt;son[now].size();i++) { dfs(son[now][i],dep+1); } } signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); if(x!=0) { son[i].push_back(x); } if(y!=0) { son[i].push_back(y); } } dfs(1,1); printf(\"%d\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"code","slug":"code","permalink":"https://lzylzy.cf/tags/code/"}]},{"title":"P1102 A-B 数对","date":"2020-07-16T12:35:07.000Z","path":"posts/48d1c4ef.html","text":"#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff //转化题目 //把数列从小到大排序，每次求ai+C出现了几次 //可以用upperbound-lowerbound实现 int a[200009]; signed main() { int n,c; scanf(\"%d%d\",&amp;n,&amp;c); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;a[i]); sort(a+1,a+1+n); ll ans=0; for(int i=1;i&lt;=n;i++) { ans+=upper_bound(a+1,a+1+n,a[i]+c)-lower_bound(a+1,a+1+n,a[i]+c); } printf(\"%lld\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1918 保龄球 ","date":"2020-07-16T12:32:39.000Z","path":"posts/68dc17be.html","text":"大意是输入一个数组a 求x在a中出现的位置 可以用map映射int解决 或者是离散化 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff map&lt;int,int&gt; mp; signed main() { int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { int x; scanf(\"%d\",&amp;x); mp[x]=i; } int m; scanf(\"%d\",&amp;m); while(m--) { int x; scanf(\"%d\",&amp;x); printf(\"%d\\n\",mp.count(x)?mp[x]:0); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1030 求先序排列","date":"2020-07-16T12:29:39.000Z","path":"posts/39eaac2a.html","text":"模拟了好一大通 QAQ /* 先序遍历：根左右 中序遍历：左根右 后序遍历：左右根 可以直接求出根，在中序遍历里找出左右儿子，继续递归 */ #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff string s1,s2; void dfs(int l,int r,int l2,int r2)//对应s1,s2的哪个区间 { cout&lt;&lt;s2[r2];//s2最后一个直接是根 int pos=s1.find(s2[r2]);//找出根在s1里的位置 int sizel=pos-l; int sizer=r-l+1-1-sizel; if(sizel&gt;0)dfs(l,l+sizel-1,l2,l2+sizel-1); if(sizer&gt;0)dfs(l+sizel+1,r,l2+sizel,r2-1); } signed main() { cin&gt;&gt;s1&gt;&gt;s2; int len=s1.size()-1; dfs(0,len,0,len); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1347 排序","date":"2020-07-14T11:29:39.000Z","path":"posts/b60d629.html","text":"一道拓扑排序题，但是我不会 由于数据范围小得吓人，可以每读入一个关系就进行一遍topsort 如果发现条件不足就继续读入，矛盾或者遍历成功就直接结束 如果读入完了还是条件不足，那就是条件不足了 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff int n,m; #define maxn 29 int b[maxn][maxn]; /* b[i][j]=1 i&gt;j b[i][j]=-1 i&lt;j */ vector&lt;int&gt; son[maxn],id[maxn]; int inn[maxn],in[maxn]; bool app[maxn]; int cnt=0; int fa[maxn]; int oo=inf; int vis[maxn]; int Find(int x) { if(fa[x]==x)return x; return fa[x]=Find(fa[x]); } void topsort(int k) { memcpy(in,inn,sizeof(inn)); queue&lt;int&gt; q; int ns=inf; int res=1; for(int i=0;i&lt;26;i++) { if(in[i]==0&amp;&amp;app[i]) { if(ns!=inf) { res=0;//条件不足 } q.push(i); ns=i; } } if(ns==inf)//有矛盾 { res=-1; } queue&lt;int&gt; ans; while(!q.empty()) { int x=q.front(); q.pop(); ans.push(x); //cout&lt;&lt;x&lt;&lt;endl; if(ans.size()==n&amp;&amp;res==1)//全部入队 { printf(\"Sorted sequence determined after %d relations: \",k); while(!ans.empty()) { putchar((char)(ans.front()+'A')); ans.pop(); } putchar('.'); exit(0); } bool p=0; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; in[to]--; if(in[to]==0) { q.push(to); if(p)res=0;//条件不足 p=1; } } } if(ans.size()!=cnt||res==-1)//没能遍历当前的图 说明有环 { printf(\"Inconsistency found after %d relations.\",k); exit(0); } else return; } signed main() { scanf(\"%d%d\",&amp;n,&amp;m); int s=inf; for(int i=0;i&lt;26;i++)fa[i]=i; for(int i=1;i&lt;=m;i++) { char a[4]; scanf(\"%s\",a); int x=a[0]-'A',y=a[2]-'A'; cnt+=(!app[x])+(!app[y]); app[x]=1,app[y]=1; s=min(s,min(x,y)); fa[Find(x)]=Find(y); if(x==y)//自环 { printf(\"Inconsistency found after %d relations.\\n\",i); return 0; } if(b[x][y]==0) { b[x][y]=-1; b[y][x]=1; son[x].push_back(y); id[x].push_back(i); inn[y]++; }else if(b[x][y]==-1)//重边 { continue; }else//矛盾 { printf(\"Inconsistency found after %d relations.\\n\",i); return 0; } topsort(i); } printf(\"Sorted sequence cannot be determined.\\n\"); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P1127 词链","date":"2020-07-13T10:32:41.000Z","path":"posts/aedc3926.html","text":"//作为首次出现的 入度比出度大1 //要是找不到 就按照第一个来 //剩下部分通过搜索解决】 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff int n; #define maxn 1009 string x[maxn]; vector&lt;int&gt; son[maxn],num[maxn]; int h[maxn];//出现次数 int t[maxn]; //作为首次出现的 入度比出度大1 //要是找不到 就按照第一个来 //剩下部分通过搜索解决 bool vis[maxn]; bool ok=0; void dfs(int rt,string now,int tot) { //cout&lt;&lt;rt&lt;&lt;\" \"&lt;&lt;now&lt;&lt;\" \"&lt;&lt;tot&lt;&lt;endl; if(ok)return; if(tot==n) { cout&lt;&lt;now&lt;&lt;endl; ok=1; return; } for(int i=0;i&lt;son[rt].size();i++) { int to=son[rt][i]; int nt=num[rt][i]; if(vis[nt])continue; vis[nt]=1; dfs(to,now+\".\"+x[nt],tot+1); vis[nt]=0; } } int fa[maxn]; int Find(int x) { if(fa[x]==x)return x; return fa[x]=Find(fa[x]); } bool app[99]; signed main() { scanf(\"%d\",&amp;n); for(int i=0;i&lt;=n;i++)fa[i]=i; for(int i=1;i&lt;=n;i++)//连边 { cin&gt;&gt;x[i]; } sort(x+1,x+1+n); for(int i=1;i&lt;=n;i++) { son[x[i][0]-'a'].push_back(x[i][x[i].size()-1]-'a'); num[x[i][0]-'a'].push_back(i); h[x[i][0]-'a']++; t[x[i][x[i].size()-1]-'a']++; app[x[i][x[i].size()-1]-'a']=1; app[x[i][0]-'a']=1; fa[x[i][0]-'a']=Find(x[i][x[i].size()-1]-'a'); } //确定第一个出现的 int af=-inf; int s=x[1][0]-'a';//默认1 for(int i=0;i&lt;26;i++) { if(app[i]) { if(af==-inf)af=Find(i); else { if(Find(i)!=af) { printf(\"***\"); return 0; } } if(h[i]-t[i]==1) { s=i; } } } for(int i=0;i&lt;1;i++) { vis[num[s][i]]=1; dfs(son[s][i],x[num[s][i]],1); vis[num[s][i]]=0; } if(!ok) { printf(\"***\"); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1801 黑匣子","date":"2020-07-12T07:00:02.000Z","path":"posts/fd017f76.html","text":"对顶堆 发现i是单调不降的，可以使用对顶堆解决问题 类似问题：P1168中位数 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;//小的在上头 priority_queue&lt;int&gt; q1;//大的在上头，大小控制为i int a[200009],t[200009]; signed main() { //freopen(\"h.in\",\"r\",stdin); int n,m; scanf(\"%d%d\",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++)scanf(\"%d\",&amp;a[i]); int j=1; for(int i=1;i&lt;=n;i++) { int x; scanf(\"%d\",&amp;x); for(;j&lt;=x;j++) { q1.push(a[j]); while(q1.size()&lt;i)//保证q1的长度为i { q1.push(q2.top()); q2.pop(); } while(q1.size()&gt;i) { q2.push(q1.top()); q1.pop(); } while(!q1.empty()&amp;&amp;!q2.empty()&amp;&amp;q1.top()&gt;q2.top())//保证q1的top更小 { int l=q1.top(),k=q2.top(); q1.pop();q2.pop(); q2.push(l);q1.push(k); } //printf(\"i:%dj:%d %d\\n\",i,j,q1.top()); } while(q1.size()&lt;i) { q1.push(q2.top()); q2.pop(); } while(q1.size()&gt;i) { q2.push(q1.top()); q1.pop(); } while(!q1.empty()&amp;&amp;!q2.empty()&amp;&amp;q1.top()&gt;q2.top()) { int l=q1.top(),k=q2.top(); q1.pop();q2.pop(); q2.push(l);q1.push(k); } printf(\"%d\\n\",q1.top()); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1621 集合","date":"2020-06-21T10:58:12.000Z","path":"posts/2f1e5e04.html","text":"用埃筛枚举质数作为质因子，看看能不能变成区间里的数字 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff int fa[100020]; int v[100020]; int a,b,p,s=0;; int Find(int x) { if(x==fa[x])return x; return fa[x]=Find(fa[x]); } signed main() { scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;p); for(int i=1;i&lt;=b;i++)fa[i]=i; for(int i=2;i&lt;=b;i++) { if(!v[i]) { for(int j=i;j&lt;=b;j+=i) { v[j]=1; if(i&gt;=p&amp;&amp;j-i&gt;=a) { if(Find(j)!=Find(j-i)) { fa[Find(j)]=Find(j-i); s++; } } } } } printf(\"%d\\n\",b-a+1-s); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P3613 【深基15.例2】寄包柜","date":"2020-06-21T10:57:21.000Z","path":"posts/5d1bcc2a.html","text":"#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff int n,m; map&lt;pair&lt;int,int&gt;,int&gt; mp;//直接用map映射pair实现 signed main() { scanf(\"%d%d\",&amp;n,&amp;m); while(m--) { int opt,x,y,z; scanf(\"%d%d%d\",&amp;opt,&amp;x,&amp;y); if(opt==1) { scanf(\"%d\",&amp;z); mp[make_pair(x,y)]=z; }else { printf(\"%d\\n\",mp.count(make_pair(x,y))==0?0:mp[make_pair(x,y)]); } } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P4715 【深基16.例1】淘汰赛","date":"2020-06-21T10:56:09.000Z","path":"posts/27fe52af.html","text":"#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff int a[250]; signed main() { int n; scanf(\"%d\",&amp;n); n=1&lt;&lt;n; for(int i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } //上半区的最大值 下半区的最大值 两个中较小的一个就是答案 cout&lt;&lt;max_element(a,a+n/2)-max_element(a,a+n)+max_element(a+n/2,a+n)-a+1&lt;&lt;endl; return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P3884 [JLOI2009]二叉树问题","date":"2020-06-21T10:55:20.000Z","path":"posts/13a5bcc7.html","text":"#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff int c[120],d[120],f[120]; int x,y,n; signed main() { scanf(\"%d\",&amp;n); int md=0; c[d[1]]++; for(int i=1;i&lt;n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); f[y]=x; d[y]=d[x]+1; md=max(md,d[y]); c[d[y]]++;//宽度就是某一个深度的节点个数 }int mc=1; for(int i=1;i&lt;=n;i++)mc=max(mc,c[i]); int x,y; scanf(\"%d%d\",&amp;x,&amp;y); int z=0; while(x!=y) { if(d[x]&lt;d[y]) { y=f[y]; z++; }else { x=f[x]; z+=2; } } printf(\"%d\\n%d\\n%d\",md+1,mc,z); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1364 医院设置","date":"2020-06-21T10:54:30.000Z","path":"posts/d3586754.html","text":"#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff int s[120];//size int f[120]; int l[120];//lson int r[120];//rson int n; void dfs(int x) { if(x) { dfs(l[x]); s[x]+=s[l[x]]; f[x]+=f[l[x]]+s[l[x]]; dfs(r[x]); s[x]+=s[r[x]]; f[x]+=f[r[x]]+s[r[x]]; } } signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d%d%d\",&amp;s[i],&amp;l[i],&amp;r[i]); } dfs(1); int x=1,z=f[x]; while(1) { if(s[l[x]]*2&gt;s[1])//左边人多，他的两倍比总人数多 { z+=s[1]-2*s[l[x]];//往左走 x=l[x]; }else if(s[r[x]]*2&gt;s[1])//同理往右 { z+=s[1]-2*s[r[x]]; x=r[x]; }else break; } printf(\"%d\\n\",z); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P1160 队列安排","date":"2020-06-21T08:48:39.000Z","path":"posts/b71d7c5c.html","text":"太水 直接上code #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff #define maxn 100020 int l[maxn],r[maxn],v[maxn]; void dfs(int x) { if(!x)return; dfs(l[x]); if(!v[x])cout&lt;&lt;x&lt;&lt;\" \"; dfs(r[x]); } signed main() { int n; scanf(\"%d\",&amp;n); for(int i=2;i&lt;=n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); if(y==0)//加入，替换掉原来这个位置的人把他接到这个加入的人后面 { l[i]=l[x]; l[x]=i; }else//同理 { r[i]=r[x]; r[x]=i; } } scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { int x; scanf(\"%d\",&amp;x); v[x]=1; } dfs(1); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P4387【深基15.习9】验证栈序列","date":"2020-06-21T08:27:48.000Z","path":"posts/b494a7bf.html","text":"#include&lt;bits/stdc++.h&gt; //一直push，直到匹配到一个pop /* 栗子： 1 2 3 4 5 5 4 3 2 1 用一个栈模拟，一直入队直到当前入队的是出栈队列的第一项 出栈，继续模拟 */ using namespace std; #define ll long long #define inf 0x7fffffff int s[200020],ss; int a[100020]; int n; signed main() { int T; scanf(\"%d\",&amp;T); while(T--) { ss=0; memset(s,0,sizeof(s)); scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)scanf(\"%d\",&amp;a[i]); for(int i=0,j=0;j&lt;n;j++) { int x; scanf(\"%d\",&amp;x); while(i&lt;n&amp;&amp;(s[ss]!=x)) { s[++ss]=a[i++]; } if(s[ss]==x) { ss--; } } puts(ss&gt;0?\"No\":\"Yes\"); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P5250【深基17.例5】木材仓库","date":"2020-06-21T07:22:54.000Z","path":"posts/9462a6a7.html","text":"水一发板子题 合理使用map和c++11 auto类型可以自动识别，在c++11下，可以节省很多代码 这里用auto代替了iterator #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff signed main() { map &lt;string,int&gt; mp; int n; cin&gt;&gt;n; while(n--) { int opt; cin&gt;&gt;opt; if(opt==1) { string name; int sc; cin&gt;&gt;name&gt;&gt;sc; mp[name]=sc; cout&lt;&lt;\"OK\"&lt;&lt;endl; }else if(opt!=4) { string name; cin&gt;&gt;name; auto it=mp.find(name); if(opt==2) { if(it!=mp.end()) { cout&lt;&lt;mp[name]&lt;&lt;endl; }else { cout&lt;&lt;\"Not found\"&lt;&lt;endl; } }else if(opt==3) { if(it!=mp.end()) { mp.erase(name); cout&lt;&lt;\"Deleted successfully\"&lt;&lt;endl; }else { cout&lt;&lt;\"Not found\"&lt;&lt;endl; } } }else cout&lt;&lt;mp.size()&lt;&lt;endl; } return 0; } //c++11 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"如何安全的举报自己的学校？","date":"2020-05-21T13:39:08.000Z","path":"posts/ada246ea.html","text":"蒟蒻开学了emm 今天教教大家两种安全举报学校的方法 法1 首先，找到你所在省/市的教育主管部门 由于咱们是山东人，所以找到山东省教育厅:http://edu.shandong.gov.cn/ 重点，什么信访条例，什么匿名不公开，全部是假的，举报不能留下任何个人身份信息，包括自己的ip地址 接下来，连接到VPN 是的，根据前人的惨痛教训你的IP可能会被卖掉 这边奉上百度第一条https://www.xicidaili.com/nn/ 最好是高匿代理，国内外都可 注意，有很多代理简直上不了网，可以多试几个，另外不要输入敏感信息，因为你所有联网的数据都会发送给代理服务器，最好退掉微信QQ啥的，搞完之后一定断开代理 连接方法： PC：https://jingyan.baidu.com/article/6fb756ec5f5dd4241858fb85.html 手机：https://jingyan.baidu.com/article/6fb756ec5f5dd4241858fb85.html 填写信息 这边山东省教育厅需要点击“留言咨询” 姓名瞎编，手机号和邮箱一定要使用临时的 这边有一篇推荐临时邮箱的文章：https://www.jianshu.com/p/adc971eb5cfe https://temp-mail.org/ 这个我觉得速度还行，其他的要么时间短，要么上不去 临时手机号来这里：https://www.materialtools.com/ 证件的话，如果必须填真实的，不要写你自己或者家人，最好找一个和你们学校和你关系不大的人，当然，搞个假的最好 剩下的大家随意发挥，切记不要留下任何真实信息（除了举报内容 本方法有一定暴露风险~不过应该不大，我觉得防护措施已经足够严密了2333 小心内鬼 法2 写封信不就完了 不要留下真实信息，直接寄到教育局，谁都查不出来hhhh document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"CF1178D Prime Graph","date":"2020-05-21T13:38:00.000Z","path":"posts/2a07be94.html","text":"/* 显然1000以内，n到3/2n中肯定有一个质数（没有证明，但是可以枚举试试 所以 先把n个点连成环，在中间两点之间加边，每个点的度为2或3，控制边数是个质数就可以 */ #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff bool Prime(int x) { for(int i=2;i&lt;=sqrt(x);i++) { if(x%i==0)return 0; } return 1; } signed main() { int n; cin&gt;&gt;n; int m=n; while(!Prime(m)) { m++; } cout&lt;&lt;m&lt;&lt;endl; for(int i=1;i&lt;=n;i++) { int x=i+1; if(x&gt;n)x=1; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;x&lt;&lt;endl; } for(int i=1;i&lt;=m-n;i++) { cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;n/2+i&lt;&lt;endl; } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"CF1220D Alex and Julian","date":"2020-05-19T12:49:46.000Z","path":"posts/ed89373b.html","text":"前置知识：二分图的判定 没有奇环 做法 考虑从0开始，lcm(a,b)lcm(a,b)lcm(a,b)构成的环为奇环 lcm(a,b)a+lcm(a,b)b≡1(mod2)\\frac { lcm(a,b)} { a }+\\frac{ lcm ( a,b ) } { b} \\equiv 1(mod 2) alcm(a,b)​+blcm(a,b)​≡1(mod2) 有 a+bgcd(a,b)≡1(mod2)\\frac{a+b}{gcd(a,b)} \\equiv 1(mod 2) gcd(a,b)a+b​≡1(mod2) 当且仅当a,b中2的因子个数相等时，ab无法构成奇环，这种情况下agcd(a,b)\\frac{a}{gcd(a,b)}gcd(a,b)a​和bgcd(a,b)\\frac{b}{gcd(a,b)}gcd(a,b)b​都是奇数 （本句话引自lg大佬，不会可以手动验证，好好想，蒟蒻数学这么差都想通了，画画图） 也就是说，对于任意两个数字，如果他们的lowbit相等，他们不会构成奇环 于是问题变成了 求n个数中lowbit相等的数字最多有多少个 code: #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff int n; #define maxn 200009 ll a[maxn]; #define lowbit(x) (x&amp;(-x)) vector&lt;ll&gt; num[69]; signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;a[i]); } //两个数lowbit相同就可以保留 //直接枚举lowbit？ int ans=0,w; for(int i=0;i&lt;=60;i++) { int s=0; for(int j=1;j&lt;=n;j++) { //cout&lt;&lt;lowbit(a[j])&lt;&lt;\" \"&lt;&lt;(1&lt;&lt;i)&lt;&lt;endl; if(lowbit(a[j])==(1ll&lt;&lt;i)) { s++; }else { num[i].push_back(a[j]); } } if(s&gt;ans) { w=i,ans=s; } } printf(\"%d\\n\",n-ans); for(int i=0;i&lt;num[w].size();i++) { printf(\"%lld\\n\",num[w][i]); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P6275 [USACO20OPEN]Sprinklers 2: Return of the Alfalfa P ","date":"2020-05-12T13:41:15.000Z","path":"posts/5f2781ba.html","text":"//轮廓线dp /* 发现A、C作物之间一定有一条分割线， 分割线的拐角处必须放灌溉器，剩下位置可以不放 但是如果要放，放的灌溉器种类是一定的 dp合法轮廓线的数量 设每一条轮廓线的权值是-2^拐角数量 每一次转移，如果拐弯了就要除以二 */ #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff #define maxn 2009 #define int ll int n; char c[maxn][maxn]; #define mod 1000000007 #define inv (500000004) int f[maxn][maxn];//f表示横着来的 //有什么方法可以转移到f[i][j]? /* f[i][j-1]-&gt;f[i][j] g[i][j-1]/2-&gt;f[i][j] f[i-1][j]/2-&gt;g[i][j] g[i-1][j]-&gt;g[i][j] */ int g[maxn][maxn];//g表示竖着来的 ll ksm(int a,int b) { ll ans=1,base=a; while(b) { if(b&amp;1) { ans*=base; ans%=mod; } base*=base; base%=mod; } return ans; } signed main() { scanf(\"%lld\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%s\",c[i]+1); } for(int i=1;i&lt;=n+1;i++) { f[1][i]=1; g[i][1]=1; } for(int i=2;i&lt;=n+1;i++)//i可以取到n+1 { for(int j=2;j&lt;=n+1;j++) { f[i][j]=f[i][j-1]; if(c[i-1][j-1]!='W')//这边ij从1开始，所以要减一 { f[i][j]=(f[i][j]+(ll)g[i][j-1]*inv)%mod; } g[i][j]=g[i-1][j]; if(c[i-1][j-1]!='W') { g[i][j]=(g[i][j]+(ll)f[i-1][j]*inv)%mod; } // cout&lt;&lt;f[i][j]&lt;&lt;\" \"&lt;&lt;g[i][j]&lt;&lt;endl; } } int ans=(g[n+1][n+1]+f[n+1][n+1])%mod; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(c[i][j]!='W') { ans=(ans*2)%mod; } } } printf(\"%lld\\n\",ans); return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"母亲节快乐！","date":"2020-05-10T14:32:34.000Z","path":"posts/c20ab536.html","text":"1.妈妈 你把心铺成路，还怕我磕了脚 2 感谢你不是超人，却为我变成了万能 3 岁月从不败我的美人妈妈 ️ 4 小棉袄会努力成为你的防弹衣 5 你说你是妈妈的防弹衣，后来才知道你是妈妈的催泪弹 6 别问你妈想要什么礼物，她就是想要我这样的女婿(儿媳妇） 7 听说神不能无处不在，所以创造了妈妈 8 我加倍努力，就是希望成长的脚步，可以赶上您老去的速度 9 曾厌恶你的市侩圆滑，却忘了你也曾松花酿酒，春水煮茶 10 从前的愿望是仗剑走天涯，现在只想赖在你身边，听你细数年华 11 整个世界都在催我长大，而你却心疼我的小翅膀 12 羡慕我爸，娶到了世界上最好的女人 13 和妈妈吵架的时候，摸摸自己肚子的肉，那是妈妈在外面赚钱养的。 14 这个世界上只有你，愿意包容我的一千种任性。 15 我快快长大，你慢慢变老ᵀᴴᴱ ᴮᴱˢᵀ ᴵˢ ᶠᴼᴿ ᵞᴼᵁ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P3258","date":"2020-05-07T07:24:38.000Z","path":"posts/b173244f.html","text":"树剖裸题啦 每走一次路径+1 最后一个房间答案-1 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define inf 0x7fffffff #define maxn 300005 int fa[maxn],son[maxn],top[maxn],pos[maxn],dfn[maxn],size[maxn],dep[maxn]; vector&lt;int&gt; e[maxn]; int cnt=0; int n; int a[maxn]; struct node{ int l,r; int mark; int val; }tr[maxn*4]; void dfs(int x) { size[x]=1; for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i]; if(!size[to]) { dep[to]=dep[x]+1; fa[to]=x; dfs(to); size[x]+=size[to]; if(size[son[x]]&lt;size[to]) { son[x]=to; } } } } void dfs2(int x,int tp) { cnt++; pos[x]=cnt; dfn[cnt]=x; top[x]=tp; if(son[x]!=0)dfs2(son[x],tp); for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i]; if(top[to])continue; dfs2(to,to); } } void Build(int x,int l,int r) { tr[x].l=l,tr[x].r=r; if(l==r) { tr[x].mark=0; tr[x].val=0; return; } int mid=(l+r)&gt;&gt;1; Build(x*2,l,mid); Build(x*2+1,mid+1,r); tr[x].mark=0; tr[x].val=0; } void relese(int x) { if(tr[x].l==tr[x].r||0==tr[x].mark) { return; } int ma=tr[x].mark; int ls=x*2,rs=x*2+1; int lsl=tr[ls].r-tr[ls].l+1; int rsl=tr[rs].r-tr[rs].l+1; tr[ls].val+=lsl*ma; tr[ls].mark+=ma; tr[rs].mark+=ma; tr[rs].val+=rsl*ma; tr[x].mark=0; } void Add(int x,int l,int r,int val) { if(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r) { tr[x].val+=val*(tr[x].r-tr[x].l+1); tr[x].mark+=val; return; } relese(x); int mid=(tr[x].l+tr[x].r)&gt;&gt;1; if(l&lt;=mid)Add(x*2,l,r,val); if(r&gt;mid)Add(x*2+1,l,r,val); tr[x].val=tr[x*2].val+tr[x*2+1].val; } void L_Add(int x,int y) { while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]])swap(x,y); // cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;\" \"&lt;&lt;dep[top[x]]&lt;&lt;\" \"&lt;&lt;dep[top[y]]&lt;&lt;endl; Add(1,pos[top[x]],pos[x],1); x=fa[top[x]]; } if(pos[x]&gt;pos[y])swap(x,y); Add(1,pos[x],pos[y],1); } int Query(int x,int p)//单点查询 { if(tr[x].l==tr[x].r) { return tr[x].val; } relese(x); int mid=(tr[x].l+tr[x].r)&gt;&gt;1; if(p&lt;=mid)return Query(x*2,p); else return Query(x*2+1,p); } signed main() { scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); } for(int i=1;i&lt;n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); e[x].push_back(y); e[y].push_back(x); } dep[1]=1; dfs(1); dfs2(1,1); Build(1,1,n); for(int i=2;i&lt;=n;i++) { L_Add(a[i-1],a[i]); if(2!=i)Add(1,pos[a[i-1]],pos[a[i-1]],-1); // cout&lt;&lt;a[i-1]&lt;&lt;\" \"&lt;&lt;a[i]&lt;&lt;endl; } Add(1,pos[a[n]],pos[a[n]],-1); for(int j=1;j&lt;=n;j++) { printf(\"%d\\n\",Query(1,pos[j])); } return 0; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"Hello World","date":"2020-05-02T10:12:05.890Z","path":"posts/4a17b156.html","text":"啊这里是lzy lzy是一个正在初中挣扎的蒟蒻 QAQ 信竞和文化课都好难嘤嘤嘤 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]}]