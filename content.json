[{"title":"P2774 方格取数问题","date":"2020-08-20T10:06:05.000Z","path":"2020/08/20/P2774-方格取数问题/","text":"给定n*m的网格，要选择四个方向不相邻的数字，使得结果最大 我们转化题目 要求构造这样的结构： 能表示n个点 不选择一个数的代价为 $ a[i][j]$ 要么能反悔，要么选择出来就是最优解 显然容易想到网络流 建立一个二分图， 源点连向横纵坐标之和为奇数的格子，权值为$a[i][j]$ 汇点连向横纵坐标之和为偶数的格子，权值为$a[i][j]$ 两边的格子连双向边，权值为inf,表示中间这些边不能被割断 对这个图求最小割，割掉一条边表示不选择这个点，代价为 $a[i][j]$ 最终状态图不联通，即没有选择相邻的点 用所有点权总和减去最小割即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=0x7fffffff;typedef long long ll;#define maxn 400009struct node{ int to; int val; int rev;};vector&lt;node&gt; e[maxn];int n,m;int S,T;#define pos(i,j) (m*i+j)int d[maxn];void add(int x,int y,int z){ e[x].push_back((node){y,z,e[y].size()}); e[y].push_back((node){x,0,e[x].size()-1});}bool bfs(){ memset(d,-1,sizeof(d)); queue&lt;int&gt; q; q.push(S); d[S]=0; while(!q.empty()) { int now=q.front(); q.pop(); for(int i=0;i&lt;e[now].size();i++) { int to=e[now][i].to; if(d[to]==-1&amp;&amp;e[now][i].val) { q.push(to); d[to]=d[now]+1; } } } if(d[T]==-1)return 0; return 1;}int dfs(int x,int low){ if(x==T||low==0)return low; int totflow=0; for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i].to; int rev=e[x][i].rev; int val=e[x][i].val; if(d[to]==d[x]+1&amp;&amp;val) { int a=dfs(to,min(low,val)); e[x][i].val-=a; totflow+=a; e[to][rev].val+=a; low-=a; if(low==0)return totflow; } } if(low)d[x]=-1; return totflow;}int gi[4]={0,1,0,-1};int gj[4]={1,0,-1,0};signed main(){ scanf(\"%d%d\",&amp;n,&amp;m); S=0,T=pos(n,m)+2; int ans=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { int x; scanf(\"%d\",&amp;x); ans+=x; if((i+j)&amp;1) { add(S,pos(i,j),x);//奇数 for(int k=0;k&lt;4;k++) { int ni=i+gi[k]; int nj=j+gj[k]; if(ni&gt;=1&amp;&amp;nj&gt;=1&amp;&amp;ni&lt;=n&amp;&amp;nj&lt;=m) { // add(pos(ni,nj),pos(i,j),inf); add(pos(i,j),pos(ni,nj),inf); } } } else { add(pos(i,j),T,x); } } } while(bfs()) { ans-=dfs(S,inf); } printf(\"%d\\n\",ans); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"网络流","slug":"网络流","permalink":"https://lzylzy.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"P2172 [国家集训队]部落战争","date":"2020-08-18T04:06:52.000Z","path":"2020/08/18/P2172-国家集训队-部落战争/","text":"二分图的最小边覆盖定义：用最少的边覆盖整个子图的边的数量求法：n-最大匹配本题具体做法每个点拆为两个点，入点和出点 入点出点不连边，入点向能到达的所有点的出点连边 所有入点连向源点，所有出点连向汇点 发现这是一个二分图 为什么入点出点不连边？ 入点连向了源点，出点连向了汇点，再把入点出点连起来就全通了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=0x7fffffff;typedef long long ll;#define maxn 100069 int d[maxn];int m,n,r,c;int S,T;struct node{ int to; int val; int rev;};vector&lt;node&gt; e[maxn];void add(int x,int y,int v){ e[x].push_back((node){y,v,e[y].size()}); e[y].push_back((node){x,0,e[x].size()-1});}int ans=0;bool bfs(){ memset(d,-1,sizeof(d)); d[S]=0; queue&lt;int&gt; q; q.push(S); while(!q.empty()) { int x=q.front(); q.pop(); for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i].to; if(d[to]==-1&amp;&amp;e[x][i].val) { d[to]=d[x]+1; q.push(to); } } } if(d[T]==-1)return 0; return 1;}int dfs(int x,int low){ if(x==T||low==0)return low; int totflow=0; for(int i=0;i&lt;e[x].size();i++) { int y=e[x][i].to; int rev=e[x][i].rev; if(d[y]==d[x]+1&amp;&amp;e[x][i].val) { int a=dfs(y,min(e[x][i].val,low)); e[x][i].val-=a; e[y][rev].val+=a; low-=a; totflow+=a;; if(low==0)return totflow; } } if(low!=0) { d[x]=-1; } return totflow;}void dinic(){ while(bfs()) { ans+=dfs(S,inf); }}signed main(){ scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;r,&amp;c); char ch[99][99]; int gox[4]={r,c,r,c}; int goy[4]={c,r,-c,-r}; for(int i=1;i&lt;=n;i++) { scanf(\"%s\",ch[i]+1); } S=0,T=n*m+n*m+m+9; int sum=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { if(ch[i][j]=='.')//这是一个正常的点 { add(S,i*m+j,1);//源点到入点 add(i*m+j+n*m,T,1);//出点到汇点 for(int k=0;k&lt;4;k++) { int ni=i+gox[k]; int nj=j+goy[k]; if(ni&gt;0&amp;&amp;nj&gt;0&amp;&amp;nj&lt;=m&amp;&amp;ni&lt;=n&amp;&amp;ch[ni][nj]=='.') { add(i*m+j,ni*m+nj+n*m,inf);//入点到其他出点 } } }else sum++; } } int ans=0; while(bfs()) { ans+=dfs(S,inf); } printf(\"%d\\n\",n*m-ans-sum); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"},{"name":"网络流","slug":"网络流","permalink":"https://lzylzy.cf/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"几个在线画图工具","date":"2020-08-16T09:39:55.000Z","path":"2020/08/16/几个在线画图工具/","text":"一、黑色背景绿色字体……https://www.ddosi.com/hs/index.html 二、https://www.desmos.com/calculator 三、访问稍稍有点慢……https://www.geogebra.org/classic document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"NOIP 2018 提高组初赛试题 题目-答案-简要解析","date":"2020-08-16T09:33:51.000Z","path":"2020/08/16/NOIP 2018 提高组初赛试题 题目-答案-简要解析/","text":"一、单项选择题（共 10 题，每题 2 分，共计 20 分； 每题有且仅有一个正确选项）\\1. 下列四个不同进制的数中，与其它三项数值上不相等的是（ ）。 A. (269) 16 B. (617) 10 C. (1151) 8 D. (1001101011) 2 答案：D 解析：进制转换，把所有的选项都转换成相同的进制即可。至于转成几进制，看个人喜好 \\2. 下列属于解释执行的程序设计语言是（ ）。 A. C B. C++ C. Pascal D. Python 答案：D 解析：可以理解为：需要编译的就是非解释性语言。本人印象最深的解释型语言是Java，有什么错写完一句就报出来。 C,C++,pascal都是需要编译的语言，就是非解释性语言 而python是交互式的，也是解释性语言 \\3. 中国计算机学会于（ ）年创办全国青少年计算机程序设计竞赛。 A. 1983 B. 1984 C. 1985 D. 1986 答案：B 解析：？？？我也不知道 \\4. 设根节点深度为 0，一棵深度为 h 的满 k（k&gt;1）叉树，即除最后一层无任何 子节点外，每一层上的所有结点都有 k 个子结点的树，共有（ ）个结点。 A. (k^{h+1}-1)/(k-1)(kh+1−1)/(k−1) B. k^{h-1}kh−1 C. k^hkh D. (k^{h-1})/(k-1)(kh−1)/(k−1) 答案：A 解析：等比数列求和。我是蒟蒻不会？多画两棵树自己试（逃 \\5. 设某算法的时间复杂度函数的递推方程是 T(n) = T(n - 1) + n（n 为正整数） 及 T(0) = 1，则该算法的时间复杂度为（ ）。 A. O(log n) B. O(n log n) C. O(n) D. O(n^2) 答案：D 解析： NOIP初赛中的时间复杂度分析题就是授人以鱼，考人以鱽鱾鲀鱿鲃鲂鲉鲌鲄鲆鲅鲇鲏鲊鲋鲐鲈鲍鲎鲝鲘鲙鲗鲓鲖鲞鲛鲒鲚鲜鲟鲔鲕鲑鲧鲬鲪鲫鲩鲣鲨鲡鲢鲤鲠鲥鲦鲺鲯鲹鲴鲶鲳鲮鲭鲵鲲鲰鲱鲻鲷鲸鳋鳊鳁鳀鲾鲼鳈鳉鳃鳄鲿鳇鳂鳆鳅鲽鳌鳒鳎鳏鳑鳐鳍鳘鳛鳕鳓鳙鳗鳚鳔鳖鳜鳟鳞鳝鳡鳠鳢鳣鳤。 引自洛谷日报（逃 求和……要把式子展开，变成 1+1+2+3+…+(n-1)+n=1+n*(n+1)/2然后忽略常数复杂度总和变成n^2 A. a d b c - B. - a d b c C. a d - b c D. - a d b c 答案：B 解析：先建一棵表达式树，先序遍历就是前缀表达式 \\7. 在一条长度为 1 的线段上随机取两个点，则以这两个点为端点的线段的期望 长度是（ ）。 A. 1 / 2 B. 1 / 3 C. 2 / 3 D. 3 / 5 答案：B 解析：全靠猜 我们设这个区间[l,r]l=0,因题目0&lt;r&lt;1 0-r长度的期望为1/2，显然l-r的期望会比0-r小……所以就是1/3了（ \\8. 关于 Catalan 数 Cn = (2n)! / (n + 1)! / n！，下列说法中错误的是（ ）。 A. Cn 表示有 n + 1 个结点的不同形态的二叉树的个数。 B. Cn 表示含 n 对括号的合法括号序列的个数。 C. Cn 表示长度为 n 的入栈序列对应的合法出栈序列个数。 D. Cn 表示通过连接顶点而将 n + 2 边的凸多边形分成三角形的方法个数。 答案：A 解析：基本知识？反正我不会QwQ 找个数带进去就行 \\9. 假设一台抽奖机中有红、蓝两色的球，任意时刻按下抽奖按钮，都会等概率 获得红球或蓝球之一。有足够多的人每人都用这台抽奖机抽奖，假如他们的 策略均为：抽中蓝球则继续抽球，抽中红球则停止。最后每个人都把自己获 得的所有球放到一个大箱子里，最终大箱子里的红球与蓝球的比例接近于 （ ）。 A. 1 : 2 B. 2 : 1 C. 1 : 3 D. 1 : 1 答案：D 解析：算出每一轮拿到红球的期望为1，拿到蓝球必定1个，所以比例会接近1:1 \\10. 为了统计一个非负整数的二进制形式中 1 的个数，代码如下： int CountBit(int x) { int ret = 0; while (x) { ret++; ____; } return ret; } 则空格内要填入的语句是（ ）。 A. x &gt;&gt;= 1 B. x &amp;= x - 1 C. x |= x &gt;&gt; 1 D. x &lt;&lt;= 1 答案：B 解析：排除法+手算 二 、 不定 项选择题（共 5 题，每题 2 分，共计 10 分 ；每题有一个或多个正确选项，多选或少选均不得分 ） \\1. NOIP 初赛中，选手可以带入考场的有（ ）。 A. 笔 B. 橡皮 C. 手机（关机） D. 草稿纸 答案：AB 解析：凭感觉 \\2. 2-3 树是一种特殊的树，它满足两个条件： （1）每个内部结点有两个或三个子结点； （2）所有的叶结点到根的路径长度相同。 如果一棵 2-3 树有 10 个叶结点，那么它可能有（ ）个非叶结点。 A. 5 B. 6 C. 7 D. 8 答案：CD 解析：自己构造树 \\3. 下列关于最短路算法的说法正确的有（ ）。 A. 当图中不存在负权回路但是存在负权边时，Dijkstra 算法不一定能求出源 点到所有点的最短路。 B. 当图中不存在负权边时，调用多次 Dijkstra 算法能求出每对顶点间最短路 径。 C. 图中存在负权回路时，调用一次 Dijkstra 算法也一定能求出源点到所有点 的最短路。 D. 当图中不存在负权边时，调用一次 Dijkstra 算法不能用于每对顶点间最短 路计算。 答案：ABD 解析：dijstra算法不适用于负权图，而且它用于求单点到其他点的最短路 \\4. 下列说法中，是树的性质的有（ ）。 A. 无环 B. 任意两个结点之间有且只有一条简单路径 C. 有且只有一个简单环 D. 边的数目恰是顶点数目减 1 答案：ABD 解析：树的基本知识 \\5. 下列关于图灵奖的说法中，正确的有（ ）。 A. 图灵奖是由电气和电子工程师协会（IEEE）设立的。 B. 目前获得该奖项的华人学者只有姚期智教授一人。 C. 其名称取自计算机科学的先驱、英国科学家艾伦·麦席森·图灵。 D. 它是计算机界最负盛名、最崇高的一个奖项，有“计算机界的诺贝尔奖” 之称。 答案：BCD 解析：你觉得A能对吗 -—————————— 二、问题求解（每题5分，共10分）1. 甲乙丙丁四人在考虑周末要不要外出郊游。 已知①如果周末下雨，并且乙不去，则甲一定不去；②如果乙去，则丁一定去；③如果丙去，则丁一定不去；④如果丁不去，而且甲不去，则丙一定不去。如果周末丙去了，则甲_（去了/没去）(1分)，乙_（去了/没去）(1分)，丁_（去了/没去）(1分)，周末_（下雨/没下雨）(2分)。 答案：去了，没去，没去，没下雨 解析：送分题，根据条件判断即可 2. 方程 ab =(a or b) (a and b)，在a, b都取[0、31]中的整数时，共有__组解。（*表示乘法；or表示按位或运算；and表示按位与运算） 解析：使得a|b== max(a,b),a&amp;b == min(a,b) 显然，a，b存在子集关系时上面的式子才能成立。 例如：1011|1001=1011=max(1011,1001) 可以自己举例验证QwQ 我们设b是a的子集，枚举a在二进制下有多少个1，即从5里面取i个1，i从0到5。每个i都是一个C(5, i) 接着枚举子集，有2^i中方案（每一个1都看看放还是不放） C(5,0)2^0 +C(5,1)2^1+…+C(5,5)*2^5 = 11 + 52 + 104 + 108 + 516 + 132 = 243 最后，由于我们限制了a&gt;b，所以答案要*2 但是a==b的情况会被多算，所以答案减去32 最后结果：2*243 – 32 = 452 四、阅读程序写结果（共 4 题，每题8 分，共计 32 分）1. 12345678910111213141516171819202122232425\\#includeint main() {int x;scanf(\"%d\", &amp;x);int res = 0;for (int i = 0; i &lt; x; ++i) { if (i * i % x == 1) {​ ++res; }}printf(\"%d\", res);return 0;} 输入：15 输出：4 解析：简单模拟 2. 1234567891011121314151617181920212223242526272829303132333435363738394041\\#includeint n, d[100];bool v[100];int main() {scanf(\"%d\", &amp;n);for (int i = 0; i &lt; n; ++i) { scanf(\"%d\", d + i); v[i] = false;}int cnt = 0;for (int i = 0; i &lt; n; ++i) { if (!v[i]) {​ for (int j = i; !v[j]; j = d[j]) {​ v[j] = true;​ }​ ++cnt; }}printf(\"%d\\n\", cnt);return 0;} 输入：10 7 1 4 3 2 5 9 8 0 6 输出：6 解析：继续模拟（逃 3. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263\\#includeusing namespace std;string s;long longmagic(int l, int r) {long long ans = 0;for (int i = l; i &lt;= r; ++i) { ans = ans * 4 + s[i] - 'a' + 1;}return ans;}int main() {cin &gt;&gt; s;int len = s.length();int ans = 0;for (int l1 = 0; l1 &lt; len; ++l1) { for (int r1 = l1; r1 &lt; len; ++r1) {​ bool bo = true;​ for (int l2 = 0; l2 &lt; len; ++l2) {​ for (int r2 = l2; r2 &lt; len; ++r2) {​ if (magic(l1, r1) == magic(l2, r2)&amp;&amp; (l1 != l2 || r1 != r2)) {​ bo = false;​ }​ }​ }​ if (bo) {​ ans += 1;​ } }}cout &lt;&lt; ans &lt;&lt; endl;return 0;} 输入：abacaba 输出：16 解析：magic(l,r)是l-r的hash，枚举两个子串，答案就是不重复出现的子串个数，手动枚举。 4. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697\\#includeusing namespace std;const int N =110;bool isUse[N];int n, t;int a[N], b[N];bool isSmall() {for (int i = 1; i &lt;= n; ++i) if (a[i] != b[i]) return a[i] &lt; b[i];return false;}boolgetPermutation(int pos) {if (pos &gt; n) { return isSmall();}for (int i = 1; i &lt;= n; ++i) { if (!isUse[i]) {​ b[pos] = i; isUse[i] = true;​ if (getPermutation(pos + 1)) {​ return true;​ }​ isUse[i] = false; }}return false;}void getNext() { for (int i = 1; i &lt;= n; ++i) { isUse[i] = false; }getPermutation(1); for (int i = 1; i &lt;= n; ++i) { a[i] = b[i]; }}int main() { scanf(\"%d%d\", &amp;n, &amp;t); for (int i = 1; i &lt;= n; ++i) { scanf(\"%d\", &amp;a[i]); } for (int i = 1; i &lt;= t; ++i) { getNext(); } for (int i = 1; i &lt;= n; ++i) { printf(\"%d\", a[i]); if (i == n) putchar('\\n'); else putchar(''); }return 0;} 输入1：6 10 1 6 4 5 32 输出 1：2 1 3 5 6 4 (3 分) 输入2：6 200 1 5 3 4 26 输出 2：3 2 5 6 1 4 (5 分) 解析：这一大堆函数就是求这个排列的下一个……手算即可（当然如果你觉得200算不出来可以使用康托展开） 五、完善程序（共 2 题，每题 14 分，共计 28 分）\\1. 对于一个1到n的排列p(即1到n中每一个数在p中出现了恰好一次)，令qi为第i个位置之后第一个比pi值更大的位置，如果不存在这样的位置，则qi =n+1。 举例来说，如果n=5且p为1 5 4 2 3，则q为2 6 6 5 6。 下列程序读入了排列p，使用双向链表求解了答案。试补全程序。（第二空2分，其余3分） 数据范围 1 ≤ n ≤ 105。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051\\#includeusing namespace std;const int N =100010;int n;int L[N], R[N],a[N];int main() {cin &gt;&gt; n;for (int i = 1; i &lt;= n; ++i) { int x; cin &gt;&gt; x; a[x] = i ;}for (int i = 1; i &lt;= n; ++i) { R[i]= i + 1; L[i] = i - 1;}for (int i = 1; i &lt;= n; ++i) { L[ R[a[i]]] = L[a[i]]; R[L[a[i]]] = R[a[i] ];}for (int i = 1; i &lt;= n; ++i) { cout &lt;&lt; R[i]&lt;&lt; \" \";}cout &lt;&lt; endl;return 0;} 解析： 纯靠猜。1空发现没有直接读入，肯定有鬼……瞎猜一种方法就行 2空仿写下句…… 3,4空互相仿写…… 5空我们肯定要求这个数右边比他大的数的位置，所以输出R 当然我蒻看不懂，有心情研究的julao们可以再去找找…… \\2. 一只小猪要买 N 件物品(N 不超过 1000)。 它要买的所有物品在两家商店里都有卖。第 i 件物品在第一家商店的价格是 a[i]，在第二家商店的价格是 b[i]，两个价格都不小于 0 且不超过 10000。如果在第一家商店买的物品的总额不少于 50000，那么在第一家店买的物品都可以打 95 折（价格变为原来的 0.95 倍）。 求小猪买齐所有物品所需最少的总额。 输入：第一行一个数 N。接下来 N 行，每行两个数。第 i 行的两个数分别代表 a[i]，b[i]。 输出：输出一行一个数，表示最少需要的总额，保留两位小数。 试补全程序。（第一空 2 分，其余 3 分） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int Inf = 1000000000;const int threshold = 50000;const int maxn = 1000; int n, a[maxn], b[maxn];bool put_a[maxn];int total_a,total_b;double ans;intf[threshold]; int main() { //第一部分 scanf(\"%d\",&amp;n); total_a= total_b = 0; for(int i = 0; i &lt; n; ++i) { scanf(\"%d%d\",a + i, b + i); if(a[i] &lt;= b[i]) total_a += a[i]; elsetotal_b += b[i]; } ans =total_a + total_b; total_a= total_b = 0; for(int i = 0; i &lt; n; ++i) { if( (1) ) { put_a[i]= true; total_a+= a[i]; }else { put_a[i]= false; total_b+= b[i]; } } if ((2) ) { printf(\"%.2f\",total_a * 0.95 + total_b); return0; } //第二部分 f[0]= 0; for(int i = 1; i &lt; threshold; ++i) f[i]= Inf; inttotal_b_prefix = 0; for(int i = 0; i &lt; n; ++i) if (!put_a[i]) { total_b_prefix += b[i]; for (int j = threshold - 1; j &gt;= 0; --j) { if ( (3) &gt;= threshold &amp;&amp; f[j] != Inf) ans = min(ans, (total_a + j +a[i]) * 0.95+ (4) ); f[j] = min(f[j] + b[i], j &gt;= a[i] ? (5) :Inf); } } printf(\"%.2f\",ans); return0;} 解析： 代码分为两个部分。 第一部分是一个贪心，我们假设满足了优惠条件，按照折后价格进行贪心，如果结果满足了优惠条件就直接输出，此时如果放弃某些b商品来买a不会再有更优策略 第二部分是一个dp……策略就是把原先买了b的东西买a以获得折扣 f[i,j]表示前i个物品，在额外在A店花了j元的情况下，购买B店物品花费的最小值。i呢？想想你的01背包是怎么优化的。 3空是一个转移判断条件，tot_a+j+a[i]是在a店话费的总钱数（本来花的钱+前面改了的钱+当前物品价格） 4空表示在b商店买的物品总价， total_b + f[j] - total_b_prefix 5空更新，看看这个商品在a商店买还是b商店买 太毒瘤了QwQ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"如何手动开大系统栈?","date":"2020-08-16T09:32:23.000Z","path":"2020/08/16/如何手动开大系统栈/","text":"Dev-c++:手动开大系统栈，防止爆栈 在各大OJ上，系统栈都会开大，而在本地调试时，常用到云端下载的各种毒瘤数据，一不小心就可能在本机上爆掉系统栈，在oj上却没事。 Devc++：工具-&gt;编译选项-&gt;选择编译时加入以下命令-&gt;输入： 1-Wl,--stack=134217728 Dev-c++神奇操作，请看： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"安装完Dev-c++如何设置?Dev-c++神奇配置指北","date":"2020-08-16T09:29:21.000Z","path":"2020/08/16/安装完Dev-c++如何设置 Dev-c++神奇配置指北/","text":"安装完Dev-c++后，我们通常会根据自己的喜好调整设置，以下是个人的做法，欢迎参考。 1.字体字体在安装界面就可以更改。默认字体是consoles，个人喜欢下面的courier new 有些字体很奇怪，甚至根本不能显示。。。 2.符号补全位置：工具-&gt;编译器选项-&gt;代码补全-&gt;完成符号 建议把所有的都打开，当然可以根据习惯调整。 3.缺省源位置：工具-&gt;编译器选项-&gt;代码-&gt;缺省源 勾选“向项目初始源文件插入代码”，在下面一栏写入以下代码： 123456789#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffsigned main(){ return 0;} 解释：第一行万能头文件，不喜欢可以自己写别的 第二行不讲。。。 第三行的意思是当你写ll的时候系统就会认为你写了long long，比如你可以这么写： ll a=0; 第四行设置最大值，0x7fffffff是int的最大值，有的时候用的不好容易爆掉 最大值还有一个常用的0x3f3f3f3f,但我觉得这个太小了，用过一次被卡了。。。 signed main：signed就等于int，两者可以通用，为什么写signed呢？个人有一种习惯： #define int long long 这时main就会出编译错误。。。 根据喜好还可以加入freopen 这一步的作用是：每当你创建一个新文件，里面都会有这样一段代码，省去敲头文件的麻烦。 4.自动保存省去断电重写的麻烦QwQ 位置：工具-&gt;编译器选项-&gt;自动保存 先勾选“启动编译器自动保存”，然后选择间隔时间 个人喜欢两分钟一保存 下面的不用动 5.代码警告这是我用过最好的功能…… 当你写long long a;scanf(“%d“,&amp;a);的时候就会报警提示，省去很多不必要的麻烦 位置：工具-&gt;编译选项-&gt;代码生成/优化-&gt;代码警告 把第二个显示最多警告信息变成yes 6.手动开大系统栈在各大OJ上，系统栈都会开大，而在本地调试时，常用到云端下载的各种毒瘤数据，一不小心就可能在本机上爆掉系统栈，在oj上却没事。 目录：工具-&gt;编译选项-&gt;编译器 勾选 选择编译时加入以下命令，输入： 1-Wl,--stack=134217728 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P2290 [HNOI2004]树的计数","date":"2020-07-28T09:45:04.000Z","path":"2020/07/28/P2290-HNOI2004-树的计数/","text":"前置知识：prufer序列对于一颗无根树，可以生成一个唯一的长度为n-2的序列 转化1：从无根树到prefurprefu**r序列以下过程引用洛谷博客，格式可能错乱，可以自行百度或去原文章访问 https://www.cnblogs.com/chenxiaoran666/p/Luogu2290.html 如果你不想看了解那么多 可以跳转到 这道题需要的知识 部分 现在，给你一棵树，我们要考虑如何把它变成prefurprefu**r序列。 我们需要重复进行以下操作，直至树中只剩下两个点： 找到一个度数为1，且编号最小的点。（其中编号最小保证了后面将会提到的pruferprufe**r序列的唯一对应性，同时也方便从pruferprufe**r序列转化回无根树） 把这个点的父亲节点加入序列，然后把这个点从树中删除。 然后我们就得到了一个长度为n-2n−2的序列，这就是pruferprufe**r序列。 所以它有什么实际意义呢？ 我也不知道。 以上面的图为例，我们可以模拟这一过程如下： 找到4号节点，将其父结点加入序列，然后将其删去。此时序列：{2}{2}。 找到5号节点，将其父结点加入序列，然后将其删去。此时序列：{2,3}{2,3}。 找到3号节点，将其父结点加入序列，然后将其删去。此时序列：{2,3,1}{2,3,1}。 找到6号节点，将其父结点加入序列，然后将其删去。此时序列：{2,3,1,2}{2,3,1,2}。 找到2号节点，将其父结点加入序列，然后将其删去。此时序列：{2,3,1,2,1}{2,3,1,2,1}。 所以，最后得到的pruferprufe**r序列就是{2,3,1,2,1}{2,3,1,2,1}。 转化22：从pruferprufe**r序列到无根树还是以刚才那棵树为例吧，我们要考虑如何把它的prefurprefu**r序列变回它本身。 我们需要重复进行以下操作，直至点集中只剩下两个点：（初始化所有点都在点集中） 取出pruferprufe**r序列最前面的元素xx。 取出在点集中的、且当前不在pruferprufe**r序列中的最小元素yy。（这恰好呼应了前面提到过的选取编号最小的节点） 在x,yx,y之间连接一条边。（注意前面的取出相当于删除） 最后，我们在点集中剩下的两个点中连一条边。 显然这有n-1n−1条边，且绝对不会形成环，因此它是一棵树，且就是原树。 以上面的序列为例，我们可以模拟这一过程如下： 取出2,42,4连边。此时pruferprufe**r序列：{3,1,2,1}{3,1,2,1}，点集：{1,2,3,5,6,7}{1,2,3,5,6,7}。 取出3,53,5连边。此时pruferprufe**r序列：{1,2,1}{1,2,1}，点集：{1,2,3,6,7}{1,2,3,6,7}。 取出1,31,3连边。此时pruferprufe**r序列：{2,1}{2,1}，点集：{1,2,6,7}{1,2,6,7}。 取出2,62,6连边。此时pruferprufe**r序列：{1}{1}，点集：{1,2,7}{1,2,7}。 取出1,21,2连边。此时pruferprufe**r序列：{}{}，点集：{1,7}{1,7}。 最后再在1,71,7间连边，就可以得到原树了。 pruferprufe**r序列的性质及相关结论讲了这么多，我们最关键的还是pruferprufe**r序列的一些性质，以及与其有关的一些结论。（毕竟前面也提到过，我也不知道这东西有什么实际意义） 重要性质：prufer*p\\r*u*f*e\\r\\序列与无根树一一对应。** 这应该显然吧，通过前面的介绍应该可以直接得出。 而由这个性质，我们才能推导出后面的结论。 度数为d_i*d\\i*的节点会在prufer*p*r*u*f**e\\r\\序列中出现d_i-1*d*i\\−1次**。 当某个节点度数为11时，会直接被删掉，否则每少掉一个相邻的节点，它就会在序列中出现11次。 因此共出现d_i-1d**i−1次。 一个n*n*个节点的完全图的生成树个数为n^{n-2}*n\\n*−2。** 对于一个nn个点的无根树，它的pruferprufe**r序列长为n-2n−2，而每个位置有nn种可能性，因此可能的pruferprufe**r序列有n^{n-2}n**n−2种。 又由于pruferprufe**r序列与无根树一一对应，因此生成树个数应与pruferprufe**r序列种树相同，即n^{n-2}n**n−2。 对于给定度数为d_{1\\sim n}*d*1∼*n*的一棵无根树共有_ _$ \\frac{(n-2)!}{\\prod_{i=1}^n(d_i-1)!}∏*i*=1*n*(*d*i\\−1)!(*n*−2)! $ 种情况。 由上面的性质可以知道，度数为d_id**i的节点会在pruferprufe**r序列中出现d_i-1d**i−1次。 则就是要求出d_i-1d**i−1个i(1\\le i\\le n)i(1≤i≤n)的全排列个数。 而上面那个式子就是可重全排列公式。（即全排列个数除以重复元素内部的全排列个数） 大致就是这些。 ——引自洛谷UID28382的大佬的题解 解决这题需要知道的序列长度为n-2，每个数字出现度数-1次 解决问题问题转化为给a序列，生成由n个数组成的长度为n-2的序列 每个数字出现次数为a[i]-1次 求方案数 类似摆花那题 使用递推解决 预处理组合数+long long可以避免精度爆炸 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n; #define maxn 199int a[maxn];ll C[maxn][maxn]; signed main(){ scanf(\"%d\",&amp;n); int sum=0; if(n==1) { int x; scanf(\"%d\",&amp;x); if(x!=0)printf(\"0\\n\"); else printf(\"1\\n\"); return 0; } for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); if(a[i]==0) { printf(\"0\\n\"); return 0; } a[i]--; sum+=a[i]; } if(sum!=n-2) { printf(\"0\\n\"); return 0; } for(int i=0;i&lt;=n;i++) { C[i][0]=1; for(int j=1;j&lt;=i;j++) { C[i][j]=C[i-1][j]+C[i-1][j-1]; } } /* 问题转化为，生成长度为n-2的序列，每个数字出现a[i]-1次 求有多少种序列 */ ll ans=1; int y=n-2; for(int i=1;i&lt;=n;i++) { ans*=C[y][a[i]]; y-=a[i]; } printf(\"%lld\\n\",ans); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P6004 [USACO20JAN]Wormhole Sort S","date":"2020-07-28T09:41:14.000Z","path":"2020/07/28/P6004-USACO20JAN-Wormhole-Sort-S/","text":"从题目“最小宽度的最大值”看出二分答案 不是最小生成树 最小生成树求的是最小值 二分虫洞的最小宽度 每次check就把宽度大于等于x的边加入 对于所有$a[i]!=i$ 的奶牛 看看 $a[i]$ 和$i$在不在同一连通块内 在的话说明这个奶牛可以到达自己的位置 如果有一只不在的话就return false 使用并查集实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n,m;#define maxn 100009#define inf 0x7fffffffint a[maxn];struct node{ int a,b,w;}e[maxn];int fa[maxn];int Find(int x){ if(fa[x]==x)return x; return fa[x]=Find(fa[x]);}bool check(int x){ for(int i=1;i&lt;=n;i++) { fa[i]=i; } for(int i=1;i&lt;=m;i++) { if(e[i].w&gt;=x) { fa[Find(e[i].a)]=Find(e[i].b); } } for(int i=1;i&lt;=n;i++) { if(a[i]!=i) { if(Find(i)!=Find(a[i]))return 0; } } return 1;}signed main(){ scanf(\"%d%d\",&amp;n,&amp;m); bool ok=1; for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); if(a[i]!=i)ok=0; fa[i]=i; } if(ok) { printf(\"-1\\n\"); return 0; } int l=inf,r=-inf,ans; for(int i=1;i&lt;=m;i++) { scanf(\"%d%d%d\",&amp;e[i].a,&amp;e[i].b,&amp;e[i].w); r=max(r,e[i].w); l=min(l,e[i].w); } while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(check(mid)) { l=mid+1; ans=mid; }else { r=mid-1; } } printf(\"%d\\n\",ans); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1334 瑞瑞的木板","date":"2020-07-28T09:35:08.000Z","path":"2020/07/28/P1334-瑞瑞的木板/","text":"发现这题就是合并果子反过来 做法与合并果子相同，因为每次拆开的代价与合并果子中合并的代价其实相同 整个把顺序倒过来即可 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=0x7fffffff;typedef long long ll;priority_queue&lt;ll,vector&lt;ll&gt; ,greater&lt;ll&gt; &gt; q;#define maxn 20009ll n;ll a[maxn];int cmp(int a,int b){ return a&gt;b;}signed main(){ scanf(\"%lld\",&amp;n); ll s=0; for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;a[i]); q.push(a[i]); } int cnt=1; s=0; for(int i=1;i&lt;n;i++) { ll p1=q.top(),q2; q.pop(); q2=q.top(); q.pop(); q.push(p1+q2); s+=p1+q2; //cout&lt;&lt;p&lt;&lt;endl; } printf(\"%lld\\n\",s); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1194 买礼物","date":"2020-07-28T09:31:57.000Z","path":"2020/07/28/P1194-买礼物/","text":"kruscal板子题 把有优惠活动的两个商品之间连一条边，跑最小生成树 不用管没有连接上的就可以 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=0x7fffffff;typedef long long ll;int a,n;int m=0;struct node{ int x,y; int s;}e[500009];bool cmp(node a,node b){ return a.s&lt;b.s;}int fa[509];int Find(int x){ if(fa[x]==x)return x; return fa[x]=Find(fa[x]);}signed main(){ scanf(\"%d%d\",&amp;a,&amp;n); for(int i=1;i&lt;=n;i++)fa[i]=i; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { int x; scanf(\"%d\",&amp;x); if(j&lt;=i&amp;&amp;x&lt;a&amp;&amp;x!=0) { e[++m].y=j; e[m].x=i; e[m].s=x; } } } sort(e+1,e+1+m,cmp); ll ans=a*n; for(int i=1;i&lt;=m;i++) { int x=e[i].x,y=e[i].y; if(Find(x)!=Find(y)) { fa[Find(x)]=Find(y); ans=ans-a+e[i].s; } } printf(\"%lld\\n\",ans); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P6033 合并果子 加强版","date":"2020-07-28T09:28:06.000Z","path":"2020/07/28/P6033-合并果子-加强版/","text":"合并果子的加强版，扩大了数据范围 Subtask 1（10 points）：$1 \\leq n \\leq 8$。 Subtask 2（20 points）：$1 \\leq n \\leq 10^3$ Subtask 3（30 points）：$1 \\leq n \\leq 10^5$ Subtask 4（40 points）：$1 \\leq n \\leq 10^7$ 对于全部的测试点，保证$1 \\leq a_i \\leq 10^5。$ 由于n太大，复杂度必须为O(N) 发现a[i]不大，可以使用桶排 不能使用优先队列，改用数组模拟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll inf=10000000000000000;//小心inf #define maxn 10000009#define f(x) x=(x==0?inf:x) ll n;int t[100009];ll st1[maxn];ll st2[maxn];int h1=1,t1=0;int h2=1,t2=0;int read()//必须快读 { int x=0; char c=getchar(); while(c&lt;'0'||c&gt;'9') { c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { x=x*10+c-'0'; c=getchar(); } return x;}signed main(){ //freopen(\"h.in\",\"r\",stdin); n=read(); ll s=0; for(int i=1;i&lt;=n;i++)//通排 { t[read()]++; } for(int i=1;i&lt;=100000;i++) { while(t[i]--) { st1[++t1]=i; } } for(int i=1;i&lt;n;i++) { ll w=st1[h1]; ll x=st1[h1+1]; ll y=st2[h2]; ll z=st2[h2+1]; f(w);f(x);f(y);f(z); ll ans=0; if(w&lt;y)//第一个用w { ans+=w; h1++; if(x&lt;y) { h1++; ans+=x; }else { h2++; ans+=y; } }else { ans+=y; h2++; if(w&lt;z) { h1++; ans+=w; }else { h2++; ans+=z; } } s+=ans; st2[++t2]=ans; } printf(\"%lld\\n\",s); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1241 括号序列","date":"2020-07-24T04:08:52.000Z","path":"2020/07/24/P1241-括号序列/","text":"原题目：扫描一遍原序列，对每一个右括号，找到在它左边最靠近它的左括号匹配，如果没有就放弃。 翻译：扫描一遍原序列，当找到一个右括号（即找到一个 ‘ ) ‘ 或者 ‘ ] ‘ 时），以它为起点向左找，找到一个没被标记成功匹配的左括号（即找到一个 ‘ ( ‘ 或者 ‘ [ ‘ ），如果两者匹配的话，标记它们成功 牵手 匹配，如果不匹配，或者找不到左括号的话，不做任何标记。 原题目：在以这种方式把原序列匹配完成后，把剩下的未匹配的括号补全。 翻译：上面扫描一遍标记完成功匹配的括号之后，扫描一遍序列，对于标记过的括号，则直接输出；对于没有标记的括号，则补全成对输出 举例：如果有个 ‘ [ ‘ 或 ‘ ] ‘ 没被标记匹配，则输出 [ ] 如果还不理解的话，给个测试样例： 输入：( [ ) ] ) 输出：( [ ( ) ] ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;bool ck(char a,char b){ if(a=='('&amp;&amp;b==')')return 1; if(a=='['&amp;&amp;b==']')return 1; swap(a,b); if(a=='('&amp;&amp;b==')')return 1; if(a=='['&amp;&amp;b==']')return 1; return 0;}char ans[2590];int x=0;pair&lt;int,char&gt; adi[2590];int y=0;int cy=1;signed main(){ string a; cin&gt;&gt;a; stack&lt;char&gt; st; stack&lt;int&gt; pos; for(int i=0;i&lt;a.size();i++) { if(a[i]=='('||a[i]=='[') { st.push(a[i]); pos.push(x);//不能push i 因为中间插队的括号会导致位置错乱 }else { if(st.empty())//!!!!小心RE！ { if(a[i]==')')ans[++x]='('; else ans[++x]='['; ans[++x]=a[i];//小心WA~！ continue; } char p=st.top(); // cout&lt;&lt;\"CP:\"&lt;&lt;p&lt;&lt;\" \"&lt;&lt;a[i]&lt;&lt;endl; if(ck(p,a[i])) { st.pop(); pos.pop(); }else { if(a[i]==')')ans[++x]='('; else ans[++x]='['; } } ans[++x]=a[i]; } //cout&lt;&lt;x&lt;&lt;endl; while(!st.empty()) { char p=st.top(); int q=pos.top()+1; st.pop();pos.pop(); y++; adi[y].first=q; if(p=='(')adi[y].second=')'; else adi[y].second=']'; } if(y!=0)sort(adi+1,adi+1+y);//好像reverse就行 for(int i=1;i&lt;=x;i++) { cout&lt;&lt;ans[i]; if(y!=0&amp;&amp;adi[cy].first==i) { cout&lt;&lt;adi[cy].second; cy++; } } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P4913 【深基16.例3】二叉树深度","date":"2020-07-16T12:36:23.000Z","path":"2020/07/16/P4913-【深基16-例3】二叉树深度/","text":"可以建树之后进行dfs求出每个节点的深度找最大值 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffint n;#define maxn 1000009vector&lt;int&gt; son[maxn];int ans=-inf;void dfs(int now,int dep){ ans=max(ans,dep); for(int i=0;i&lt;son[now].size();i++) { dfs(son[now][i],dep+1); }}signed main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); if(x!=0) { son[i].push_back(x); } if(y!=0) { son[i].push_back(y); } } dfs(1,1); printf(\"%d\\n\",ans); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"code","slug":"code","permalink":"https://lzylzy.cf/tags/code/"}]},{"title":"P1102 A-B 数对","date":"2020-07-16T12:35:07.000Z","path":"2020/07/16/P1102-A-B-数对/","text":"12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffff//转化题目 //把数列从小到大排序，每次求ai+C出现了几次 //可以用upperbound-lowerbound实现 int a[200009];signed main(){ int n,c; scanf(\"%d%d\",&amp;n,&amp;c); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;a[i]); sort(a+1,a+1+n); ll ans=0; for(int i=1;i&lt;=n;i++) { ans+=upper_bound(a+1,a+1+n,a[i]+c)-lower_bound(a+1,a+1+n,a[i]+c); } printf(\"%lld\\n\",ans); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1918 保龄球 ","date":"2020-07-16T12:32:39.000Z","path":"2020/07/16/P1918-保龄球/","text":"大意是输入一个数组a 求x在a中出现的位置 可以用map映射int解决 或者是离散化 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffmap&lt;int,int&gt; mp; signed main(){ int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { int x; scanf(\"%d\",&amp;x); mp[x]=i; } int m; scanf(\"%d\",&amp;m); while(m--) { int x; scanf(\"%d\",&amp;x); printf(\"%d\\n\",mp.count(x)?mp[x]:0); } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1030 求先序排列","date":"2020-07-16T12:29:39.000Z","path":"2020/07/16/P1030-求先序排列/","text":"模拟了好一大通 QAQ 123456789101112131415161718192021222324252627/*先序遍历：根左右 中序遍历：左根右 后序遍历：左右根 可以直接求出根，在中序遍历里找出左右儿子，继续递归 */#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffstring s1,s2; void dfs(int l,int r,int l2,int r2)//对应s1,s2的哪个区间 { cout&lt;&lt;s2[r2];//s2最后一个直接是根 int pos=s1.find(s2[r2]);//找出根在s1里的位置 int sizel=pos-l; int sizer=r-l+1-1-sizel; if(sizel&gt;0)dfs(l,l+sizel-1,l2,l2+sizel-1); if(sizer&gt;0)dfs(l+sizel+1,r,l2+sizel,r2-1);}signed main(){ cin&gt;&gt;s1&gt;&gt;s2; int len=s1.size()-1; dfs(0,len,0,len); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1347 排序","date":"2020-07-14T11:29:39.000Z","path":"2020/07/14/P1347-排序/","text":"一道拓扑排序题，但是我不会 由于数据范围小得吓人，可以每读入一个关系就进行一遍topsort 如果发现条件不足就继续读入，矛盾或者遍历成功就直接结束 如果读入完了还是条件不足，那就是条件不足了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffint n,m;#define maxn 29int b[maxn][maxn];/*b[i][j]=1 i&gt;jb[i][j]=-1 i&lt;j*/vector&lt;int&gt; son[maxn],id[maxn];int inn[maxn],in[maxn];bool app[maxn];int cnt=0;int fa[maxn];int oo=inf;int vis[maxn];int Find(int x){ if(fa[x]==x)return x; return fa[x]=Find(fa[x]); }void topsort(int k){ memcpy(in,inn,sizeof(inn)); queue&lt;int&gt; q; int ns=inf; int res=1; for(int i=0;i&lt;26;i++) { if(in[i]==0&amp;&amp;app[i]) { if(ns!=inf) { res=0;//条件不足 } q.push(i); ns=i; } } if(ns==inf)//有矛盾 { res=-1; } queue&lt;int&gt; ans; while(!q.empty()) { int x=q.front(); q.pop(); ans.push(x); //cout&lt;&lt;x&lt;&lt;endl; if(ans.size()==n&amp;&amp;res==1)//全部入队 { printf(\"Sorted sequence determined after %d relations: \",k); while(!ans.empty()) { putchar((char)(ans.front()+'A')); ans.pop(); } putchar('.'); exit(0); } bool p=0; for(int i=0;i&lt;son[x].size();i++) { int to=son[x][i]; in[to]--; if(in[to]==0) { q.push(to); if(p)res=0;//条件不足 p=1; } } } if(ans.size()!=cnt||res==-1)//没能遍历当前的图 说明有环 { printf(\"Inconsistency found after %d relations.\",k); exit(0); } else return;}signed main(){ scanf(\"%d%d\",&amp;n,&amp;m); int s=inf; for(int i=0;i&lt;26;i++)fa[i]=i; for(int i=1;i&lt;=m;i++) { char a[4]; scanf(\"%s\",a); int x=a[0]-'A',y=a[2]-'A'; cnt+=(!app[x])+(!app[y]); app[x]=1,app[y]=1; s=min(s,min(x,y)); fa[Find(x)]=Find(y); if(x==y)//自环 { printf(\"Inconsistency found after %d relations.\\n\",i); return 0; } if(b[x][y]==0) { b[x][y]=-1; b[y][x]=1; son[x].push_back(y); id[x].push_back(i); inn[y]++; }else if(b[x][y]==-1)//重边 { continue; }else//矛盾 { printf(\"Inconsistency found after %d relations.\\n\",i); return 0; } topsort(i); } printf(\"Sorted sequence cannot be determined.\\n\"); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P1127 词链","date":"2020-07-13T10:32:41.000Z","path":"2020/07/13/P1127-词链/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffint n;#define maxn 1009string x[maxn];vector&lt;int&gt; son[maxn],num[maxn];int h[maxn];//出现次数 int t[maxn];//作为首次出现的 入度比出度大1 //要是找不到 就按照第一个来//剩下部分通过搜索解决bool vis[maxn];bool ok=0;void dfs(int rt,string now,int tot){ //cout&lt;&lt;rt&lt;&lt;\" \"&lt;&lt;now&lt;&lt;\" \"&lt;&lt;tot&lt;&lt;endl; if(ok)return; if(tot==n) { cout&lt;&lt;now&lt;&lt;endl; ok=1; return; } for(int i=0;i&lt;son[rt].size();i++) { int to=son[rt][i]; int nt=num[rt][i]; if(vis[nt])continue; vis[nt]=1; dfs(to,now+\".\"+x[nt],tot+1); vis[nt]=0; }}int fa[maxn];int Find(int x){ if(fa[x]==x)return x; return fa[x]=Find(fa[x]);}bool app[99];signed main(){ scanf(\"%d\",&amp;n); for(int i=0;i&lt;=n;i++)fa[i]=i; for(int i=1;i&lt;=n;i++)//连边 { cin&gt;&gt;x[i]; } sort(x+1,x+1+n); for(int i=1;i&lt;=n;i++) { son[x[i][0]-'a'].push_back(x[i][x[i].size()-1]-'a'); num[x[i][0]-'a'].push_back(i); h[x[i][0]-'a']++; t[x[i][x[i].size()-1]-'a']++; app[x[i][x[i].size()-1]-'a']=1; app[x[i][0]-'a']=1; fa[x[i][0]-'a']=Find(x[i][x[i].size()-1]-'a'); } //确定第一个出现的 int af=-inf; int s=x[1][0]-'a';//默认1 for(int i=0;i&lt;26;i++) { if(app[i]) { if(af==-inf)af=Find(i); else { if(Find(i)!=af) { printf(\"***\"); return 0; } } if(h[i]-t[i]==1) { s=i; } } } for(int i=0;i&lt;1;i++) { vis[num[s][i]]=1; dfs(son[s][i],x[num[s][i]],1); vis[num[s][i]]=0; } if(!ok) { printf(\"***\"); } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1801 黑匣子","date":"2020-07-12T07:00:02.000Z","path":"2020/07/12/P1801-黑匣子/","text":"对顶堆 发现i是单调不降的，可以使用对顶堆解决问题 类似问题：P1168中位数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffpriority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q2;//小的在上头priority_queue&lt;int&gt; q1;//大的在上头，大小控制为i int a[200009],t[200009];signed main(){ //freopen(\"h.in\",\"r\",stdin); int n,m; scanf(\"%d%d\",&amp;m,&amp;n); for(int i=1;i&lt;=m;i++)scanf(\"%d\",&amp;a[i]); int j=1; for(int i=1;i&lt;=n;i++) { int x; scanf(\"%d\",&amp;x); for(;j&lt;=x;j++) { q1.push(a[j]); while(q1.size()&lt;i)//保证q1的长度为i { q1.push(q2.top()); q2.pop(); } while(q1.size()&gt;i) { q2.push(q1.top()); q1.pop(); } while(!q1.empty()&amp;&amp;!q2.empty()&amp;&amp;q1.top()&gt;q2.top())//保证q1的top更小 { int l=q1.top(),k=q2.top(); q1.pop();q2.pop(); q2.push(l);q1.push(k); } //printf(\"i:%dj:%d %d\\n\",i,j,q1.top()); } while(q1.size()&lt;i) { q1.push(q2.top()); q2.pop(); } while(q1.size()&gt;i) { q2.push(q1.top()); q1.pop(); } while(!q1.empty()&amp;&amp;!q2.empty()&amp;&amp;q1.top()&gt;q2.top()) { int l=q1.top(),k=q2.top(); q1.pop();q2.pop(); q2.push(l);q1.push(k); } printf(\"%d\\n\",q1.top()); } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"myx","date":"2020-07-10T09:22:08.000Z","path":"2020/07/10/myx/","text":"愿君一路星光、前程似锦，所得皆所愿、扬帆起远航、不负青春梦！他日江湖再相见，历经千帆仍少年～ 李佩璇 祝愿帅气的马宇轩同学在新的学校里闪闪发光，熠熠生辉，实现自己的理想，学业有成，前程似锦，一路星光！ 王一诺 也许这是短暂的两年吧，未来的道路依然漫长。愿我们都能 “长风破浪会有时，直挂云帆济沧海”。希望这份情谊，永存。 lzy (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"/myx/a.MOV\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"/myx/z.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer2\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"/myx/d.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer3\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"/myx/c.mp4\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P1621 集合","date":"2020-06-21T10:58:12.000Z","path":"2020/06/21/P1621-集合/","text":"用埃筛枚举质数作为质因子，看看能不能变成区间里的数字 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffint fa[100020];int v[100020];int a,b,p,s=0;;int Find(int x){ if(x==fa[x])return x; return fa[x]=Find(fa[x]);}signed main(){ scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;p); for(int i=1;i&lt;=b;i++)fa[i]=i; for(int i=2;i&lt;=b;i++) { if(!v[i]) { for(int j=i;j&lt;=b;j+=i) { v[j]=1; if(i&gt;=p&amp;&amp;j-i&gt;=a) { if(Find(j)!=Find(j-i)) { fa[Find(j)]=Find(j-i); s++; } } } } } printf(\"%d\\n\",b-a+1-s); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P3613 【深基15.例2】寄包柜","date":"2020-06-21T10:57:21.000Z","path":"2020/06/21/P3613-【深基15-例2】寄包柜/","text":"123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffint n,m;map&lt;pair&lt;int,int&gt;,int&gt; mp;//直接用map映射pair实现 signed main(){ scanf(\"%d%d\",&amp;n,&amp;m); while(m--) { int opt,x,y,z; scanf(\"%d%d%d\",&amp;opt,&amp;x,&amp;y); if(opt==1) { scanf(\"%d\",&amp;z); mp[make_pair(x,y)]=z; }else { printf(\"%d\\n\",mp.count(make_pair(x,y))==0?0:mp[make_pair(x,y)]); } } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P4715 【深基16.例1】淘汰赛","date":"2020-06-21T10:56:09.000Z","path":"2020/06/21/P4715-【深基16-例1】淘汰赛/","text":"123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffint a[250];signed main(){ int n; scanf(\"%d\",&amp;n); n=1&lt;&lt;n; for(int i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } //上半区的最大值 下半区的最大值 两个中较小的一个就是答案 cout&lt;&lt;max_element(a,a+n/2)-max_element(a,a+n)+max_element(a+n/2,a+n)-a+1&lt;&lt;endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P3884 [JLOI2009]二叉树问题","date":"2020-06-21T10:55:20.000Z","path":"2020/06/21/P3884-JLOI2009-二叉树问题/","text":"123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffint c[120],d[120],f[120];int x,y,n;signed main(){ scanf(\"%d\",&amp;n); int md=0; c[d[1]]++; for(int i=1;i&lt;n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); f[y]=x; d[y]=d[x]+1; md=max(md,d[y]); c[d[y]]++;//宽度就是某一个深度的节点个数 }int mc=1; for(int i=1;i&lt;=n;i++)mc=max(mc,c[i]); int x,y; scanf(\"%d%d\",&amp;x,&amp;y); int z=0; while(x!=y) { if(d[x]&lt;d[y]) { y=f[y]; z++; }else { x=f[x]; z+=2; } } printf(\"%d\\n%d\\n%d\",md+1,mc,z); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P1364 医院设置","date":"2020-06-21T10:54:30.000Z","path":"2020/06/21/P1364-医院设置/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffint s[120];//sizeint f[120];int l[120];//lsonint r[120];//rsonint n;void dfs(int x){ if(x) { dfs(l[x]); s[x]+=s[l[x]]; f[x]+=f[l[x]]+s[l[x]]; dfs(r[x]); s[x]+=s[r[x]]; f[x]+=f[r[x]]+s[r[x]]; }}signed main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d%d%d\",&amp;s[i],&amp;l[i],&amp;r[i]); } dfs(1); int x=1,z=f[x]; while(1) { if(s[l[x]]*2&gt;s[1])//左边人多，他的两倍比总人数多 { z+=s[1]-2*s[l[x]];//往左走 x=l[x]; }else if(s[r[x]]*2&gt;s[1])//同理往右 { z+=s[1]-2*s[r[x]]; x=r[x]; }else break; } printf(\"%d\\n\",z); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P1160 队列安排","date":"2020-06-21T08:48:39.000Z","path":"2020/06/21/P1160-队列安排/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffff#define maxn 100020int l[maxn],r[maxn],v[maxn];void dfs(int x){ if(!x)return; dfs(l[x]); if(!v[x])cout&lt;&lt;x&lt;&lt;\" \"; dfs(r[x]);}signed main(){ int n; scanf(\"%d\",&amp;n); for(int i=2;i&lt;=n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); if(y==0)//加入，替换掉原来这个位置的人把他接到这个加入的人后面 { l[i]=l[x]; l[x]=i; }else//同理 { r[i]=r[x]; r[x]=i; } } scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { int x; scanf(\"%d\",&amp;x); v[x]=1; } dfs(1); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P4387【深基15.习9】验证栈序列","date":"2020-06-21T08:27:48.000Z","path":"2020/06/21/P4387【深基15-习9】验证栈序列/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;//一直push，直到匹配到一个pop /*栗子： 1 2 3 4 55 4 3 2 1用一个栈模拟，一直入队直到当前入队的是出栈队列的第一项 出栈，继续模拟 */using namespace std;#define ll long long#define inf 0x7fffffffint s[200020],ss;int a[100020]; int n;signed main(){ int T; scanf(\"%d\",&amp;T); while(T--) { ss=0; memset(s,0,sizeof(s)); scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)scanf(\"%d\",&amp;a[i]); for(int i=0,j=0;j&lt;n;j++) { int x; scanf(\"%d\",&amp;x); while(i&lt;n&amp;&amp;(s[ss]!=x)) { s[++ss]=a[i++]; } if(s[ss]==x) { ss--; } } puts(ss&gt;0?\"No\":\"Yes\"); } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P5250【深基17.例5】木材仓库","date":"2020-06-21T07:22:54.000Z","path":"2020/06/21/P5250【深基17-例5】木材仓库/","text":"水一发板子题 合理使用map和c++11 auto类型可以自动识别，在c++11下，可以节省很多代码 这里用auto代替了iterator 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffsigned main(){ map &lt;string,int&gt; mp; int n; cin&gt;&gt;n; while(n--) { int opt; cin&gt;&gt;opt; if(opt==1) { string name; int sc; cin&gt;&gt;name&gt;&gt;sc; mp[name]=sc; cout&lt;&lt;\"OK\"&lt;&lt;endl; }else if(opt!=4) { string name; cin&gt;&gt;name; auto it=mp.find(name); if(opt==2) { if(it!=mp.end()) { cout&lt;&lt;mp[name]&lt;&lt;endl; }else { cout&lt;&lt;\"Not found\"&lt;&lt;endl; } }else if(opt==3) { if(it!=mp.end()) { mp.erase(name); cout&lt;&lt;\"Deleted successfully\"&lt;&lt;endl; }else { cout&lt;&lt;\"Not found\"&lt;&lt;endl; } } }else cout&lt;&lt;mp.size()&lt;&lt;endl; } return 0;}//c++11 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"如何安全的举报自己的学校？","date":"2020-05-21T13:39:08.000Z","path":"2020/05/21/如何安全的举报自己的学校？/","text":"蒟蒻开学了emm 今天教教大家两种安全举报学校的方法 法1首先，找到你所在省/市的教育主管部门由于咱们是山东人，所以找到山东省教育厅:http://edu.shandong.gov.cn/ 重点，什么信访条例，什么匿名不公开，全部是假的，举报不能留下任何个人身份信息，包括自己的ip地址 接下来，连接到VPN是的，根据前人的惨痛教训你的IP可能会被卖掉 这边奉上百度第一条https://www.xicidaili.com/nn/ 最好是高匿代理，国内外都可 注意，有很多代理简直上不了网，可以多试几个，另外不要输入敏感信息，因为你所有联网的数据都会发送给代理服务器，最好退掉微信QQ啥的，搞完之后一定断开代理 连接方法： PC：https://jingyan.baidu.com/article/6fb756ec5f5dd4241858fb85.html 手机：https://jingyan.baidu.com/article/6fb756ec5f5dd4241858fb85.html 填写信息这边山东省教育厅需要点击“留言咨询” 姓名瞎编，手机号和邮箱一定要使用临时的 这边有一篇推荐临时邮箱的文章：https://www.jianshu.com/p/adc971eb5cfe https://temp-mail.org/ 这个我觉得速度还行，其他的要么时间短，要么上不去 临时手机号来这里：https://www.materialtools.com/ 证件的话，如果必须填真实的，不要写你自己或者家人，最好找一个和你们学校和你关系不大的人，当然，搞个假的最好 剩下的大家随意发挥，切记不要留下任何真实信息（除了举报内容 本方法有一定暴露风险~不过应该不大，我觉得防护措施已经足够严密了2333 小心内鬼 法2写封信不就完了 不要留下真实信息，直接寄到教育局，谁都查不出来hhhh document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"CF1178D Prime Graph","date":"2020-05-21T13:38:00.000Z","path":"2020/05/21/CF1178D Prime Graph/","text":"1234567891011121314151617181920212223242526272829303132333435363738/*显然1000以内，n到3/2n中肯定有一个质数（没有证明，但是可以枚举试试 所以 先把n个点连成环，在中间两点之间加边，每个点的度为2或3，控制边数是个质数就可以 */#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffbool Prime(int x){ for(int i=2;i&lt;=sqrt(x);i++) { if(x%i==0)return 0; } return 1;}signed main(){ int n; cin&gt;&gt;n; int m=n; while(!Prime(m)) { m++; } cout&lt;&lt;m&lt;&lt;endl; for(int i=1;i&lt;=n;i++) { int x=i+1; if(x&gt;n)x=1; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;x&lt;&lt;endl; } for(int i=1;i&lt;=m-n;i++) { cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;n/2+i&lt;&lt;endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"CF1220D Alex and Julian","date":"2020-05-19T12:49:46.000Z","path":"2020/05/19/CF1220D Alex and Julian/","text":"前置知识：二分图的判定没有奇环 做法考虑从0开始，$lcm(a,b)$构成的环为奇环 \\frac { lcm(a,b)} { a }+\\frac{ lcm ( a,b ) } { b} \\equiv 1(mod 2)有 \\frac{a+b}{gcd(a,b)} \\equiv 1(mod 2)当且仅当a,b中2的因子个数相等时，ab无法构成奇环，这种情况下$\\frac{a}{gcd(a,b)}$和$\\frac{b}{gcd(a,b)}$都是奇数 （本句话引自lg大佬，不会可以手动验证，好好想，蒟蒻数学这么差都想通了，画画图） 也就是说，对于任意两个数字，如果他们的lowbit相等，他们不会构成奇环 于是问题变成了 求n个数中lowbit相等的数字最多有多少个 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffffint n;#define maxn 200009ll a[maxn]; #define lowbit(x) (x&amp;(-x))vector&lt;ll&gt; num[69];signed main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%lld\",&amp;a[i]); } //两个数lowbit相同就可以保留 //直接枚举lowbit？ int ans=0,w; for(int i=0;i&lt;=60;i++) { int s=0; for(int j=1;j&lt;=n;j++) { //cout&lt;&lt;lowbit(a[j])&lt;&lt;\" \"&lt;&lt;(1&lt;&lt;i)&lt;&lt;endl; if(lowbit(a[j])==(1ll&lt;&lt;i)) { s++; }else { num[i].push_back(a[j]); } } if(s&gt;ans) { w=i,ans=s; } } printf(\"%d\\n\",n-ans); for(int i=0;i&lt;num[w].size();i++) { printf(\"%lld\\n\",num[w][i]); } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"P6275 [USACO20OPEN]Sprinklers 2: Return of the Alfalfa P ","date":"2020-05-12T13:41:15.000Z","path":"2020/05/12/P6275-USACO20OPEN-Sprinklers-2-Return-of-the-Alfalfa-P/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//轮廓线dp/*发现A、C作物之间一定有一条分割线，分割线的拐角处必须放灌溉器，剩下位置可以不放 但是如果要放，放的灌溉器种类是一定的 dp合法轮廓线的数量 设每一条轮廓线的权值是-2^拐角数量 每一次转移，如果拐弯了就要除以二 */ #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffff#define maxn 2009#define int llint n;char c[maxn][maxn];#define mod 1000000007#define inv (500000004)int f[maxn][maxn];//f表示横着来的 //有什么方法可以转移到f[i][j]?/*f[i][j-1]-&gt;f[i][j]g[i][j-1]/2-&gt;f[i][j]f[i-1][j]/2-&gt;g[i][j]g[i-1][j]-&gt;g[i][j]*/ int g[maxn][maxn];//g表示竖着来的 ll ksm(int a,int b){ ll ans=1,base=a; while(b) { if(b&amp;1) { ans*=base; ans%=mod; } base*=base; base%=mod; } return ans;}signed main(){ scanf(\"%lld\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%s\",c[i]+1); } for(int i=1;i&lt;=n+1;i++) { f[1][i]=1; g[i][1]=1; } for(int i=2;i&lt;=n+1;i++)//i可以取到n+1 { for(int j=2;j&lt;=n+1;j++) { f[i][j]=f[i][j-1]; if(c[i-1][j-1]!='W')//这边ij从1开始，所以要减一 { f[i][j]=(f[i][j]+(ll)g[i][j-1]*inv)%mod; } g[i][j]=g[i-1][j]; if(c[i-1][j-1]!='W') { g[i][j]=(g[i][j]+(ll)f[i-1][j]*inv)%mod; } // cout&lt;&lt;f[i][j]&lt;&lt;\" \"&lt;&lt;g[i][j]&lt;&lt;endl; } } int ans=(g[n+1][n+1]+f[n+1][n+1])%mod; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(c[i][j]!='W') { ans=(ans*2)%mod; } } } printf(\"%lld\\n\",ans); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"母亲节快乐！","date":"2020-05-10T14:32:34.000Z","path":"2020/05/10/mother/","text":"1.妈妈 你把心铺成路，还怕我磕了脚 2感谢你不是超人，却为我变成了万能 3岁月从不败我的美人妈妈 ️ 4小棉袄会努力成为你的防弹衣 5你说你是妈妈的防弹衣，后来才知道你是妈妈的催泪弹 6别问你妈想要什么礼物，她就是想要我这样的女婿(儿媳妇） 7听说神不能无处不在，所以创造了妈妈 8我加倍努力，就是希望成长的脚步，可以赶上您老去的速度 9曾厌恶你的市侩圆滑，却忘了你也曾松花酿酒，春水煮茶 10从前的愿望是仗剑走天涯，现在只想赖在你身边，听你细数年华 11整个世界都在催我长大，而你却心疼我的小翅膀 12羡慕我爸，娶到了世界上最好的女人 13和妈妈吵架的时候，摸摸自己肚子的肉，那是妈妈在外面赚钱养的。 14这个世界上只有你，愿意包容我的一千种任性。 15我快快长大，你慢慢变老ᵀᴴᴱ ᴮᴱˢᵀ ᴵˢ ᶠᴼᴿ ᵞᴼᵁ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"P3258","date":"2020-05-07T07:24:38.000Z","path":"2020/05/07/P3258/","text":"树剖裸题啦 每走一次路径+1 最后一个房间答案-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x7fffffff#define maxn 300005int fa[maxn],son[maxn],top[maxn],pos[maxn],dfn[maxn],size[maxn],dep[maxn];vector&lt;int&gt; e[maxn];int cnt=0;int n;int a[maxn];struct node{ int l,r; int mark; int val;}tr[maxn*4];void dfs(int x){ size[x]=1; for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i]; if(!size[to]) { dep[to]=dep[x]+1; fa[to]=x; dfs(to); size[x]+=size[to]; if(size[son[x]]&lt;size[to]) { son[x]=to; } } }}void dfs2(int x,int tp){ cnt++; pos[x]=cnt; dfn[cnt]=x; top[x]=tp; if(son[x]!=0)dfs2(son[x],tp); for(int i=0;i&lt;e[x].size();i++) { int to=e[x][i]; if(top[to])continue; dfs2(to,to); }}void Build(int x,int l,int r){ tr[x].l=l,tr[x].r=r; if(l==r) { tr[x].mark=0; tr[x].val=0; return; } int mid=(l+r)&gt;&gt;1; Build(x*2,l,mid); Build(x*2+1,mid+1,r); tr[x].mark=0; tr[x].val=0;}void relese(int x){ if(tr[x].l==tr[x].r||0==tr[x].mark) { return; } int ma=tr[x].mark; int ls=x*2,rs=x*2+1; int lsl=tr[ls].r-tr[ls].l+1; int rsl=tr[rs].r-tr[rs].l+1; tr[ls].val+=lsl*ma; tr[ls].mark+=ma; tr[rs].mark+=ma; tr[rs].val+=rsl*ma; tr[x].mark=0;}void Add(int x,int l,int r,int val){ if(l&lt;=tr[x].l&amp;&amp;tr[x].r&lt;=r) { tr[x].val+=val*(tr[x].r-tr[x].l+1); tr[x].mark+=val; return; } relese(x); int mid=(tr[x].l+tr[x].r)&gt;&gt;1; if(l&lt;=mid)Add(x*2,l,r,val); if(r&gt;mid)Add(x*2+1,l,r,val); tr[x].val=tr[x*2].val+tr[x*2+1].val;}void L_Add(int x,int y){ while(top[x]!=top[y]) { if(dep[top[x]]&lt;dep[top[y]])swap(x,y); // cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;\" \"&lt;&lt;dep[top[x]]&lt;&lt;\" \"&lt;&lt;dep[top[y]]&lt;&lt;endl; Add(1,pos[top[x]],pos[x],1); x=fa[top[x]]; } if(pos[x]&gt;pos[y])swap(x,y); Add(1,pos[x],pos[y],1);}int Query(int x,int p)//单点查询 { if(tr[x].l==tr[x].r) { return tr[x].val; } relese(x); int mid=(tr[x].l+tr[x].r)&gt;&gt;1; if(p&lt;=mid)return Query(x*2,p); else return Query(x*2+1,p);}signed main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;a[i]); } for(int i=1;i&lt;n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); e[x].push_back(y); e[y].push_back(x); } dep[1]=1; dfs(1); dfs2(1,1); Build(1,1,n); for(int i=2;i&lt;=n;i++) { L_Add(a[i-1],a[i]); if(2!=i)Add(1,pos[a[i-1]],pos[a[i-1]],-1); // cout&lt;&lt;a[i-1]&lt;&lt;\" \"&lt;&lt;a[i]&lt;&lt;endl; } Add(1,pos[a[n]],pos[a[n]],-1); for(int j=1;j&lt;=n;j++) { printf(\"%d\\n\",Query(1,pos[j])); } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"OI","slug":"OI","permalink":"https://lzylzy.cf/tags/OI/"}]},{"title":"Hello World","date":"2020-05-02T10:12:05.890Z","path":"2020/05/02/hello-world/","text":"啊这里是lzylzy是一个正在初中挣扎的蒟蒻 QAQ信竞和文化课都好难嘤嘤嘤 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]}]